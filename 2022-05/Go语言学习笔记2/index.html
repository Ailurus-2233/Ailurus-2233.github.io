

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/system/icon.jpg">
  <link rel="icon" href="/images/system/icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ailurus">
  <meta name="keywords" content="">
  
    <meta name="description" content="整理学习go基础的过程中，一些基础语法以及相关的问题">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言学习笔记-复合类型">
<meta property="og:url" content="http://blog.ailurus2233.site/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/index.html">
<meta property="og:site_name" content="Ailurusの客栈">
<meta property="og:description" content="整理学习go基础的过程中，一些基础语法以及相关的问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/mArr.png">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/slice.png">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/map1.png">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/map2.png">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/map3.png">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/map4.png">
<meta property="og:image" content="http://blog.ailurus2233.site/page/2022-05/map5.png">
<meta property="article:published_time" content="2022-05-06T07:30:48.000Z">
<meta property="article:modified_time" content="2022-05-06T08:12:37.002Z">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://blog.ailurus2233.site/page/2022-05/mArr.png">
  
  
  <title>Go语言学习笔记-复合类型 - Ailurusの客栈</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.ailurus2233.site","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ailurus&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/system/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Go语言学习笔记-复合类型">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Ailurus
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-06 15:30" pubdate>
        2022年5月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      120 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Go语言学习笔记-复合类型</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年5月6日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="数组类型">数组类型</h1>
<p>Go
语言的数组是一个长度固定的、由同构类型元素组成的连续序列。通过这个定义，我们可以识别出
Go
的数组类型包含两个重要属性：元素的类型和数组长度（元素的个数）。这两个属性也直接构成了
Go 语言中数组类型变量的声明：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [N]T<br></code></pre></div></td></tr></table></figure>
<p>如果两个数组类型的元素类型 T 与数组长度 N
都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(arr [5]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr3 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><br>    foo(arr1) <span class="hljs-comment">// ok</span><br>    foo(arr2) <span class="hljs-comment">// 错误：[6]int与函数foo参数的类型[5]int不是同一数组类型</span><br>    foo(arr3) <span class="hljs-comment">// 错误：[5]string与函数foo参数的类型[5]int不是同一数组类型</span><br>&#125;  <br></code></pre></div></td></tr></table></figure>
<p>数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。Go
编译器在为数组类型的变量实际分配内存时，会为 Go
数组分配一整块、可以容纳它所有元素的连续内存。</p>
<p>从这个数组类型的内存表示中可以看出来，这块内存全部空间都被用来表示数组元素，所以说这块内存的大小，就等于各个数组元素的大小之和。如果两个数组所分配的内存大小不同，那么它们肯定是不同的数组类型。Go
提供了预定义函数 <code>len</code>
可以用于获取一个数组类型变量的长度，通过 <code>unsafe</code> 包提供的
<code>Sizeof</code>
函数，我们可以获得一个数组变量的总大小，如下面代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;数组长度：&quot;</span>, <span class="hljs-built_in">len</span>(arr))           <span class="hljs-comment">// 6</span><br>fmt.Println(<span class="hljs-string">&quot;数组大小：&quot;</span>, unsafe.Sizeof(arr)) <span class="hljs-comment">// 6 * 8 = 48</span><br></code></pre></div></td></tr></table></figure>
<p>和基本数据类型一样，我们声明一个数组类型变量的同时，也可以显式地对它进行初始化。我们需要在右值中显式放置数组类型，并通过大括号的方式给各个元素赋值（如下面代码中的
arr2）。如果不进行显式初始化，那么数组中的元素值就是它类型的零值。我们也可以忽略掉右值初始化表达式中数组类型的长度，用“…”替代，Go
编译器会根据数组元素的个数，自动计算出数组长度。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// [0 0 0 0 0 0]</span><br><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>,<br>&#125; <span class="hljs-comment">// [11 12 13 14 15 16]</span><br><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-type">int</span> &#123; <br>    <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>,<br>&#125; <span class="hljs-comment">// [21 22 23]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr3) <span class="hljs-comment">// [3]int</span><br><br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-number">99</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">// 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr4) <span class="hljs-comment">// [100]int</span><br></code></pre></div></td></tr></table></figure>
<h1 id="多维数组">多维数组</h1>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mArr [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></div></td></tr></table></figure>
<p>多维数组也不难理解，我们以上面示例中的多维数组类型为例，我们从左向右逐维地去看，这样我们就可以将一个多维数组分层拆解成这样</p>
<p><img src="/page/2022-05/mArr.png" srcset="/img/loading.gif" lazyload /></p>
<p>虽然数组类型是 Go
语言中最基础的复合数据类型，但是在使用中它也会有一些问题。数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。这点与
C 语言完全不同，在 C
语言中，数组变量可视为指向数组第一个元素的指针。这样一来，无论是参与迭代，还是作为实际参数传给一个函数
/ 方法，Go
传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。虽然可以使用指针的方式，来向函数传递数组，但这样做的确可以避免性能损耗，但这更像是
C 语言的惯用法。其实，Go 语言为我们提供了一种更为灵活、更为地道的方式
，切片，来解决这个问题。它的优秀特性让它成为了 Go
语言中最常用的同构复合类型。</p>
<h1 id="切片">切片</h1>
<p>初始化切片</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></div></td></tr></table></figure>
<p>与数组声明相比，切片声明仅仅是少了一个“长度”属性。去掉“长度”这一束缚后，切片展现出更为灵活的特性，这些特性我们后面再分析。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 6</span><br><br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">7</span>) <span class="hljs-comment">// 切片变为[1 2 3 4 5 6 7]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码，表示的是通过len获取切片长度，通过append追加7到切片后面，长度也会对应变化。</p>
<h2 id="切片的底层实现">切片的底层实现</h2>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer<br>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>每个切片包含三个字段：</p>
<ul>
<li>array: 是指向底层数组的指针；</li>
<li>len: 是切片的长度，即切片中当前元素的个数；</li>
<li>cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len
值。</li>
</ul>
<h3 id="其他切片的创建方式">其他切片的创建方式</h3>
<p><strong>方法一：通过 make
函数来创建切片，并指定底层数组的长度。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 其中10为cap值，即底层数组长度，6为切片的初始长度</span><br></code></pre></div></td></tr></table></figure>
<p>如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len</p>
<p><strong>方法二：采用 array[low : high :
max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化</strong></p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>sl := arr[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>]<br></code></pre></div></td></tr></table></figure>
<p>我们基于数组 arr 创建了一个切片 sl，这个切片 sl
在运行时中的表示是这样</p>
<p><img src="/page/2022-05/slice.png" srcset="/img/loading.gif" lazyload /></p>
<p>我们看到，基于数组创建的切片，它的起始元素从 low
所标识的下标值开始，切片的长度（len）是 high - low，它的容量是 max -
low。而且，由于切片 sl 的底层数组就是数组 arr，对切片 sl
中元素的修改将直接影响数组 arr 变量。比如，如果我们将切片的第一个元素加
10，那么数组 arr 的第四个元素将变为 14。</p>
<p>切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。这有些类似于我们操作文件之前打开的“文件描述符”（Windows
上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。可以说，切片之于数组就像是文件描述符之于文件。</p>
<p>针对一个已存在的数组，我们还可以建立多个操作数组的切片，这些切片共享同一底层数组，切片对底层数组的操作也同样会反映到其他切片中。</p>
<p><strong>方法三：基于切片创建切片</strong></p>
<p>这种切片的运行时表示原理与上面的是一样的</p>
<h2 id="切片的动态扩容">切片的动态扩容</h2>
<p>“动态扩容”指的就是，当我们通过 append
操作向切片追加数据的时候，如果这时切片的 len 值和 cap
值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go
运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。前面的切片变量
nums 之所以可以存储下新追加的值，就是因为 Go
对其进行了动态扩容，也就是重新分配了其底层数组，从一个长度为 6
的数组变成了一个长为 12 的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">11</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//1 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">13</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//3 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">14</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//4 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">15</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//5 8</span><br></code></pre></div></td></tr></table></figure>
<p>append
操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">u := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;array:&quot;</span>, u) <span class="hljs-comment">// [11, 12, 13, 14, 15]</span><br>s := u[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s) <span class="hljs-comment">// [12, 13]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">24</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 24, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 24, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">25</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 25, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 25, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">26</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 26, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 26, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span><br>fmt.Println(<span class="hljs-string">&quot;after reassign 1st elem of slice, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br></code></pre></div></td></tr></table></figure>
<p>运行这段代码，我们得到这样的结果</p>
<figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br><span class="hljs-keyword">slice</span>(len=<span class="hljs-number">2</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">24</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">15</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">24</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">3</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">25</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">25</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">4</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">26</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">26</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">5</span>, cap=<span class="hljs-number">8</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]<br><span class="hljs-keyword">after</span> <span class="hljs-keyword">reassign</span> <span class="hljs-number">1</span>st elem <span class="hljs-keyword">of</span> <span class="hljs-keyword">slice</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> <span class="hljs-keyword">reassign</span> <span class="hljs-number">1</span>st elem <span class="hljs-keyword">of</span> <span class="hljs-keyword">slice</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">5</span>, cap=<span class="hljs-number">8</span>): [<span class="hljs-number">22</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]<br></code></pre></div></td></tr></table></figure>
<p>这里，在 append 25 之后，切片的元素已经触碰到了底层数组 u
的边界了。然后我们再 append 26 之后，append 发现底层数组已经无法满足
append 的要求，于是新创建了一个底层数组（数组长度为 cap(s) 的 2 倍，即
8），并将 slice 的元素拷贝到新数组中了。</p>
<p>在这之后，我们即便再修改切片的第一个元素值，原数组 u
的元素也不会发生改变了，因为这个时候切片 s 与数组 u
已经解除了“绑定关系”，s 已经不再是数组 u
的“描述符”了。这种因切片的自动扩容而导致的“绑定关系”解除，有时候会成为实践道路上的一个小陷阱，一定要注意这一点。</p>
<h1 id="map-类型">Map 类型</h1>
<p>map 是 Go
语言提供的一种抽象数据类型，它表示一组无序的键值对。在后面的讲解中，我们会直接使用
key 和 value 分别代表 map 的键和值。而且，map 集合中每个 key
都是唯一的。和切片类似，作为复合类型的 map，它在 Go 中的类型表示也是由
key 类型与 value 类型组成的，就像下面代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[key_type]value_type<br></code></pre></div></td></tr></table></figure>
<p>这里，我们要注意，map 类型对 value 的类型没有限制，但是对 key
的类型却有严格要求，因为 map 类型要保证 key 的唯一性。Go 语言中要求，key
的类型必须支持<code>==</code>和<code>!=</code>两种比较操作符。</p>
<p>在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil
的比较，而不支持同类型两个变量的比较。如果像下面代码这样，进行这些类型的比较，Go
编译器将会报错：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><span class="hljs-built_in">println</span>(s1 == s2) <span class="hljs-comment">// 错误：invalid operation: s1 == s2 (slice can only be compared to nil)</span><br><span class="hljs-built_in">println</span>(f1 == f2) <span class="hljs-comment">// 错误：invalid operation: f1 == f2 (func can only be compared to nil)</span><br><span class="hljs-built_in">println</span>(m1 == m2) <span class="hljs-comment">// 错误：invalid operation: m1 == m2 (map can only be compared to nil)</span><br></code></pre></div></td></tr></table></figure>
<p>因此在这里，你一定要注意：函数类型、map
类型自身，以及切片类型是不能作为 map 的 key 类型的。</p>
<h2 id="map-变量的声明和初始化">map 变量的声明和初始化</h2>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 一个map[string]int类型的变量</span><br></code></pre></div></td></tr></table></figure>
<p>和切片类型变量一样，如果我们没有显式地赋予 map 变量初值，map
类型变量的默认值为 nil。不过切片变量和 map
变量在这里也有些不同。初值为零值 nil 的切片类型变量，可以借助内置的
append 的函数进行操作，这种在 Go 语言中被称为“零值可用”。但 map
类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的
map
变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// m = nil</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-number">1</span>         <span class="hljs-comment">// 发生运行时异常：panic: assignment to entry in nil map</span><br></code></pre></div></td></tr></table></figure>
<p>为 map
类型变量显式赋值有两种方式：一种是使用复合字面值；另外一种是使用 make
这个预声明的内置函数。</p>
<p><strong>方法一：使用复合字面值初始化 map 类型变量。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>这里，我们显式初始化了 map 类型变量 m。不过，你要注意，虽然此时 map
类型变量 m 中没有任何键值对，但变量 m 也不等同于初值为 nil 的 map
变量。这个时候，我们对 m 进行键值对的插入操作，不会引发运行时异常。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-number">1</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val1_1&quot;</span>, <span class="hljs-string">&quot;val1_2&quot;</span>&#125;,<br>    <span class="hljs-number">3</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val3_1&quot;</span>, <span class="hljs-string">&quot;val3_2&quot;</span>, <span class="hljs-string">&quot;val3_3&quot;</span>&#125;,<br>    <span class="hljs-number">7</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val7_1&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123; <br>    x <span class="hljs-type">float64</span> <br>    y <span class="hljs-type">float64</span><br>&#125;<br><br>m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    Position&#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    Position&#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    Position&#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>Go 还提供了“语法糖”。这种情况下，Go 允许省略字面值中的元素类型。因为
map 类型表示中包含了 key 和 value 的元素类型，Go
编译器已经有足够的信息，来推导出字面值中各个值的类型了。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    &#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    &#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    &#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>方法二：使用 make 为 map
类型变量进行显式初始化。</strong></p>
<p>和切片通过 make 进行初始化一样，通过 make 的初始化方式，我们可以为
map
类型变量指定键值对的初始容量，但无法进行具体的键值对赋值，就像下面代码这样：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 未指定初始容量</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 指定初始容量为8</span><br></code></pre></div></td></tr></table></figure>
<p>map
类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量后，Go
运行时会自动增加 map 类型的容量，保证后续键值对的正常插入。</p>
<h2 id="map-基本操作">Map 基本操作</h2>
<p><strong>操作一：插入新键值对。</strong></p>
<p>面对一个非 nil 的 map 类型变量，我们可以在其中插入符合 map
类型定义的任意新键值对。插入新键值对的方式很简单，我们只需要把 value
赋值给 map 中对应的 key 就可以了：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value1&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;value2&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;value3&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>不过，如果我们插入新键值对的时候，某个 key 已经存在于 map
中了，那我们的插入操作就会用新值覆盖旧值：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 11会覆盖掉&quot;key1&quot;对应的旧值1</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment">// 此时m为map[key1:11 key2:2 key3:3]</span><br></code></pre></div></td></tr></table></figure>
<p><strong>操作二：获取键值对数量。</strong></p>
<p>和切片一样，map 类型也可以通过内置函数
len，获取当前变量已经存储的键值对数量:</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 2</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>这里要注意的是我们不能对 map 类型变量调用 cap，来获取当前容量，这是
map 类型与切片类型的一个不同点。</p>
<p><strong>操作三：查找和数据读取</strong></p>
<p>和写入相比，map
类型更多用在查找和数据读取场合。所谓查找，就是判断某个 key
是否存在于某个 map 中。有了前面向 map
插入键值对的基础，我们可能自然而然地想到，可以用下面代码去查找一个键并获得该键对应的值：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v := m[<span class="hljs-string">&quot;key1&quot;</span>]<br></code></pre></div></td></tr></table></figure>
<p>乍一看，第二行代码在语法上好像并没有什么不当之处，但其实通过这行语句，我们还是无法确定键
key1 是否真实存在于 map
中。这是因为，当我们尝试去获取一个键对应的值的时候，如果这个键在 map
中并不存在，我们也会得到一个值，这个值是 value 元素类型的零值。</p>
<p>那么在 map 中查找 key 的正确姿势是什么呢？Go 语言的 map
类型支持通过用一种名为“comma ok”的惯用法，进行对某个 key
的查询。接下来我们就用“comma ok”惯用法改造一下上面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br>    <span class="hljs-comment">// &quot;key1&quot;不在map中</span><br>&#125;<br><br><span class="hljs-comment">// &quot;key1&quot;在map中，v将被赋予&quot;key1&quot;键对应的value</span><br></code></pre></div></td></tr></table></figure>
<p>如果我们并不关心某个键对应的 value，而只关心某个键是否在于 map
中，我们可以使用空标识符替代变量 v，忽略可能返回的 value：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>_, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br>... ...<br></code></pre></div></td></tr></table></figure>
<p>因此，一定要记住：在 Go 语言中，请使用“comma ok”惯用法对 map
进行键查找和键值读取操作。</p>
<p><strong>操作四：删除数据。</strong></p>
<p>在 Go 中，我们需要借助内置函数 delete 来从 map 中删除数据。使用
delete 函数的情况下，传入的第一个参数是我们的 map
类型变量，第二个参数就是我们想要删除的键。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key2&quot;</span>) <span class="hljs-comment">// 删除&quot;key2&quot;</span><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1]</span><br></code></pre></div></td></tr></table></figure>
<p>这里要注意的是，delete 函数是从 map 中删除键的唯一方法。即便传给
delete 的键在 map 中并不存在，delete
函数的执行也不会失败，更不会抛出运行时的异常。</p>
<p><strong>操作五：遍历 map 中的键值数据</strong></p>
<p>遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range
语句对 map 数据进行遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果我们只关心每次迭代的键，我们可以使用下面的方式对 map
进行遍历：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> m &#123; <br>  <span class="hljs-comment">// 使用k</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 使用k</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>如果我们只关心每次迭代返回的键所对应的
value，我们同样可以通过空标识符替代变量 k，就像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 使用v</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>我们可以看到，对同一 map
做多次遍历的时候，每次遍历元素的次序都不相同。这是 Go 语言 map
类型的一个重要特点，也是很容易让 Go
初学者掉入坑中的一个地方。所以这里你一定要记住：程序逻辑千万不要依赖遍历
map 所得到的的元素次序。</p>
<h2 id="map-变量的传递开销">map 变量的传递开销</h2>
<p>和切片类型一样，map 也是引用类型。这就意味着 map
类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”</p>
<h2 id="map-的内部实现">map 的内部实现</h2>
<p>和切片相比，map 类型的内部实现要更加复杂。Go
运行时使用一张哈希表来实现抽象的 map 类型。运行时实现了 map
类型操作的所有功能，包括查找、插入、删除等。在编译阶段，Go 编译器会将 Go
语法层面的 map
操作，重写成运行时对应的函数调用。大致的对应关系是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 创建map类型变量实例</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)<br><span class="hljs-comment">// 插入新键值对或给键重新赋值</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span> → v := runtime.mapassign(maptype, m, <span class="hljs-string">&quot;key&quot;</span>) v是用于后续存储value的空间的地址<br><span class="hljs-comment">// 获取某键的值 </span><br>v := m[<span class="hljs-string">&quot;key&quot;</span>]      → v := runtime.mapaccess1(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br>v, ok := m[<span class="hljs-string">&quot;key&quot;</span>]  → v, ok := runtime.mapaccess2(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">// 删除某键</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key&quot;</span>)   → runtime.mapdelete(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p><img src="/page/2022-05/map1.png" srcset="/img/loading.gif" lazyload /></p>
<p>我们可以看到，和切片的运行时表示图相比，map
的实现示意图显然要复杂得多。接下来，我们结合这张图来简要描述一下 map
在运行时层的实现原理。我们重点讲解一下一个 map
变量在初始状态、进行键值对操作后，以及在并发场景下的 Go
运行时层的实现原理。</p>
<h3 id="初始状态">初始状态</h3>
<p>从图中我们可以看到，与语法层面 map 类型变量（m）一一对应的是
<code>*runtime.hmap</code> 的实例，即 <code>runtime.hmap</code>
类型的指针，也就是我们前面在讲解 <code>map</code>
类型变量传递开销时提到的 <code>map</code> 类型的描述符。hmap 类型是 map
类型的头部结构（header），它存储了后续 map
类型操作所需的所有信息，包括：</p>
<p><img src="/page/2022-05/map2.png" srcset="/img/loading.gif" lazyload /></p>
<p>真正用来存储键值对数据的是桶，也就是 <code>bucket</code>，每个
<code>bucket</code> 中存储的是 Hash 值低 bit
位数值相同的元素，默认的元素个数为 BUCKETSIZE（值为 8，Go 1.17 版本中在
<code>$GOROOT/src/cmd/compile/internal/reflectdata/reflect.go</code>
中定义，与 <code>runtime/map.go</code> 中常量 <code>bucketCnt</code>
保持一致）。</p>
<p>当某个 <code>bucket</code>（比如 <code>buckets[0]</code>) 的 8 个空槽
slot）都填满了，且 <code>map</code>
尚未达到扩容的条件的情况下，运行时会建立
<code>overflow bucket</code>，并将这个 <code>overflow bucket</code>
挂在上面<code>bucket</code>（如 <code>buckets[0]</code>）末尾的
<code>overflow</code> 指针上，这样两个<code>buckets</code>
形成了一个链表结构，直到下一次 map
扩容之前，这个结构都会一直存在。从图中我们可以看到，每个
<code>bucket</code> 由三部分组成，从上到下分别是 <code>tophash</code>
区域、key 存储区域和 value 存储区域。</p>
<h3 id="tophash-区域">tophash 区域</h3>
<p>当我们向 map 插入一条数据，或者是从 map 按 key
查询数据的时候，运行时都会使用哈希函数对 key
做哈希运算，并获得一个哈希值（hashcode）。这个 hashcode
非常关键，运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定
bucket，高位区的值用于在某个 bucket 中确定 key
的位置。我把这一过程整理成了下面这张示意图，你理解起来可以更直观：</p>
<p><img src="/page/2022-05/map3.png" srcset="/img/loading.gif" lazyload /></p>
<p>因此，每个 bucket 的 tophash 区域其实是用来快速定位 key
位置的，这样就避免了逐个 key 进行比较这种代价较大的操作。尤其是当 key 是
size
较大的字符串类型时，好处就更突出了。这是一种以空间换时间的思路。</p>
<h3 id="key-存储区域">key 存储区域</h3>
<p>我们看 tophash 区域下面是一块连续的内存区域，存储的是这个 bucket
承载的所有 key 数据。运行时在分配 bucket 的时候需要知道 key 的
Size。</p>
<p>当我们声明一个 map 类型变量，比如 <code>var m map[string]int</code>
时，Go 运行时就会为这个变量对应的特定 map
类型，生成一个<code>runtime.maptype</code>
实例。如果这个实例已经存在，就会直接复用。maptype
实例的结构是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> maptype <span class="hljs-keyword">struct</span> &#123;<br>    typ        _type<br>    key        *_type<br>    elem       *_type<br>    bucket     *_type <span class="hljs-comment">// internal type representing a hash bucket</span><br>    keysize    <span class="hljs-type">uint8</span>  <span class="hljs-comment">// size of key slot</span><br>    elemsize   <span class="hljs-type">uint8</span>  <span class="hljs-comment">// size of elem slot</span><br>    bucketsize <span class="hljs-type">uint16</span> <span class="hljs-comment">// size of bucket</span><br>    flags      <span class="hljs-type">uint32</span><br>&#125; <br></code></pre></div></td></tr></table></figure>
<p>我们可以看到，这个实例包含了我们需要的 map
类型中的所有"元信息"。我们前面提到过，编译器会把语法层面的 map
操作重写成运行时对应的函数调用，这些运行时函数都有一个共同的特点，那就是第一个参数都是
maptype 指针类型的参数。</p>
<p>Go 运行时就是利用 maptype 参数中的信息确定 key 的类型和大小的。map
所用的 hash 函数也存放在 maptype.key.alg.hash(key, hmap.hash0) 中。同时
maptype 的存在也让 Go 中所有 map 类型都共享一套运行时 map
操作函数，而不是像 C++ 那样为每种 map 类型创建一套 map
操作函数，这样就节省了对最终二进制文件空间的占用。</p>
<h3 id="value-存储区域">value 存储区域</h3>
<p>key 存储区域下方的另外一块连续的内存区域，这个区域存储的是 key 对应的
value。和 key 一样，这个区域的创建也是得到了 <code>maptype</code>
中信息的帮助。Go 运行时采用了把 key 和 value
分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv
紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。</p>
<p><code>map[int8]int64</code> 为例，看看下面的存储空间利用率对比图</p>
<p><img src="/page/2022-05/map4.png" srcset="/img/loading.gif" lazyload /></p>
<p>当前 Go 运行时使用的方案内存利用效率很高，而 kv
紧邻存储的方案在<code>map[int8]int64</code>
这样的例子中内存浪费十分严重，它的内存利用率是
<code>72/128=56.25%</code>，有近一半的空间都浪费掉了。另外，还有一点要强调一下，如果
key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket
中直接存储数据，而是会存储 key 或 value 数据的指针。目前 Go
运行时定义的最大 key 和 value 的长度是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/map.go</span><br><span class="hljs-keyword">const</span> (<br>    maxKeySize  = <span class="hljs-number">128</span><br>    maxElemSize = <span class="hljs-number">128</span><br>)<br></code></pre></div></td></tr></table></figure>
<h3 id="map-扩容">map 扩容</h3>
<p>我们前面提到过，map
会对底层使用的内存进行自动管理。因此，在使用过程中，当插入元素个数超出一定数值后，map
一定会存在自动扩容的问题，也就是怎么扩充 bucket 的数量，并重新在 bucket
间均衡分配数据的问题。那么 map 在什么情况下会进行扩容呢？Go 运行时的 map
实现中引入了一个 LoadFactor（负载因子），当 count &gt; LoadFactor * 2^B
或 overflow bucket 过多时，运行时会自动对 map 进行扩容。目前 Go 最新
1.17 版本 LoadFactor 设置为 6.5（loadFactorNum/loadFactorDen）。这里是
Go 中与 map 扩容相关的部分源码：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/map.go</span><br><span class="hljs-keyword">const</span> (<br>  ... ...<br><br>  loadFactorNum = <span class="hljs-number">13</span><br>  loadFactorDen = <span class="hljs-number">2</span><br>  ... ...<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>  ... ...<br>  <span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>    hashGrow(t, h)<br>    <span class="hljs-keyword">goto</span> again <span class="hljs-comment">// Growing the table invalidates everything, so try again</span><br>  &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这两方面原因导致的扩容，在运行时的操作其实是不一样的。如果是因为
overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的
bucket 数组，然后在 assign 和 delete
时做排空和迁移。如果是因为当前数据数量超出 LoadFactor
指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket
数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。原
bucket 数组会挂在 hmap 的 oldbuckets 指针下面，直到原 buckets
数组中所有数据都迁移到新数组后，原 buckets
数组才会被释放。你可以结合下面的 map
扩容示意图来理解这个过程，这会让你理解得更深刻一些：</p>
<p><img src="/page/2022-05/map5.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="map-与并发">map 与并发</h3>
<p>接着我们来看一下 map 和并发。从上面的实现原理来看，充当 map
描述符角色的 hmap
实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说
map 实例不是并发写安全的，也不支持并发读写。如果我们对 map
实例进行并发读写，程序运行时就会抛出异常。看看下面这个并发读写 map
的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doIteration</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        _ = fmt.Sprintf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        m[k] = v + <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>            doIteration(m)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>            doWrite(m)<br>        &#125;<br>    &#125;()<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>运行这个示例程序，我们会得到下面的执行错误结果： <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fatal <span class="hljs-type">error</span>: concurrent <span class="hljs-keyword">map</span> iteration and <span class="hljs-keyword">map</span> write<br></code></pre></div></td></tr></table></figure></p>
<p>不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9
版本中引入了支持并发写安全的 sync.Map
类型，可以用来在并发读写的场景下替换掉
map，如果你有这方面的需求，可以查看一下sync.Map 的手册。另外，考虑到 map
可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以
Go 不允许获取 map 中 value
的地址，这个约束是在编译期间就生效的。下面这段代码就展示了 Go
编译器识别出获取 map 中 value 地址的语句后，给出的编译错误：
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">p := &amp;m[key]  <span class="hljs-comment">// cannot take the address of m[key]</span><br>fmt.Println(p)<br></code></pre></div></td></tr></table></figure> <strong>特别注意：</strong></p>
<ul>
<li>不要依赖 map 的元素遍历顺序；</li>
<li>map 不是线程安全的，不支持并发读写；</li>
<li>不要尝试获取 map 中元素（value）的地址。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Go语言学习</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Go/">Go</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Go语言学习笔记-控制结构、函数</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">
                        <span class="hidden-mobile">Go语言学习笔记-变量、常量、数据类型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        豫ICP备2022006334号-1
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41900102411004"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/images/system/beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
            
            <span>豫公网安备 41900102411004号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

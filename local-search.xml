<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go语言学习笔记-结构体、方法</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h1 id="类型定义type-definition">类型定义（Type Definition）</h1><p><strong>自定义一个新类型</strong></p><p>这也是我们最常用的类型定义方法。在这种方法中，我们会使用关键字type来定义一个新类型 T，具体形式是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T S <span class="hljs-comment">// 定义一个新类型T</span><br></code></pre></div></td></tr></table></figure><p>在这里，S 可以是任何一个已定义的类型，包括 Go原生类型，或者是其他已定义的自定义类型，我们来演示一下这两种情况：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span> <br><span class="hljs-keyword">type</span> T2 T1  <br></code></pre></div></td></tr></table></figure></p><p>这段代码中，新类型 T1 是基于 Go 原生类型 int定义的新自定义类型，而新类型 T2 则是基于刚刚定义的类型T1，定义的新类型。</p><p>这里我们引入一个新概念，底层类型。如果一个新类型是基于某个 Go原生类型定义的，那么我们就叫 Go 原生类型为新类型的底层类型（UnderlyingType)。比如这个例子中，类型 int 就是类型 T1 的底层类型。底层类型在 Go语言中有重要作用，它被用来判断两个类型本质上是否相同（Identical）。</p><p>本质上相同的两个类型，它们的变量可以通过显式转型进行相互赋值，相反，如果本质上是不同的两个类型，它们的变量间连显式转型都不可能，更不要说相互赋值了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> T2 T1<br><span class="hljs-keyword">type</span> T3 <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n1 T1<br>    <span class="hljs-keyword">var</span> n2 T2 = <span class="hljs-number">5</span><br>    n1 = T1(n2)  <span class="hljs-comment">// ok</span><br>    <br>    <span class="hljs-keyword">var</span> s T3 = <span class="hljs-string">&quot;hello&quot;</span><br>    n1 = T1(s) <span class="hljs-comment">// 错误：cannot convert s (type T3) to type T1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>除了基于已有类型定义新类型之外，我们还可以基于类型字面值来定义新类型，这种方式多用于自定义一个新的复合类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> M <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span><br><span class="hljs-keyword">type</span> S []<span class="hljs-type">string</span><br></code></pre></div></td></tr></table></figure><p>和变量声明支持使用 var 块的方式类似，类型定义也支持通过 type块的方式进行，比如我们可以把上面代码中的 T1、T2 和 T3 的定义放在同一个type 块中：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>   T1 <span class="hljs-type">int</span><br>   T2 T1<br>   T3 <span class="hljs-type">string</span><br>)<br></code></pre></div></td></tr></table></figure><p><strong>类型别名（Type Alias）</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = S <span class="hljs-comment">// type alias</span><br></code></pre></div></td></tr></table></figure><p>我们看到，与前面的第一种类型定义相比，类型别名的形式只是多了一个等号，但正是这个等号让新类型T 与原类型 S 完全等价。完全等价的意思就是，类型别名并没有定义出新类型，T与 S 实际上就是同一种类型，它们只是一种类型的两个名字罢了</p><h1 id="结构体">结构体</h1><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    Field1 T1<br>    Field2 T2<br>    ... ...<br>    FieldN Tn<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据这个定义，我们会得到一个名为 T 的结构体类型，定义中 struct关键字后面的大括号包裹的内容就是一个类型字面值。我们看到这个类型字面值由若干个字段（field）聚合而成，每个字段有自己的名字与类型，并且在一个结构体中，每个字段的名字应该都是唯一的。</p><p>我们前面提到过对现实世界的书进行抽象的情况，其实用结构体类型就可以实现，比如这里，我就用前面的典型方法定义了一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> book<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>     Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>     Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>     Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，只要其他包导入了包 book，我们就可以在这些包中直接引用类型名Book，也可以通过 Book 类型变量引用 <code>Name</code>、<code>Pages</code>等字段，就像下面代码中这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;.../book&quot;</span><br><br><span class="hljs-keyword">var</span> b book.Book<br>b.Title = <span class="hljs-string">&quot;The Go Programming Language&quot;</span><br>b.Pages = <span class="hljs-number">800</span><br></code></pre></div></td></tr></table></figure><p>如果结构体类型只在它定义的包内使用，那么我们可以将类型名的首字母小写；如果你不想将结构体类型中的某个字段暴露给其他包，那么我们同样可以把这个字段名字的首字母小写。</p><p>除了通过类型字面值来定义结构体这种典型操作外，我们还有另外几种特殊的情况。</p><p><strong>定义一个空结构体</strong></p><p>我们可以定义一个空结构体，也就是没有包含任何字段的结构体类型，就像下面示例代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// Empty是一个不包含任何字段的空结构体类型</span><br></code></pre></div></td></tr></table></figure><p>空结构体类型有什么用呢？我们继续看下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s Empty<br><span class="hljs-built_in">println</span>(unsafe.Sizeof(s)) <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure><p>我们看到，输出的空结构体类型变量的大小为0，也就是说，空结构体类型变量的内存占用为0。基于空结构体类型内存零开销这样的特性，我们在日常 Go开发中会经常使用空结构体类型元素，作为一种“事件”信息进行 Goroutine之间的通信，就像下面示例代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Empty) <span class="hljs-comment">// 声明一个元素类型为Empty的channel</span><br>c&lt;-Empty&#123;&#125;               <span class="hljs-comment">// 向channel写入一个“事件”</span><br></code></pre></div></td></tr></table></figure><p>这种以空结构体为元素类建立的 channel，是目前能实现的、内存占用最小的Goroutine 间通信方式。</p><p><strong>使用其他结构体作为自定义结构体中字段的类型。</strong></p><p>我们看这段代码，这里结构体类型 Book 的字段 Author的类型，就是另外一个结构体类型 Person：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>    Addr <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Author Person<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们要访问 Book 结构体字段 Author 中的 Phone字段，我们可以这样操作：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Author.Phone)<br></code></pre></div></td></tr></table></figure><p>不过，对于包含结构体类型字段的结构体类型来说，Go还提供了一种更为简便的定义方法，那就是我们可以无需提供字段的名字，只需要使用其类型就可以了，以上面的Book 结构体定义为例，我们可以用下面的方式提供一个等价的定义：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Person<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以这种方式定义的结构体字段，我们叫做嵌入字段（EmbeddedField）。我们也可以将这种字段称为匿名字段，或者把类型名看作是这个字段的名字。如果我们要访问Person 中的 Phone 字段，我们可以通过下面两种方式进行：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Person.Phone) <span class="hljs-comment">// 将类型名当作嵌入字段的名字</span><br><span class="hljs-built_in">println</span>(book.Phone)        <span class="hljs-comment">// 支持直接访问嵌入字段所属类型中字段</span><br></code></pre></div></td></tr></table></figure><p>第一种方式显然是通过把类型名当作嵌入字段的名字来进行操作的，而第二种方式更像是一种“语法糖”，我们可以“绕过”Person类型这一层，直接访问 Person 中的字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ad-note">Go 语言不支持这种在结构体类型定义中，递归地放入其自身类型字段的定义方式。面对上面的示例代码，编译器就会给出“invalid recursive type T”的错误信息。<br></code></pre></div></td></tr></table></figure><p>同样，下面这两个结构体类型 T1 与 T2的定义也存在递归的情况，所以这也是不合法的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span> &#123;<br>  t2 T2<br>&#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span> &#123;<br>  t1 T1<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然我们不能在结构体类型 T 定义中，拥有以自身类型 T定义的字段，但我们却可以拥有自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为value 类型的 map 类型的字段，比如这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    t  *T           <span class="hljs-comment">// ok</span><br>    st []T          <span class="hljs-comment">// ok</span><br>    m  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]T <span class="hljs-comment">// ok</span><br>&#125;     <br></code></pre></div></td></tr></table></figure><p>一个类型，它所占用的大小是固定的，因此一个结构体定义好的时候，其大小是固定的。但是，如果结构体里面套结构体，那么在计算该结构体占用大小的时候，就会成死循环。但如果是指针、切片、map等类型，其本质都是一个int大小(指针，4字节或者8字节，与操作系统有关)，因此该结构体的大小是固定的，记得老师前几节课讲类型的时候说过，类型就能决定内存占用的大小。因此，结构体是可以接口自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为value 类型的 map 类型的字段，而自己本身不行。</p><h2 id="结构体变量的声明与初始化">结构体变量的声明与初始化</h2><p>和其他所有变量的声明一样，我们也可以使用标准变量声明语句，或者是短变量声明语句声明一个结构体类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book<br><span class="hljs-keyword">var</span> book = Book&#123;&#125;<br>book := Book&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>不过，这里要注意，我们在前面说过，结构体类型通常是对真实世界复杂事物的抽象，这和简单的数值、字符串、数组/切片等类型有所不同，结构体类型的变量通常都要被赋予适当的初始值后，才会有合理的意义。</p><p><strong>零值初始化</strong></p><p>零值初始化说的是使用结构体的零值作为它的初始值。对于 Go原生类型来说，这个默认值也称为零值。Go结构体类型由若干个字段组成，当这个结构体类型变量的各个字段的值都是零值时，我们就说这个结构体类型变量处于零值状态。</p><p>前面提到过，结构体类型的零值变量，通常不具有或者很难具有合理的意义，比如通过下面代码得到的零值book 变量就是这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <span class="hljs-comment">// book为零值结构体变量</span><br></code></pre></div></td></tr></table></figure><p>如果一种类型采用零值初始化得到的零值变量，是有意义的，而且是直接可用的，称这种类型为“零值可用”类型。可以说，定义零值可用类型是简化代码、改善开发者使用体验的一种重要的手段。</p><p><strong>使用复合字面值</strong></p><p>最简单的对结构体变量进行显式初始化的方式，就是按顺序依次给每个结构体字段进行赋值，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>    Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>    Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br><br><span class="hljs-keyword">var</span> book = Book&#123;<span class="hljs-string">&quot;The Go Programming Language&quot;</span>, <span class="hljs-number">700</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br></code></pre></div></td></tr></table></figure><p>我们依然可以用这种方法给结构体的每一个字段依次赋值，但这种方法也有很多问题：*首先，当结构体类型定义中的字段顺序发生变化，或者字段出现增删操作时，我们就需要手动调整该结构体类型变量的显式初始化代码，让赋值顺序与调整后的字段顺序一致。*其次，当一个结构体的字段较多时，这种逐一字段赋值的方式实施起来就会比较困难，而且容易出错，开发人员需要来回对照结构体类型中字段的类型与顺序，谨慎编写字面值表达式。*最后，一旦结构体中包含非导出字段，那么这种逐一字段赋值的方式就不再被支持了，编译器会报错：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    F1 <span class="hljs-type">int</span><br>    F2 <span class="hljs-type">string</span><br>    f3 <span class="hljs-type">int</span><br>    F4 <span class="hljs-type">int</span><br>    F5 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br>或<br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br></code></pre></div></td></tr></table></figure><p>Go 语言并不推荐我们按字段顺序对一个结构体类型变量进行显式初始化，甚至Go 官方还在提供的 go vet工具中专门内置了一条检查规则：“composites”，用来静态检查代码中结构体变量初始化是否使用了这种方法，一旦发现，就会给出警告。</p><p>Go推荐我们用“field:value”形式的复合字面值，对结构体类型变量进行显式初始化，这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合，这也是Go 语言的惯用法。这里，我们用“field:value”形式复合字面值，对上面的类型 T的变量进行初始化看看：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t = T&#123;<br>    F2: <span class="hljs-string">&quot;hello&quot;</span>,<br>    F1: <span class="hljs-number">11</span>,<br>    F4: <span class="hljs-number">14</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用这种“field:value”形式的复合字面值对结构体类型变量进行初始化，非常灵活。和之前的顺序复合字面值形式相比，“field:value”形式字面值中的字段可以以任意次序出现。未显式出现在字面值中的结构体字段（比如上面例子中的F5）将采用它对应类型的零值。</p><p>复合字面值作为结构体类型变量初值被广泛使用，即便结构体采用类型零值时，我们也会使用复合字面值的形式，较少使用new 这一个 Go 预定义的函数来创建结构体变量实例。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">t := T&#123;&#125;<br>tp := <span class="hljs-built_in">new</span>(T)<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ad-note">这里值得我们注意的是，我们不能用从其他包导入的结构体中的未导出字段，来作为复合字面值中的 field。这会导致编译错误，因为未导出字段是不可见的。<br></code></pre></div></td></tr></table></figure><p><strong>构造函数</strong></p><p>使用特定的构造函数创建并初始化结构体变量的例子，并不罕见。在 Go标准库中就有很多，其中 time.Timer这个结构体就是一个典型的例子，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-keyword">type</span> runtimeTimer <span class="hljs-keyword">struct</span> &#123;<br>    pp       <span class="hljs-type">uintptr</span><br>    when     <span class="hljs-type">int64</span><br>    period   <span class="hljs-type">int64</span><br>    f        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">uintptr</span>)</span></span> <br>    arg      <span class="hljs-keyword">interface</span>&#123;&#125;<br>    seq      <span class="hljs-type">uintptr</span><br>    nextwhen <span class="hljs-type">int64</span><br>    status   <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span> &#123;<br>    C &lt;-<span class="hljs-keyword">chan</span> Time<br>    r runtimeTimer<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Timer 结构体中包含了一个非导出字段 r，r 的类型为另外一个结构体类型runtimeTimer。这个结构体更为复杂，而且我们一眼就可以看出来，这个runtimeTimer 结构体不是零值可用的，那我们在创建一个 Timer类型变量时就没法使用显式复合字面值的方式了。这个时候，Go标准库提供了一个 Timer 结构体专用的构造函数 NewTimer，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Time, <span class="hljs-number">1</span>)<br>    t := &amp;Timer&#123;<br>        C: c,<br>        r: runtimeTimer&#123;<br>            when: when(d),<br>            f:    sendTime,<br>            arg:  c,<br>        &#125;,<br>    &#125;<br>    startTimer(&amp;t.r)<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，NewTimer 这个函数只接受一个表示定时时间的参数d，在经过一个复杂的初始化过程后，它返回了一个处于可用状态的 Timer类型指针实例。像这类通过专用构造函数进行结构体类型变量创建、初始化的例子还有很多，我们可以总结一下，它们的专用构造函数大多都符合这种模式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(field1, field2, ...)</span></span> *T &#123;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，NewT 是结构体类型 T 的专用构造函数，它的参数列表中的参数通常与T 定义中的导出字段相对应，返回值则是一个 T 指针类型的变量。T的非导出字段在 NewT 内部进行初始化，一些需要复杂初始化逻辑的字段也会在NewT 内部完成初始化。这样，我们只要调用 NewT 函数就可以得到一个可用的 T指针类型变量了。</p><h1 id="方法">方法</h1><p><strong>方法的一般声明形式</strong> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(src *Server)</span></span> ListenAndServeTLS(certFile, keyFile String) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">//method block</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>Go中方法的声明和函数的声明有很多相似之处，从上面这张图我们可以看到，和由五个部分组成的函数声明不同，Go方法的声明有六个组成部分，多的一个就是图中的 receiver 部分。在 receiver部分声明的参数，Go 称之为 receiver 参数，这个 receiver参数也是方法与类型之间的纽带，也是方法与函数的最大不同。</p><p>方法接收器（receiver）参数、函数 /方法参数，以及返回值变量对应的作用域范围，都是函数 /方法体对应的显式代码块。</p><p>这就意味着，receiver部分的参数名不能与方法参数列表中的形参名，以及具名返回值中的变量名存在冲突，必须在这个方法的作用域中具有唯一性。如果这个不唯一不存在，比如像下面例子中那样，Go编译器就会报错：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M(t <span class="hljs-type">string</span>) &#123; <span class="hljs-comment">// 编译器报错：duplicate argument t (重复声明参数t)</span><br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不过，如果在方法体中，我们没有用到 receiver 参数，我们也可以省略receiver 的参数名，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M(t <span class="hljs-type">string</span>) &#123; <br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>仅当方法体中的实现不需要 receiver 参数参与时，我们才会省略 receiver参数名。</p><p>除了 receiver 参数名字要保证唯一外，Go 语言对 receiver参数的基类型也有约束，那就是 receiver参数的基类型本身不能为指针类型或接口类型。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyInt)</span></span> String() <span class="hljs-type">string</span> &#123; <span class="hljs-comment">// r的基类型为MyInt，编译器报错：invalid receiver type MyInt (MyInt is a pointer type)</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, *(*<span class="hljs-type">int</span>)(r))<br>&#125;<br><br><span class="hljs-keyword">type</span> MyReader io.Reader<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// r的基类型为MyReader，编译器报错：invalid receiver type MyReader (MyReader is an interface type)</span><br>    <span class="hljs-keyword">return</span> r.Read(p)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go 对方法声明的位置也是有约束的，Go 要求，方法声明要与 receiver参数的基类型声明放在同一个包内。基于这个约束，我们还可以得到两个推论。 *第一个推论：我们不能为原生类型（诸如 int、float64、map 等）添加方法。 *第二个推论：不能跨越 Go 包为其他包的类型声明新方法。</p><h2 id="方法的本质">方法的本质</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123; <br>    a <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> Get() <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Set(a <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br></code></pre></div></td></tr></table></figure><p>C++ 中的对象在调用方法时，编译器会自动传入指向对象自身的 this指针作为方法的第一个参数。而 Go 方法中的原理也是相似的，只不过我们是将receiver参数以第一个参数的身份并入到方法的参数列表中。按照这个原理，我们示例中的类型T 和 *T 的方法，就可以分别等价转换为下面的普通函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 类型T的方法Get的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(t T)</span></span> <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><br><span class="hljs-comment">// 类型*T的方法Set的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Set</span><span class="hljs-params">(t *T, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种等价转换后的函数的类型就是方法的类型。只不过在 Go语言中，这种等价转换是由 Go 编译器在编译和生成代码时自动完成的。Go语言规范中还提供了方法表达式（MethodExpression）的概念，可以让我们更充分地理解上面的等价转换，我们来看一下。</p><p>我们还以上面类型 T 以及它的方法为例，结合前面说过的 Go方法的调用方式，我们可以得到下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>t.Get()<br>(&amp;t).Set(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>我们可以用另一种方式，把上面的方法调用做一个等价替换：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>T.Get(t)<br>(*T).Set(&amp;t, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>这种直接以类型名 T 调用方法的表达方式，被称为 Method Expression。通过Method Expression 这种形式，类型 T 只能调用 T 的方法集合（MethodSet）中的方法，同理类型 *T 也只能调用 *T 的方法集合中的方法。这种通过Method Expression对方法进行调用的方式，与我们之前所做的方法到函数的等价转换是如出一辙的。所以，Go语言中的方法的本质就是，一个以方法的 receiver参数作为第一个参数的普通函数。</p><h2 id="receiver-参数类型对-go-方法的影响">receiver 参数类型对 Go方法的影响</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1() &lt;=&gt; F1(t T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &lt;=&gt; F2(t *T)<br></code></pre></div></td></tr></table></figure><p>这个例子中有方法 M1 和 M2。M1 方法是 receiver 参数类型为 T的一类方法的代表，而 M2 方法则代表了 receiver 参数类型为 *T的另一类。下面我们分别来看看不同的 receiver 参数类型对 M1 和 M2的影响。</p><ul><li>首先，当 receiver 参数的类型为 T 时： 当我们选择以 T 作为 receiver参数类型时，M1 方法等价转换为F1(t T)。我们知道，Go函数的参数采用的是值拷贝传递，也就是说，F1 函数体中的 t 是 T类型实例的一个副本。这样，我们在 F1 函数的实现中对参数 t做任何修改，都只会影响副本，而不会影响到原 T 类型实例。</li></ul><p>据此我们可以得出结论：当我们的方法 M1 采用类型为 T 的 receiver参数时，代表 T 类型实例的 receiver 参数以值传递方式传递到 M1方法体中的，实际上是 T 类型实例的副本，M1方法体中对副本的任何修改操作，都不会影响到原 T 类型实例。</p><ul><li>第二，当 receiver 参数的类型为 *T 时： 当我们选择以 *T 作为 receiver参数类型时，M2 方法等价转换为F2(t *T)。同上面分析，我们传递给 F2 函数的t 是 T 类型实例的地址，这样 F2 函数体中对参数 t做的任何修改，都会反映到原 T 类型实例上。</li></ul><p>据此我们也可以得出结论：当我们的方法 M2 采用类型为 *T 的 receiver参数时，代表 *T 类型实例的 receiver 参数以值传递方式传递到 M2方法体中的，实际上是 T 类型实例的地址，M2 方法体通过该地址可以对原 T类型实例进行任何修改操作。</p><h3 id="选择-receiver-参数类型的第一个原则">选择 receiver参数类型的第一个原则</h3><p>基于上面的影响分析，我们可以得到选择 receiver参数类型的第一个原则：如果 Go 方法要把对 receiver参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为receiver 参数的类型。</p><p>存在问题：如果我们选择了 *T 作为 Go 方法 receiver参数的类型，那么我们是不是只能通过 *T 类型变量调用该方法，而不能通过 T类型变量调用了呢？</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>     a <span class="hljs-type">int</span><br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1() &#123;<br>     t.a = <span class="hljs-number">10</span><br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &#123;<br>    t.a = <span class="hljs-number">11</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t1 T<br>    <span class="hljs-built_in">println</span>(t1.a) <span class="hljs-comment">// 0</span><br>    t1.M1()<br>    <span class="hljs-built_in">println</span>(t1.a) <span class="hljs-comment">// 0</span><br>    t1.M2()<br>    <span class="hljs-built_in">println</span>(t1.a) <span class="hljs-comment">// 11</span><br><br>    <span class="hljs-keyword">var</span> t2 = &amp;T&#123;&#125;<br>    <span class="hljs-built_in">println</span>(t2.a) <span class="hljs-comment">// 0</span><br>    t2.M1()<br>    <span class="hljs-built_in">println</span>(t2.a) <span class="hljs-comment">// 0</span><br>    t2.M2()<br>    <span class="hljs-built_in">println</span>(t2.a) <span class="hljs-comment">// 11</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过这个实例，我们知道了这样一个结论：无论是 T 类型实例，还是 *T类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为*T 类型的方法。这样，我们在为方法选择 receiver参数的类型的时候，就不需要担心这个方法不能被与 receiver参数类型不一致的类型实例调用了。</p><h3 id="选择-receiver-参数类型的第二个原则">选择 receiver参数类型的第二个原则</h3><p>考虑到 Go 方法调用时，receiver参数是以值拷贝的形式传入方法中的。那么，如果 receiver 参数类型的 size较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为receiver 类型可能更好些。</p><h4 id="方法集合">方法集合</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    <span class="hljs-keyword">var</span> i Interface<br><br>    i = pt<br>    i = t <span class="hljs-comment">// cannot use t (type T) as type Interface in assignment: T does not implement Interface (M2 method has pointer receiver)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们定义了一个接口类型 Interface 以及一个自定义类型T。Interface 接口类型包含了两个方法 M1 和 M2，代码中还定义了基类型为 T的两个方法 M1 和 M2，但它们的 receiver 参数类型不同，一个为 T，另一个为*T。在 main 函数中，我们分别将 T 类型实例 t 和 *T 类型实例 pt 赋值给Interface 类型变量 i。运行一下这个示例程序，我们在i = t这一行会得到 Go编译器的错误提示，Go 编译器提示我们：T 没有实现 Interface类型方法列表中的 M2，因此类型 T 的实例 t 不能赋值给 Interface变量。有些事情并不是表面看起来这个样子的。了解方法集合后，这个问题就迎刃而解了。同时，方法集合也是用来判断一个类型是否实现了某接口类型的唯一手段，可以说，“方法集合决定了接口实现”。</p><p>所谓的方法集合决定接口实现的含义就是：如果某类型 T的方法集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I方法集合的超集，那么我们就说这个类型 T 实现了接口I。或者说，方法集合这个概念在 Go语言中的主要用途，就是用来判断某个类型是否实现了某个接口。</p><h3 id="选择-receiver-参数类型的第三个原则">选择 receiver参数类型的第三个原则</h3><p>这个原则的选择依据就是 T 类型是否需要实现某个接口，也就是是否存在将 T类型的变量赋值给某接口类型变量的情况。如果 T类型需要实现某个接口，那我们就要使用 T 作为 receiver参数的类型，来满足接口类型方法集合中的所有方法。如果 T不需要实现某一接口，但 *T 需要实现该接口，那么根据方法集合概念，*T的方法集合是包含 T 的方法集合的，这样我们在确定 Go 方法的 receiver的类型时，参考原则一和原则二就可以了。</p><h3 id="receiver-总结">receiver 总结</h3><p>receiver 参数选型的三个经验原则，在实际进行 Go方法设计时，我们首先应该考虑的是原则三，即 T类型是否要实现某一接口。如果 T类型需要实现某一接口的全部方法，那么我们就需要使用 T 作为 receiver参数的类型来满足接口类型方法集合中的所有方法。如果 T类型不需要实现某一接口，那么我们就可以参考原则一和原则二来为 receiver参数选择类型了。也就是，如果 Go 方法要把对 receiver参数所代表的类型实例的修改反映到原类型实例上，那么我们应该选择 *T 作为receiver 参数的类型。否则通常我们会为 receiver 参数选择 T类型，这样可以减少外部修改类型实例内部状态的“渠道”。除非 receiver参数类型的 size 较大，考虑到传值的较大性能开销，选择 *T 作为 receiver类型可能更适合。</p><p>方法集合。它在 Go语言中的主要用途就是判断某个类型是否实现了某个接口。方法集合像“胶水”一样，将自定义类型与接口隐式地“粘结”在一起，我们后面理解带有类型嵌入的类型时还会借助这个概念。</p><h1 id="继承-类型嵌入">“继承” 类型嵌入</h1><p>类型嵌入指的就是在一个类型的定义中嵌入了其他类型。Go语言支持两种类型嵌入，分别是接口类型的类型嵌入和结构体类型的类型嵌入。</p><h2 id="接口类型的类型嵌入">接口类型的类型嵌入</h2><p>我们先用一个案例，直观地了解一下什么是接口类型的类型嵌入。虽然我们现在还没有系统学习接口类型，但在前面的讲解中，我们已经多次接触了接口类型。我们知道，接口类型声明了由一个方法集合代表的接口，比如下面接口类型E：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> E <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个接口类型 E 的方法集合，包含两个方法，分别是 M1 和 M2，它们组成了E 这个接口类型所代表的接口。如果某个类型实现了方法 M1 和M2，我们就说这个类型实现了 E所代表的接口。此时，我们再定义另外一个接口类型I，它的方法集合中包含了三个方法 M1、M2 和 M3，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>    M3()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到接口类型 I 方法集合中的 M1 和 M2，与接口类型 E的方法集合中的方法完全相同。在这种情况下，我们可以用接口类型 E替代上面接口类型 I 定义中 M1 和 M2，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    E<br>    M3()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>像这种在一个接口类型（I）定义中，嵌入另外一个接口类型（E）的方式，就是我们说的接口类型的类型嵌入。而且，这个带有类型嵌入的接口类型I 的定义与上面那个包含 M1、M2 和 M3 的接口类型 I的定义，是等价的。因此，我们可以得到一个结论，这种接口类型嵌入的语义就是新接口类型（如接口类型I）将嵌入的接口类型（如接口类型E）的方法集合，并入到自己的方法集合中。</p><p>这也是 Go 组合设计哲学的一种体现</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/io/io.go</span><br><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;<br>    Close() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>&#125;<br><br><span class="hljs-keyword">type</span> ReadCloser <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Closer<br>&#125;<br><br><span class="hljs-keyword">type</span> WriteCloser <span class="hljs-keyword">interface</span> &#123;<br>    Writer<br>    Closer<br>&#125;<br><br><span class="hljs-keyword">type</span> ReadWriteCloser <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>    Closer<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不过，这种通过嵌入其他接口类型来创建新接口类型的方式，在 Go 1.14版本之前是有约束的：如果新接口类型嵌入了多个接口类型，这些嵌入的接口类型的方法集合不能有交集，同时嵌入的接口类型的方法集合中的方法名字，也不能与新接口中的其他方法同名。</p><h2 id="结构体类型的类型嵌入">结构体类型的类型嵌入</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    A <span class="hljs-type">int</span><br>    b <span class="hljs-type">string</span><br>    c T<br>    p *P<br>    _ [<span class="hljs-number">10</span>]<span class="hljs-type">int8</span><br>    F <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结构体类型 S中的每个字段（field）都有唯一的名字与对应的类型，即便是使用空标识符占位的字段，它的类型也是明确的，但这还不是Go 结构体类型的“完全体”。Go结构体类型定义还有另外一种形式，那就是带有嵌入字段（EmbeddedField）的结构体定义。我们看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> t2 <span class="hljs-keyword">struct</span>&#123;<br>    n <span class="hljs-type">int</span><br>    m <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>&#125;<br><br><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *t2<br>    I            <br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，结构体 S1 定义中有三个“非常规形式”的标识符，分别是 T1、t2和I，这三个标识符究竟代表的是什么呢？是字段名还是字段的类型呢？它们既代表字段的名字，也代表字段的类型。我们分别以这三个标识符为例，说明一下它们的具体含义：* 标识符 T1 表示字段名为 T1，它的类型为自定义类型 T1； * 标识符 t2表示字段名为 t2，它的类型为自定义结构体类型 t2 的指针类型； * 标识符 I表示字段名为 I，它的类型为接口类型 I。</p><p>这种以某个类型名、类型的指针类型名或接口类型名，直接作为结构体字段的方式就叫做结构体的类型嵌入，这些字段也被叫做嵌入字段（EmbeddedField）。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *MyInt)</span></span> Add(m <span class="hljs-type">int</span>) &#123;<br>    *n = *n + MyInt(m)<br>&#125;<br><br><span class="hljs-keyword">type</span> t <span class="hljs-keyword">struct</span> &#123;<br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    *MyInt<br>    t<br>    io.Reader<br>    s <span class="hljs-type">string</span><br>    n <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := MyInt(<span class="hljs-number">17</span>)<br>    r := strings.NewReader(<span class="hljs-string">&quot;hello, go&quot;</span>)<br>    s := S&#123;<br>        MyInt: &amp;m,<br>        t: t&#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>        &#125;,<br>        Reader: r,<br>        s:      <span class="hljs-string">&quot;demo&quot;</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>    s.Reader.Read(sl)<br>    fmt.Println(<span class="hljs-type">string</span>(sl)) <span class="hljs-comment">// hello, go</span><br>    s.MyInt.Add(<span class="hljs-number">5</span>)<br>    fmt.Println(*(s.MyInt)) <span class="hljs-comment">// 22</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先，这个例子中的结构体类型 S使用了类型嵌入方式进行定义，它有三个嵌入字段 MyInt、t 和Reader。为什么第三个嵌入字段的名字为 Reader 而不是io.Reader？这是因为，Go语言规定如果结构体使用从其他包导入的类型作为嵌入字段，比如pkg.T，那么这个嵌入字段的字段名就是 T，代表的类型为 pkg.T。</p><p>接下来，我们再来看结构体类型 S 的变量的初始化。我们使用 field:value方式对 S 类型的变量 s的各个字段进行初始化。和普通的字段一样，初始化嵌入字段时，我们可以直接用嵌入字段名作为field。</p><p>而且，通过变量 s使用这些嵌入字段时，我们也可以像普通字段那样直接用变量s+字段选择符.+嵌入字段的名字，比如s.Reader。我们还可以通过这种方式调用嵌入字段的方法，比如 s.Reader.Read和 s.MyInt.Add。</p><h2 id="实现继承的原理">“实现继承”的原理</h2><p>我们将上面例子代码做一下细微改动，我这里只列了变化部分的代码<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>s.Read(sl) <br>fmt.Println(<span class="hljs-type">string</span>(sl))<br>s.Add(<span class="hljs-number">5</span>) <br>fmt.Println(*(s.MyInt))<br></code></pre></div></td></tr></table></figure></p><p>这段代码似乎在告诉我们：Read 方法与 Add 方法就是类型 S方法集合中的方法。但是，这里类型 S明明没有显式实现这两个方法呀，它是从哪里得到这两个方法的实现的呢？</p><p>其实，这两个方法就来自结构体类型 S 的两个嵌入字段 Reader 和MyInt。结构体类型 S“继承”了 Reader 字段的方法 Read 的实现，也“继承”了*MyInt 的 Add方法的实现。注意，我这里的“继承”用了引号，说明这并不是真正的继承，它只是Go 语言的一种“障眼法”。</p><p>这种“障眼法”的工作机制是这样的，当我们通过结构体类型 S 的变量 s 调用Read 方法时，Go 发现结构体类型 S 自身并没有定义 Read 方法，于是 Go会查看 S 的嵌入字段对应的类型是否定义了 Read 方法。这个时候，Reader字段就被找了出来，之后 s.Read 的调用就被转换为 s.Reader.Read调用。这样一来，嵌入字段 Reader 的 Read 方法就被提升为 S的方法，放入了类型 S 的方法集合。同理 *MyInt 的 Add 方法也被提升为 S的方法而放入 S的方法集合。从外部来看，这种嵌入字段的方法的提升就给了我们一种结构体类型S“继承”了 io.Reader 类型 Read 方法的实现，以及 *MyInt 类型 Add方法的实现的错觉。到这里，我们就清楚了，嵌入字段的使用的确可以帮我们在Go 中实现方法的“继承”</p><p>[[Pasted image 20220405120810.png]]</p><h2 id="类型嵌入与方法集合">类型嵌入与方法集合</h2><p>在前面讲解接口类型的类型嵌入时，我们提到过接口类型的类型嵌入的本质，就是嵌入类型的方法集合并入到新接口类型的方法集合中，并且，接口类型只能嵌入接口类型。而结构体类型对嵌入类型的要求就比较宽泛了，可以是任意自定义类型或接口类型。</p><h3 id="结构体类型中嵌入接口类型">结构体类型中嵌入接口类型</h3><p>在结构体类型中嵌入接口类型后，结构体类型的方法集合会发生什么变化呢？我们通过下面这个例子来看一下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    I<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M3() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> p *T<br>    dumpMethodSet(t)<br>    dumpMethodSet(p)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行这个示例，我们会得到以下结果：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string">- M3</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br>- M3<br></code></pre></div></td></tr></table></figure><p>我们可以看到，原本结构体类型 T 只带有一个方法 M3，但在嵌入接口类型 I后，结构体类型 T 的方法集合中又并入了接口类型 I 的方法集合。并且，由于*T 类型方法集合包括 T 类型的方法集合，因此无论是类型 T 还是类型*T，它们的方法集合都包含 M1、M2 和M3。于是我们可以得出一个结论：结构体类型的方法集合，包含嵌入的接口类型的方法集合。</p><p>如果实现了，Go 就会优先使用结构体自己实现的方法。如果没有实现，那么Go就会查找结构体中的嵌入字段的方法集合中，是否包含了这个方法。如果多个嵌入字段的方法集合中都包含这个方法，那么我们就说方法集合存在交集。这个时候，Go编译器就会因无法确定究竟使用哪个方法而报错。那怎么解决这个问题呢？其实有两种解决方案。一是，我们可以消除E1 和 E2 方法集合存在交集的情况。二是为 T 增加 M1 和 M2方法的实现，这样的话，编译器便会直接选择 T 自己实现的 M1 和M2，不会陷入两难境地。</p><h3 id="结构体类型中嵌入结构体类型">结构体类型中嵌入结构体类型</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T1)</span></span> T1M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T1&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T1)</span></span> PT1M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT1&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T2)</span></span> T2M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T2&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T2)</span></span> PT2M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT2&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *T2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t := T&#123;<br>        T1: T1&#123;&#125;,<br>        T2: &amp;T2&#123;&#125;,<br>    &#125;<br><br>    dumpMethodSet(t)<br>    dumpMethodSet(&amp;t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，结构体类型 T 有两个嵌入字段，分别是 T1 和 *T2，我们知道T1 与 *T1、T2 与 *T2 的方法集合是不同的： T1 的方法集合包含：T1M1； *T1的方法集合包含：T1M1、PT1M2； T2 的方法集合包含：T2M1； *T2的方法集合包含：T2M1、PT2M2。</p><p>它们作为嵌入字段嵌入到 T 中后，对 T 和 *T的方法集合的影响也是不同的。我们运行一下这个示例，看一下输出结果：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- PT2M2</span><br><span class="hljs-string">- T1M1</span><br><span class="hljs-string">- T2M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- PT1M2<br>- PT2M2<br>- T1M1<br>- T2M1<br></code></pre></div></td></tr></table></figure><p>通过输出结果，我们看到了 T 和 *T 类型的方法集合果然有差别的： 类型 T的方法集合 = T1 的方法集合 + *T2 的方法集合类型 *T 的方法集合 = *T1的方法集合 + *T2 的方法集合</p><h2 id="defined-类型与-alias-类型的方法集合">defined 类型与 alias类型的方法集合</h2><p>Go 语言中，凡通过类型声明语法声明的类型都被称为 defined类型，下面是一些 defined 类型的声明的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><span class="hljs-keyword">type</span> T <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> NT T <span class="hljs-comment">// 基于已存在的类型T创建新的defined类型NT</span><br><span class="hljs-keyword">type</span> NI I <span class="hljs-comment">// 基于已存在的接口类型I创建新defined接口类型NI</span><br></code></pre></div></td></tr></table></figure><p>对于那些基于接口类型创建的 defined的接口类型，它们的方法集合与原接口类型的方法集合是一致的。但对于基于非接口类型的defined 类型创建的非接口类型，我们通过下面例子来看一下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> t T<br>  <span class="hljs-keyword">var</span> pt *T<br>  <span class="hljs-keyword">var</span> t1 T1<br>  <span class="hljs-keyword">var</span> pt1 *T1<br><br>  dumpMethodSet(t)<br>  dumpMethodSet(t1)<br><br>  dumpMethodSet(pt)<br>  dumpMethodSet(pt1)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们基于一个 defined 的非接口类型 T 创建了新 defined类型 T1，并且分别输出 T1 和 *T1 的方法集合来确认它们是否“继承”了 T的方法集合。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T1&#x27;</span>s method set is empty!<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T1&#x27;</span>s method set is empty!<br></code></pre></div></td></tr></table></figure><p>从输出结果上看，新类型 T1 并没有“继承”原 defined 类型 T的任何一个方法。从逻辑上来说，这也符合 T1 与 T是两个不同类型的语义。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 = T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    <span class="hljs-keyword">var</span> t1 T1<br>    <span class="hljs-keyword">var</span> pt1 *T1<br><br>    dumpMethodSet(t)<br>    dumpMethodSet(t1)<br><br>    dumpMethodSet(pt)<br>    dumpMethodSet(pt1)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T&#x27;</span>s method set:<br>- M1<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br></code></pre></div></td></tr></table></figure><p>通过这个输出结果，我们看到，我们的 dumpMethodSet函数甚至都无法识别出“类型别名”，无论类型别名还是原类型，输出的都是原类型的方法集合。由此我们可以得到一个结论：无论原类型是接口类型还是非接口类型，类型别名都与原类型拥有完全相同的方法集合。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-控制结构、函数</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h1 id="控制结构">控制结构</h1><h2 id="if-语句">if 语句</h2><p>if 语句是 Go 语言中提供的一种分支控制结构，它也是 Go中最常用、最简单的分支控制结构。它会根据布尔表达式的值，在两个分支中选择一个执行。我们先来看一个最简单的、单分支结构的if 语句的形式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression &#123;<br>    <span class="hljs-comment">// 新分支</span><br>&#125;<br><br><span class="hljs-comment">// 原分支</span><br></code></pre></div></td></tr></table></figure><p>虽然各种编程语言几乎都原生支持了 if 语句，但 Go 的 if语句依然有着自己的特点：</p><ol type="1"><li>和 Go 函数一样，if 语句的分支代码块的左大括号与 if关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt工具会帮助我们实现这一点；</li><li>if语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。而且，if关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是true，要么是 false</li></ol><h3 id="逻辑操作符">逻辑操作符</h3><p>如果判断的条件比较多，我们可以用多个逻辑操作符连接起多个条件判断表达式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (runtime.GOOS == <span class="hljs-string">&quot;linux&quot;</span>) &amp;&amp; (runtime.GOARCH == <span class="hljs-string">&quot;amd64&quot;</span>) &amp;&amp;<br>    (runtime.Compiler != <span class="hljs-string">&quot;gccgo&quot;</span>) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;we are using standard go compiler on linux os for amd64&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go语言的操作符是有优先级的。这里你要记住，一元操作符，比如上面的逻辑非操作符，具有最高优先级，其他操作符的优先级如下：</p><table><thead><tr class="header"><th>优先级</th><th>操作符</th></tr></thead><tbody><tr class="odd"><td>5</td><td>*、/、%、&lt;&lt;、&gt;&gt;、&amp;、&amp;^</td></tr><tr class="even"><td>4</td><td>+、-</td></tr><tr class="odd"><td>3</td><td>!=、==、&lt;、&lt;=、&gt;、&gt;=</td></tr><tr class="even"><td>2</td><td>&amp;&amp;</td></tr><tr class="odd"><td>1</td><td>||</td></tr></tbody></table><p>操作符优先级决定了操作数优先参与哪个操作符的求值运算，我们以下面代码中if 语句的布尔表达式为例：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a, b := <span class="hljs-literal">false</span>,<span class="hljs-literal">true</span><br>    <span class="hljs-keyword">if</span> a &amp;&amp; b != <span class="hljs-literal">true</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;(a &amp;&amp; b) != true&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;a &amp;&amp; (b != true) == false&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码的关键就在于，if 后面的布尔表达式中的操作数 b 是先参与&amp;&amp; 的求值运算，还是先参与!=的求值运算。根据前面的操作符优先级表，我们知道，!= 的优先级要高于&amp;&amp;，因此操作数 b 先参与的是!= 的求值运算，这样 if后的布尔表达式就等价于 a &amp;&amp; (b != true) ，而不是我们最初认为的(a &amp;&amp; b) != true。</p><p>从学习和使用 C语言开始，我自己就记不住这么多操作符的优先级，况且不同编程语言的操作符优先级还可能有所不同，所以我个人倾向在if 布尔表达式中，使用带有小括号的子布尔表达式来清晰地表达判断条件。</p><p>除了上面的最简形式，Go 语言的 if语句还有其他多种形式，比如二分支结构和多（N）分支结构。</p><p>二分支控制结构比较好理解。比如下面这个例子，当 boolean_expression求值为 true 时，执行分支 1，否则，执行分支 2：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>多分支结构:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression1 &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expression2 &#123;<br>  <span class="hljs-comment">// 分支2</span><br><br>... ...<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expressionN &#123;<br>  <span class="hljs-comment">// 分支N</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支N+1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>支持声明 if语句的自用变量</strong>：无论是单分支、二分支还是多分支结构，我们都可以在if 后的布尔表达式前，进行一些变量的声明，在 if布尔表达式前声明的变量，我叫它 if 语句的自用变量。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a, c := f(), h(); a &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(a)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b := f(); b &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b, c)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 if 语句中声明自用变量是 Go语言的一个惯用法，这种使用方式直观上可以让开发者有一种代码行数减少的感觉，提高可读性。</p><p><strong>if 语句的“快乐路径”原则</strong>:在日常编码中要减少多分支结构，甚至是二分支结构的使用，这会有助于我们编写出优雅、简洁、易读易维护且不易错的代码。</p><h2 id="for-语句">for 语句</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br><span class="hljs-built_in">println</span>(sum)<br></code></pre></div></td></tr></table></figure><p>这种 for 语句的使用形式是 Go 语言中 for 循环语句的经典形式</p><p>Go 语言的 for循环支持声明多循环变量，并且可以应用在循环体以及判断条件中，比如下面就是一个使用多循环变量的、稍复杂的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, j, k := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>; (i &lt; <span class="hljs-number">20</span>) &amp;&amp; (j &lt; <span class="hljs-number">10</span>) &amp;&amp; (k &lt; <span class="hljs-number">30</span>); i, j, k = i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">5</span> &#123;<br>    sum += (i + j + k)<br>    <span class="hljs-built_in">println</span>(sum)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们继续按四个组成部分分析这段代码。其实，除了循环体部分（③）之外，其余的三个部分都是可选的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; &#123;<br>    i++<br>&#125;<br><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++&#123;<br>    <span class="hljs-built_in">println</span>(i)<br>&#125;  <br><br><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; &#123;<br>    <span class="hljs-built_in">println</span>(i)<br>    i++<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然我们对前置语句或后置语句进行了省略，但经典 for循环形式中的分号依然被保留着，你要注意这一点，这是 Go语法的要求。不过有一个例外，那就是当循环前置与后置语句都省略掉，仅保留循环判断条件表达式时，我们可以省略经典for 循环形式中的分号。也就是说，我们可以将上面的例子写出如下形式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-built_in">println</span>(i)<br>    i++<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种形式也是我们在日常 Go 编码中经常使用的 for循环语句的第二种形式，也就是除了循环体之外，我们仅保留循环判断条件表达式。特殊的，当for 循环语句的循环判断条件表达式的求值结果始终为 true时，我们就可以将它省略掉了：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123; <br>   <span class="hljs-comment">// 循环体代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>for range 循环</strong></p><p>先来看一个例子。如果我们要使用 for经典形式遍历一个切片中的元素，我们可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, sl[i])<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go 语言提供了一个更方便的“语法糖”形式：forrange。现在我们就来写一个等价于上面代码的 for range 循环：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> sl &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, v)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>for range 语句也有几个常见变种</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//不关心值时</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">//只关心值</span><br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">//都不关心</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><span class="hljs-comment">//or</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>针对不同数据类型，for range 分析</p><p><strong>string</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d %s 0x%x\n&quot;</span>, i, <span class="hljs-type">string</span>(v), v)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 0 中 0x4e2d</span><br><span class="hljs-comment">// 3 国 0x56fd</span><br><span class="hljs-comment">// 6 人 0x4eba</span><br></code></pre></div></td></tr></table></figure><p>for range 对于 string 类型来说，每次循环得到的 v 值是一个 Unicode字符码点，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为该Unicode字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置。</p><p><strong>map</strong></p><p>但在 Go 语言中，我们要对 map 进行循环操作，for range 是唯一的方法</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;Rob&quot;</span> : <span class="hljs-number">67</span>,<br>    <span class="hljs-string">&quot;Russ&quot;</span> : <span class="hljs-number">39</span>,<br>    <span class="hljs-string">&quot;John&quot;</span> : <span class="hljs-number">29</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-built_in">println</span>(k, v)<br>&#125;<br><br><span class="hljs-comment">// John 29</span><br><span class="hljs-comment">// Rob 67</span><br><span class="hljs-comment">// Russ 39</span><br></code></pre></div></td></tr></table></figure><p>每次循环，循环变量 k 和 v 分别会被赋值为 map 键值对集合中一个元素的key 值和 value 值。而且，map 类型中没有下标的概念，通过 key 和 value来循环操作 map 类型变量也就十分自然了。</p><p><strong>channel</strong></p><p>channel 是 Go 语言提供的并发设计的原语，它用于多个 Goroutine之间的通信，在for range 中的用法是下面这样的:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> c &#123;<br>   <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，for range 每次从 channel中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。当 channel中没有数据可读的时候，for range 循环会阻塞在对 channel 的读操作上。直到channel 关闭时，for range 循环才会结束，这也是 for range 循环与 channel配合时隐含的循环判断条件。</p><h3 id="带-label-的-continue-语句">带 label 的 continue 语句</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>    <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 忽略切片中值为偶数的元素</span><br>        <span class="hljs-keyword">continue</span><br>    &#125;<br>    sum += sl[i]<br>&#125;<br><span class="hljs-built_in">println</span>(sum) <span class="hljs-comment">// 9</span><br></code></pre></div></td></tr></table></figure><p>与C语法上的continue并没有很大区别，但是Go 语言中的 continue 在 C 语言continue 语义的基础上又增加了对 label 的支持。</p><p>label 语句的作用，是标记跳转的目标。我们可以把上面的代码改造为使用label 的等价形式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><br>loop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 忽略切片中值为偶数的元素</span><br>            <span class="hljs-keyword">continue</span> loop<br>        &#125;<br>        sum += sl[i]<br>    &#125;<br>    <span class="hljs-built_in">println</span>(sum) <span class="hljs-comment">// 9</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而带 label 的 continue语句，通常出现于嵌套循环语句中，被用于跳转到外层循环并继续执行外层循环语句的下一个迭代，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == <span class="hljs-number">13</span> &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found 13 at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">continue</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>与goto的区别</strong>：使用goto不管是内层循环还是外层循环都会被终结，代码将会从outerloop 这个 label 处，开始重新执行我们的嵌套循环语句，这与带 label 的continue 的跳转语义是完全不同的。</p><h3 id="break-语句的使用">break 语句的使用</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>&#125;<br>    <span class="hljs-keyword">var</span> firstEven <span class="hljs-type">int</span> = <span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 找出整型切片sl中的第一个偶数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            firstEven = sl[i]<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">println</span>(firstEven) <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦找到就不需要继续执行后续迭代了，这个时候我们就通过 break语句跳出了这个循环。</p><p>和 continue 语句一样，Go 也 break 语句增加了对 label的支持。而且，和前面 continue 语句一样，如果遇到嵌套循环，break要想跳出外层循环，用不带 label 的 break 是不够，因为不带 label 的 break仅能跳出其所在的最内层循环。要想实现外层循环的跳出，我们还需给 break加上 label。我们来看一个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> gold = <span class="hljs-number">38</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == gold &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found gold at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">break</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们通过带有 label 的 break语句，就可以直接终结外层循环，从而从复杂多层次的嵌套循环中直接跳出，避免不必要的算力资源的浪费。</p><h3 id="for-语句的常见坑">for 语句的常见“坑”</h3><p><strong>问题一：循环变量的重用</strong> <strong>问题二：参与循环的是range 表达式的副本</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123; <span class="hljs-comment">// 是a的一个值拷贝</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>    &#125;<br>    r[i] = v<br>&#125;<br></code></pre></div></td></tr></table></figure><p>r中记录的还是原来的a，而不是修改后的</p><p>解决方案：使用切片</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a[:] &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>    &#125;<br>    r[i] = v<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当进行 range表达式复制时，我们实际上复制的是一个切片，也就是表示切片的结构体。表示切片副本的结构体中的array，依旧指向原切片对应的底层数组，所以我们对切片副本的修改也都会反映到底层数组a 上去。而 v 再从切片副本结构体中 array指向的底层数组中，获取数组元素，也就得到了被修改后的元素值。</p><p><strong>遍历 map 中元素的随机性</strong></p><p>如果我们在循环的过程中，对 map进行了修改，那么这样修改的结果是否会影响后续迭代呢？这个结果和我们遍历map 一样，具有随机性。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;tony&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;tom&quot;</span>:  <span class="hljs-number">22</span>,<br>    <span class="hljs-string">&quot;jim&quot;</span>:  <span class="hljs-number">23</span>,<br>&#125;<br><br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;tony&quot;</span>)<br>    &#125;<br>    counter++<br>    fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br></code></pre></div></td></tr></table></figure><p>如果我们反复运行这个例子多次，会得到两个不同的结果。当k="tony"作为第一个迭代的元素时，我们将得到如下结果：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">tony <span class="hljs-number">21</span><br>tom <span class="hljs-number">22</span><br>jim <span class="hljs-number">23</span><br>counter is  <span class="hljs-number">3</span><br><br><span class="hljs-comment">//or</span><br><br>tom <span class="hljs-number">22</span><br>jim <span class="hljs-number">23</span><br>counter is  <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>考虑到上述这种随机性，我们日常编码遇到遍历 map 的同时，还需要对 map进行修改的场景的时候，要格外小心。</p><h2 id="switch-语句">switch 语句</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> initStmt; expr &#123;<br>    <span class="hljs-keyword">case</span> expr1:<br>        <span class="hljs-comment">// 执行分支1</span><br>    <span class="hljs-keyword">case</span> expr2:<br>        <span class="hljs-comment">// 执行分支2</span><br>    <span class="hljs-keyword">case</span> expr3_1, expr3_2, expr3_3:<br>        <span class="hljs-comment">// 执行分支3</span><br>    <span class="hljs-keyword">case</span> expr4:<br>        <span class="hljs-comment">// 执行分支4</span><br>    ... ...<br>    <span class="hljs-keyword">case</span> exprN:<br>        <span class="hljs-comment">// 执行分支N</span><br>    <span class="hljs-keyword">default</span>: <br>        <span class="hljs-comment">// 执行默认分支</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在有多个 case 执行分支的 switch 语句中，Go 是按什么次序对各个 case表达式进行求值，并且与 switch 表达式（expr）进行比较的？</p><p>顺序执行，一旦匹配到对应case下面，后面的expr语句变不会执行；</p><p>还有一点，无论 default 分支出现在什么位置，它都只会在所有 case都没有匹配上的情况下才会被执行的。</p><h3 id="switch-语句的灵活性">switch 语句的灵活性</h3><p><strong>switch语句各表达式的求值结果可以为各种类型值，只要它的类型支持比较操作就可以了</strong></p><p><strong>switch 语句支持声明临时变量</strong></p><p><strong>case 语句支持表达式列表</strong></p><p><strong>取消了默认执行下一个 case 代码逻辑的语义</strong></p><p>如果在少数场景下，你需要执行下一个 case 的代码逻辑，你可以显式使用 Go提供的关键字 fallthrough 来实现，这也是 Go“显式”设计哲学的一个体现。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> switchexpr() &#123;<br>    <span class="hljs-keyword">case</span> case1():<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exec case1&quot;</span>)<br>        <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">case</span> case2():<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exec case2&quot;</span>)<br>        <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exec default&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="type-switch">type switch</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">13</span><br>    <span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;x is nil&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of x is int&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of x is string&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of x is string&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;don&#x27;t support the type&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>switch 关键字后面跟着的表达式为x.(type)，这种表达式形式是 switch语句专有的，而且也只能在 switch 语句中使用。这个表达式中的 x必须是一个接口类型变量，表达式的求值结果是这个接口类型变量对应的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">13</span><br>    <span class="hljs-keyword">switch</span> v := x.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;v is nil&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of v is int, v =&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of v is string, v =&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of v is bool, v =&quot;</span>, v)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;don&#x27;t support the type&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里我们将 switch 后面的表达式由x.(type)换成了v :=x.(type)。对于后者，你千万不要认为变量 v 存储的是类型信息，其实 v存储的是变量 x 的动态类型对应的值信息，这样我们在接下来的 case执行路径中就可以使用变量 v 中的值信息了。</p><h1 id="函数">函数</h1><h2 id="go-函数与函数声明">Go 函数与函数声明</h2><p>函数对应的英文单词是 Function，Function这个单词原本是功能、职责的意思。编程语言使用 Function这个单词，表示将一个大问题分解后而形成的、若干具有特定功能或职责的小任务，可以说十分贴切。函数代表的小任务可以在一个程序中被多次使用，甚至可以在不同程序中被使用，因此函数的出现也提升了整个程序界代码复用的水平。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FuncName</span><span class="hljs-params">(<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, ...)</span></span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, err <span class="hljs-type">error</span>)&#123;<br><span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>第一部分是关键字 func</strong>，Go 函数声明必须以关键字 func开始。</p><p><strong>第二部分是函数名</strong>，函数名是指代函数定义的标识符，函数声明后，我们会通过函数名这个标识符来使用这个函数。在同一个Go 包中，函数名应该是唯一的，并且它也遵守 Go标识符的导出规则，也就是我们之前说的，首字母大写的函数名指代的函数是可以在包外使用的，小写的就只在包内可见。</p><p><strong>第三部分是参数列表</strong>，参数列表中声明了我们将要在函数体中使用的各个参数。参数列表紧接在函数名的后面，并用一个括号包裹。它使用逗号作为参数间的分隔符，而且每个参数的参数名在前，参数类型在后，这和变量声明中变量名与类型的排列方式是一致的。</p><p><strong>第四部分是返回值列表</strong>，返回值承载了函数执行后要返回给调用者的结果，返回值列表声明了这些返回值的类型，返回值列表的位置紧接在参数列表后面，两者之间用一个空格隔开。</p><p><strong>放在一对大括号内的是函数体</strong>函数的具体实现都放在这里。不过，函数声明中的函数体是可选的。如果没有函数体，说明这个函数可能是在Go语言之外实现的，比如使用汇编语言实现，然后通过链接器将实现与声明中的函数名链接到一起。</p><p>等价的变量声明 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> FuncName = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, ...)</span></span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, err <span class="hljs-type">error</span>) &#123;&#125;<br></code></pre></div></td></tr></table></figure></p><p>函数声明中的函数名其实就是变量名，函数声明中的 func关键字、参数列表和返回值列表共同构成了函数类型。而参数列表与返回值列表的组合也被称为函数签名，它是决定两个函数类型是否相同的决定因素。因此，函数类型也可以看成是由func 关键字与函数签名组合而成的。</p><p>函数签名 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">type</span>, ...)</span></span> (<span class="hljs-keyword">type</span>, <span class="hljs-type">error</span>)<br></code></pre></div></td></tr></table></figure></p><p>这样，如果两个函数类型的函数签名是相同的，即便参数列表中的参数名，以及返回值列表中的返回值变量名都是不同的，那么这两个函数类型也是相同类型，比如下面两个函数类型：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">string</span>)</span></span> (results []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c <span class="hljs-type">int</span>, d <span class="hljs-type">string</span>)</span></span> (sl []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br></code></pre></div></td></tr></table></figure><p>如果我们把这两个函数类型的参数名与返回值变量名省略，那它们都是func(int, string) ([]string, error)，因此它们是相同的函数类型。</p><p>到这里，我们可以得到这样一个结论：每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例，就像vara int = 13这个变量声明语句中 a 是 int 类型的一个实例一样。</p><p><strong>函数字面值（Function Literal）</strong>函数字面值由函数类型与函数体组成，它特别像一个没有函数名的函数声明，因此我们也叫它匿名函数。</p><h2 id="函数参数">函数参数</h2><p>在函数声明阶段，我们把参数列表中的参数叫做形式参数（Parameter，简称形参），在函数体中，我们使用的都是形参；而在函数实际调用时传入的参数被称为实际参数（Argument，简称实参）。当我们实际调用函数的时候，实参会传递给函数，并和形式参数逐一绑定，编译器会根据各个形参的类型与数量，来检查传入的实参的类型与数量是否匹配。只有匹配，程序才能继续执行函数调用，否则编译器就会报错。</p><p>Go语言中，函数参数传递采用是值传递的方式。所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（BitwiseCopy）到形式参数中。对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。</p><p>但是像 string、切片、map这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“浅拷贝”。</p><p>不过函数参数的传递也有两个例外，当函数的形参为接口类型，或者形参是变长参数时，简单的值传递就不能满足要求了，这时Go 编译器会介入：对于类型为接口类型的形参，Go编译器会把传递的实参赋值给对应的接口类型形参；对于为变长参数的形参，Go编译器会将零个或多个实参按一定形式转换为对应的变长形参。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(sl []<span class="hljs-type">int</span>, elems ...<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, elems) <span class="hljs-comment">// []int</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;no elems to append&quot;</span>)<br>        <span class="hljs-keyword">return</span> sl<br>    &#125;<br><br>    sl = <span class="hljs-built_in">append</span>(sl, elems...)<br>    <span class="hljs-keyword">return</span> sl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sl := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    sl = myAppend(sl) <span class="hljs-comment">// no elems to append</span><br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3]</span><br>    sl = myAppend(sl, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3 4 5 6]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们重点看一下代码中的 myAppend 函数，这个函数基于append，实现了向一个整型切片追加数据的功能。它支持变长参数，它的第二个形参elems 就是一个变长参数。myAppend 函数通过 Printf输出了变长参数的类型。执行这段代码，我们将看到变长参数 elems的类型为[]int。这也就说明，在 Go中，变长参数实际上是通过切片来实现的。所以，我们在函数体中，就可以使用切片支持的所有操作来操作变长参数，这会大大简化了变长参数的使用复杂度。比如myAppend 中，我们使用 len 函数就可以获取到传给变长参数的实参个数。</p><h2 id="函数支持多返回值">函数支持多返回值</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>                       <span class="hljs-comment">// 无返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>                 <span class="hljs-comment">// 仅有一个返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>, <span class="hljs-type">error</span>)  <span class="hljs-comment">// 有2或2个以上返回值</span><br></code></pre></div></td></tr></table></figure><p>如果一个函数没有显式返回值，那么我们可以像第一种情况那样，在函数声明中省略返回值列表。而且，如果一个函数仅有一个返回值，那么通常我们在函数声明中，就不需要将返回值用括号括起来，如果是2 个或 2 个以上的返回值，那我们还是需要用括号括起来的</p><p>在函数声明的返回值列表中，我们通常会像上面例子那样，仅列举返回值的类型，但我们也可以像fmt.Fprintf函数的返回值列表那样，为每个返回值声明变量名，这种带有名字的返回值被称为具名返回值（NamedReturnValue）。这种具名返回值变量可以像函数体中声明的局部变量一样在函数体内使用。</p><p>当函数的返回值个数较多时，每次显式使用 return语句时都会接一长串返回值，这时，我们用具名返回值可以让函数实现的可读性更好一些，比如下面Go 标准库 time 包中的 parseNanoseconds 函数就是这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/format.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNanoseconds</span><span class="hljs-params">(value <span class="hljs-type">string</span>, nbytes <span class="hljs-type">int</span>)</span></span> (ns <span class="hljs-type">int</span>, rangeErrString <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> !commaOrPeriod(value[<span class="hljs-number">0</span>]) &#123;<br>        err = errBad<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns, err = atoi(value[<span class="hljs-number">1</span>:nbytes]); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns &lt; <span class="hljs-number">0</span> || <span class="hljs-number">1e9</span> &lt;= ns &#123;<br>        rangeErrString = <span class="hljs-string">&quot;fractional second&quot;</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    scaleDigits := <span class="hljs-number">10</span> - nbytes<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; scaleDigits; i++ &#123;<br>        ns *= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="函数是一等公民">函数是“一等公民”</h2><p>函数在 Go 语言中属于“一等公民（First-Class Citizen）”</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。<br></code></pre></div></td></tr></table></figure><p><strong>特征一：Go 函数可以存储在变量中</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    myFprintf = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-keyword">return</span> fmt.Fprintf(w, format, a...)<br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, myFprintf) <span class="hljs-comment">// func(io.Writer, string, ...interface &#123;&#125;) (int, error)</span><br>    myFprintf(os.Stdout, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Hello, Go&quot;</span>) <span class="hljs-comment">// 输出Hello，Go</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们把新创建的一个匿名函数赋值给了一个名为 myFprintf的变量，通过这个变量，我们便可以调用刚刚定义的匿名函数。然后我们再通过Printf 输出 myFprintf变量的类型，也会发现结果与我们预期的函数类型是相符的。</p><p><strong>特征二：支持在函数内创建并通过返回值返回</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">(task <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some setup stuff for&quot;</span>, task)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some teardown stuff for&quot;</span>, task)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    teardown := setup(<span class="hljs-string">&quot;demo&quot;</span>)<br>    <span class="hljs-keyword">defer</span> teardown()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some bussiness stuff&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个例子，模拟了执行一些重要逻辑之前的上下文建立（setup），以及之后的上下文拆除（teardown）。在一些单元测试的代码中，我们也经常会在执行某些用例之前，建立此次执行的上下文（setup），并在这些用例执行后拆除上下文（teardown），避免这次执行对后续用例执行的干扰。我们在setup函数中创建了这次执行的上下文拆除函数，并通过返回值的形式，将这个拆除函数返回给了setup 函数的调用者。setup函数的调用者，在执行完对应这次执行上下文的重要逻辑后，再调用 setup函数返回的拆除函数，就可以完成对上下文的拆除了。</p><p>从这段代码中我们也可以看到，setup函数中创建的拆除函数也是一个匿名函数，但和前面我们看到的匿名函数有一个不同，这个不同就在于这个匿名函数使用了定义它的函数setup 的局部变量 task，这样的匿名函数在 Go中也被称为闭包（Closure）。</p><p><strong>特征三：作为参数传入函数</strong></p><p>既然函数可以存储在变量中，也可以作为返回值返回，那我们可以理所当然地想到，把函数作为参数传入函数也是可行的。比如我们在日常编码时经常使用、标准库time 包的 AfterFunc函数，就是一个接受函数类型参数的典型例子。你可以看看下面这行代码，这里通过AfterFunc 函数设置了一个 2秒的定时器，并传入了时间到了后要执行的函数。这里传入的就是一个匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">time.AfterFunc(time.Second*<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timer fired&quot;</span>) &#125;)<br></code></pre></div></td></tr></table></figure><p><strong>特征四：拥有自己的类型</strong></p><p>每个函数都和整型值、字符串值等一等公民一样，拥有自己的类型，也就是我们讲过的函数类型。我们甚至可以基于函数类型来自定义类型，就像基于整型、字符串类型等类型来自定义类型一样。下面代码中的HandlerFunc、visitFunc 就是 Go标准库中，基于函数类型进行自定义的类型：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-comment">// $GOROOT/src/sort/genzfunc.go</span><br><span class="hljs-keyword">type</span> visitFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ast.Node)</span></span> ast.Visitor<br></code></pre></div></td></tr></table></figure><h2 id="函数一等公民特性的高效运用">函数“一等公民”特性的高效运用</h2><p><strong>应用一：函数类型的妙用</strong></p><p>Go函数是“一等公民”，也就是说，它拥有自己的类型。而且，整型、字符串型等所有类型都可以进行的操作，比如显式转型，也同样可以用在函数类型上面，也就是说，函数也可以被显式转型。并且，这样的转型在特定的领域具有奇妙的作用，一个最为典型的示例就是标准库http 包中的 HandlerFunc 这个类型。我们来看一个使用了这个类型的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome, Gopher!\n&quot;</span>)<br>&#125;                    <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.HandlerFunc(greeting))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以进行这让转换的前提是，两个函数的函数签名是一致的，这类似与底层类型一直的类之间的相互转换</p><p><strong>应用二：利用闭包简化函数调用</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">times</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x * y<br>&#125;<br><br><br>times(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算2 x 5</span><br>times(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算3 x 5</span><br>times(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算4 x 5</span><br></code></pre></div></td></tr></table></figure><p>这是一个简单乘法运算，不过，有些场景存在一些高频使用的乘数，这个时候我们就没必要每次都传入这样的高频乘数了。那我们怎样能省去高频乘数的传入呢?我们看看下面这个新函数 partialTimes：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partialTimes</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> times(x, y)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，partialTimes 的返回值是一个接受单一参数的函数，这个由partialTimes 函数生成的匿名函数，使用了 partialTimes 函数的参数x。按照前面的定义，这个匿名函数就是一个闭包。partialTimes实质上就是用来生成以 x为固定乘数的、接受另外一个乘数作为参数的、闭包函数的函数。当程序调用partialTimes(2) 时，partialTimes 实际上返回了一个调用 times(2,y)的函数，这个过程的逻辑类似于下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">timesTwo = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> times(<span class="hljs-number">2</span>, y)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个时候，我们再看看如何使用 partialTimes，分别生成以 2、3、4为固定高频乘数的乘法函数，以及这些生成的乘法函数的使用方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  timesTwo := partialTimes(<span class="hljs-number">2</span>)   <span class="hljs-comment">// 以高频乘数2为固定乘数的乘法函数</span><br>  timesThree := partialTimes(<span class="hljs-number">3</span>) <span class="hljs-comment">// 以高频乘数3为固定乘数的乘法函数</span><br>  timesFour := partialTimes(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 以高频乘数4为固定乘数的乘法函数</span><br>  fmt.Println(timesTwo(<span class="hljs-number">5</span>))   <span class="hljs-comment">// 10，等价于times(2, 5)</span><br>  fmt.Println(timesTwo(<span class="hljs-number">6</span>))   <span class="hljs-comment">// 12，等价于times(2, 6)</span><br>  fmt.Println(timesThree(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 15，等价于times(3, 5)</span><br>  fmt.Println(timesThree(<span class="hljs-number">6</span>)) <span class="hljs-comment">// 18，等价于times(3, 6)</span><br>  fmt.Println(timesFour(<span class="hljs-number">5</span>))  <span class="hljs-comment">// 20，等价于times(4, 5)</span><br>  fmt.Println(timesFour(<span class="hljs-number">6</span>))  <span class="hljs-comment">// 24，等价于times(4, 6)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="错误处理">错误处理</h2><p>Go函数增加了多返回值机制，来支持错误状态与返回信息的分离，并建议开发者把要返回给调用者的信息和错误状态标识，分别放在不同的返回值中。</p><p>Go标准库中有一个fmt.Fprintf的函数，这个函数就是使用一个独立的表示错误状态的返回值（如下面代码中的err），解决了 fprintf 函数中错误状态值与返回信息耦合在一起的问题：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// fmt包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></div></td></tr></table></figure><p>在 Go 语言中，我们依然可以像传统的 C语言那样，用一个整型值来表示错误状态，但 Go 语言惯用法，是使用 error这个接口类型表示错误，并且按惯例，我们通常将 error类型返回值放在返回值列表的末尾，就像 fmt.Fprintf 函数声明中那样。</p><h3 id="error-类型与错误值构造">error 类型与错误值构造</h3><p>error 接口是 Go 原生内置的类型，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/builtin/builtin.go</span><br><span class="hljs-keyword">type</span> <span class="hljs-keyword">interface</span> <span class="hljs-type">error</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>任何实现了 error 的 Error 方法的类型的实例，都可以作为错误值赋值给error 接口变量。那这里。error接口的错误值构造：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">err := errors.New(<span class="hljs-string">&quot;your first demo error&quot;</span>)<br>errWithCtx = fmt.Errorf(<span class="hljs-string">&quot;index %d is out of bounds&quot;</span>, i)<br></code></pre></div></td></tr></table></figure><p>这两种方法实际上返回的是同一个实现了 error接口的类型的实例，这个未导出的类型就是errors.errorString，它的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/errors/errors.go</span><br><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>    s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></div></td></tr></table></figure><p>大多数情况下，使用这两种方法构建的错误值就可以满足我们的需求了。但我们也要看到，虽然这两种构建错误值的方法很方便，但它们给错误处理者提供的错误上下文（ErrorContext）只限于以字符串形式呈现的信息，也就是 Error 方法返回的信息。</p><p>但在一些场景下，错误处理者需要从错误值中提取出更多信息，帮助他选择错误处理路径，显然这两种方法就不能满足了。这个时候，我们可以自定义错误类型来满足这一需求。比如：标准库中的net 包就定义了一种携带额外错误上下文的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    Op <span class="hljs-type">string</span><br>    Net <span class="hljs-type">string</span><br>    Source Addr<br>    Addr Addr<br>    Err <span class="hljs-type">error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，错误处理者就可以根据这个类型的错误值提供的额外上下文信息，比如Op、Net、Source 等，做出错误处理路径的选择，比如下面标准库中的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isCommonNetReadError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == <span class="hljs-string">&quot;read&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="error-类型的好处">error 类型的好处</h3><p><strong>第一点：统一了错误类型</strong></p><p>如果不同开发者的代码、不同项目中的代码，甚至标准库中的代码，都统一以error接口变量的形式呈现错误类型，就能在提升代码可读性的同时，还更容易形成统一的错误处理策略。</p><p><strong>第二点：错误是值</strong></p><p>我们构造的错误都是值，也就是说，即便赋值给 error这个接口类型变量，我们也可以像整型值那样对错误做“==”和“!=”的逻辑比较，函数调用者检视错误时的体验保持不变。</p><p><strong>第三点：易扩展，支持自定义错误上下文。</strong></p><p>虽然错误以 error接口变量的形式统一呈现，但我们很容易通过自定义错误类型来扩展我们的错误上下文，就像前面的Go 标准库的 OpError 类型那样。error接口是错误值的提供者与错误值的检视者之间的契约。error接口的实现者负责提供错误上下文，供负责错误处理的代码使用。这种错误具体上下文与作为错误值类型的error 接口类型的解耦，也体现了 Go 组合设计哲学中“正交”的理念。</p><h3 id="error-设计策略">error 设计策略</h3><p><strong>策略一：透明错误处理策略</strong></p><p>简单来说，Go 语言中的错误处理，就是根据函数 / 方法返回的 error类型变量中携带的错误值信息做决策，并选择后续代码执行路径的过程。这样，最简单的错误策略莫过于完全不关心返回错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">err := doSomething()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 不关心err变量底层错误值所携带的具体上下文信息</span><br>    <span class="hljs-comment">// 执行简单错误处理逻辑并返回</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这也是 Go 语言中最常见的错误处理策略，80% 以上的 Go错误处理情形都可以归类到这种策略下。在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造方（如上面的函数doSomething）可以直接使用Go标准库提供的两个基本错误值构造方法errors.New和fmt.Errorf来构造错误值，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(...)</span></span> <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;some error occurred&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样构造出的错误值代表的上下文信息，对错误处理方是透明的，因此这种策略称为“透明错误处理策略”。在错误处理方不关心错误值上下文的前提下，透明错误处理策略能最大程度地减少错误处理方与错误值构造方之间的耦合关系。</p><p><strong>策略二：“哨兵”错误处理策略</strong></p><p>当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的反模式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err.Error() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: negative count&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: buffer full&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单来说，反模式就是，错误处理方以透明错误值所能提供的唯一上下文信息（描述错误的字符串），作为错误处理路径选择的依据。但这种“反模式”会造成严重的隐式耦合。这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。</p><p>那这有什么办法吗？Go标准库采用了定义导出的（Exported）“哨兵”错误值的方式，来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策，比如下面的bufio 包中定义的“哨兵错误”：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/bufio/bufio.go</span><br><span class="hljs-keyword">var</span> (<br>    ErrInvalidUnreadByte = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>)<br>    ErrInvalidUnreadRune = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadRune&quot;</span>)<br>    ErrBufferFull        = errors.New(<span class="hljs-string">&quot;bufio: buffer full&quot;</span>)<br>    ErrNegativeCount     = errors.New(<span class="hljs-string">&quot;bufio: negative count&quot;</span>)<br>)<br></code></pre></div></td></tr></table></figure><p>下面的代码片段利用了上面的哨兵错误，进行错误处理分支的决策：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err &#123;<br>    <span class="hljs-keyword">case</span> bufio.ErrNegativeCount:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrBufferFull:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrInvalidUnreadByte:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，一般“哨兵”错误值变量以 ErrXXX格式命名。和透明错误策略相比，“哨兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。不过，对于API 的开发者而言，暴露“哨兵”错误值也意味着这些错误值和包的公共函数 /方法一起成为了 API的一部分。一旦发布出去，开发者就要对它进行很好的维护。而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。</p><p>从 Go 1.13 版本开始，标准库 errors 包提供了 Is函数用于错误处理方对错误值的检视。Is 函数类似于把一个 error类型变量与“哨兵”错误值进行比较，比如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if err == ErrOutOfBounds&#123; … &#125;</span><br><span class="hljs-keyword">if</span> errors.Is(err, ErrOutOfBounds) &#123;<br>    <span class="hljs-comment">// 越界的错误处理</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>不同的是，如果 error 类型变量的底层错误值是一个包装错误（WrappedError），errors.Is 方法会沿着该包装错误所在错误链（ErrorChain)，与链上所有被包装的错误（WrappedError）进行比较，直至找到一个匹配的错误为止。下面是 Is函数应用的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ErrSentinel = errors.New(<span class="hljs-string">&quot;the underlying sentinel error&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap sentinel: %w&quot;</span>, ErrSentinel)<br>err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br><span class="hljs-built_in">println</span>(err2 == ErrSentinel) <span class="hljs-comment">//false</span><br><span class="hljs-keyword">if</span> errors.Is(err2, ErrSentinel) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is ErrSentinel&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br> <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is not ErrSentinel&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你使用的是 Go 1.13及后续版本，建议尽量使用errors.Is方法去检视某个错误值是否就是某个预期错误值，或者包装了某个特定的“哨兵”错误值。</p><p><strong>策略三：错误值类型检视策略</strong></p><p>基于 Go标准库提供的错误值构造方法构造的“哨兵”错误值，除了让错误处理方可以“有的放矢”的进行值比较之外，并没有提供其他有效的错误上下文信息。那如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理策略和错误值构造方式都无法满足。这种情况下，我们需要通过自定义错误类型的构造错误值的方式，来提供更多的“错误上下文”信息。并且，由于错误值都通过error接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用Go 提供的类型断言机制（Type Assertion）或类型选择机制（TypeSwitch），这种错误处理方式，我称之为错误值类型检视策略。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-keyword">type</span> UnmarshalTypeError <span class="hljs-keyword">struct</span> &#123;<br>    Value  <span class="hljs-type">string</span>       <br>    Type   reflect.Type <br>    Offset <span class="hljs-type">int64</span>        <br>    Struct <span class="hljs-type">string</span>       <br>    Field  <span class="hljs-type">string</span>      <br>&#125;<br></code></pre></div></td></tr></table></figure><p>错误处理方可以通过错误类型检视策略，获得更多错误值的错误上下文信息，下面就是利用这一策略的json 包的一个方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> addErrorContext(err <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> d.errorContext.Struct != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(d.errorContext.FieldStack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *UnmarshalTypeError:<br>            err.Struct = d.errorContext.Struct.Name()<br>            err.Field = strings.Join(d.errorContext.FieldStack, <span class="hljs-string">&quot;.&quot;</span>)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，这段代码通过类型 switch 语句得到了 err变量代表的动态类型和值，然后在匹配的 case分支中利用错误上下文信息进行处理。这里，一般自定义导出的错误类型以XXXError的形式命名。和“哨兵”错误处理策略一样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数/ 方法一起，成为了 API的一部分。一旦发布出去，开发者就要对它们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖</p><p>从 Go 1.13 版本开始，标准库 errors包提供了As函数给错误处理方检视错误值。As函数类似于通过类型断言判断一个error 类型变量是否为特定的自定义错误类型，如下面代码所示：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if e, ok := err.(*MyError); ok &#123; … &#125;</span><br><span class="hljs-keyword">var</span> e *MyError<br><span class="hljs-keyword">if</span> errors.As(err, &amp;e) &#123;<br>    <span class="hljs-comment">// 如果err类型为*MyError，变量e将被设置为对应的错误值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    e <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> err = &amp;MyError&#123;<span class="hljs-string">&quot;MyError error demo&quot;</span>&#125;<br>    err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap err: %w&quot;</span>, err)<br>    err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br>    <span class="hljs-keyword">var</span> e *MyError<br>    <span class="hljs-keyword">if</span> errors.As(err2, &amp;e) &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is on the chain of err2&quot;</span>)<br>        <span class="hljs-built_in">println</span>(e == err)                  <br>        <span class="hljs-keyword">return</span>                             <br>    &#125;                                      <br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is not on the chain of err2&quot;</span>)<br>&#125; <br></code></pre></div></td></tr></table></figure><p>errors.As函数会沿着该包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错误类型，就像errors.Is 函数那样。</p><p>errors.As函数沿着 err2所在错误链向下找到了被包装到最深处的错误值，并将 err2 与其类型 *MyError成功匹配。匹配成功后，errors.As 会将匹配到的错误值存储到 As函数的第二个参数中，这也是为什么println(e == err)输出 true 的原因。</p><p>如果你使用的是 Go 1.13及后续版本，请尽量使用errors.As方法去检视某个错误值是否是某自定义错误类型的实例</p><p><strong>策略四：错误行为特征检视策略</strong></p><p>在 Go标准库中，我们发现了这样一种错误处理方式：将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。这种方式也被叫做错误行为特征检视策略。</p><p>以标准库中的net包为例，它将包内的所有错误类型的公共行为特征抽象并放入net.Error这个接口中，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> Error <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">error</span><br>    Timeout() <span class="hljs-type">bool</span>  <br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，net.Error 接口包含两个用于判断错误行为特征的方法：Timeout用来判断是否是超时（Timeout）错误，Temporary用于判断是否是临时（Temporary）错误。而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并根据这些信息做出后续错误处理分支选择的决策。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, e := l.Accept()<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-srv.getDoneChan():<br>                <span class="hljs-keyword">return</span> ErrServerClosed<br>            <span class="hljs-keyword">default</span>:<br>            &#125;<br>            <span class="hljs-keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;<br>                <span class="hljs-comment">// 注：这里对临时性(temporary)错误进行处理</span><br>                ... ...<br>                time.Sleep(tempDelay)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> e<br>        &#125;<br>        ...<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面代码中，Accept方法实际上返回的错误类型为<code>*OpError</code>，它是 net包中的一个自定义错误类型，它实现了错误公共特征接口net.Error，如下代码所示：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    ... ...<br>    <span class="hljs-comment">// Err is the error that occurred during the operation.</span><br>    Err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *OpError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">if</span> ne, ok := e.Err.(*os.SyscallError); ok &#123;<br>      t, ok := ne.Err.(temporary)<br>      <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>  &#125;<br>  t, ok := e.Err.(temporary)<br>  <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此，OpError实例可以被错误处理方通过net.Error接口的方法，判断它的行为是否满足Temporary 或 Timeout 特征。</p><p>在错误处理策略选择上： *请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合； *如果可以通过错误值类型的特征进行错误检视，那么请尽量使用“错误行为特征检视策略”;*在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略；* Go 1.13及后续版本中，尽量用errors.Is和errors.As函数替换原先的错误检视比较语句。</p><h2 id="go-语言中的异常">Go 语言中的异常</h2><h3 id="函数健壮性设计原则">函数健壮性设计原则</h3><p>原则一：不要相信任何外部输入的参数。</p><p>原则二：不要忽略任何一个错误。</p><p>原则三：不要假定异常不会发生。</p><h3 id="认识-go-语言中的异常panic">认识 Go 语言中的异常：panic</h3><p>panic 指的是 Go程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go程序的执行就会被终止，即便出现异常的位置不在主 Goroutine中也会这样。</p><p>在 Go 中，panic 主要有两类来源，一类是来自 Go 运行时，另一类则是 Go开发人员通过 panic 函数主动触发的。无论是哪种，一旦 panic 被触发，后续Go 程序的执行过程都是一样的，这个过程被 Go 语言称为 panicking。</p><p>Go 官方文档以手工调用 panic 函数触发 panic 为例，对 panicking这个过程进行了诠释：当函数 F 调用 panic 函数时，函数 F的执行将停止。不过，函数 F 中已进行求值的 deferred函数都会得到正常执行，执行完这些 deferred 函数后，函数 F才会把控制权返还给其调用者。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call foo&quot;</span>)<br>    bar()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit foo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zoo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call zoo&quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit zoo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call main&quot;</span>)<br>    foo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit main&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面这个例子中，从 Go 应用入口开始，函数的调用次序依次为main -&gt;foo -&gt; bar -&gt; zoo。在 bar 函数中，我们调用 panic 函数手动触发了panic。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">call</span> main<br><span class="hljs-keyword">call</span> foo<br><span class="hljs-keyword">call</span> <span class="hljs-built_in">bar</span><br>panic: panic occurs in <span class="hljs-built_in">bar</span><br></code></pre></div></td></tr></table></figure><p>从 main 函数的视角来看，这就好比将它对 foo 函数的调用，换成了对 panic函数的调用一样。结果就是，main函数的执行也被终止了，于是整个程序异常退出，日志"exitmain"也没有得到输出的机会。不过，Go 也提供了捕捉 panic并恢复程序正常执行秩序的方法，我们可以通过 recover函数来实现这一点。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> e := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;recover the panic:&quot;</span>, e)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>recover 是 Go 内置的专门用于恢复 panic 的函数，它必须被放在一个 defer函数中才能生效。如果 recover 捕捉到 panic，它就会返回以 panic的具体内容为错误上下文信息的错误值。如果没有 panic 发生，那么 recover将返回 nil。而且，如果 panic 被 recover 捕捉到，panic 引发的 panicking过程就会停止。</p><h3 id="如何应对-panic">如何应对 panic？</h3><ul><li>第一点：评估程序对 panic的忍受度，不同应用对异常引起的程序崩溃退出的忍受度是不一样的。比如，一个单次运行于控制台窗口中的命令行交互类程序（CLI），和一个常驻内存的后端HTTP服务器程序，对异常崩溃的忍受度就是不同的。前者即便因异常崩溃，对用户来说也仅仅是再重新运行一次而已。但后者一旦崩溃，就很可能导致整个网站停止服务。所以，针对各种应用对panic 忍受度的差异，我们采取的应对 panic 的策略也应该有不同。</li><li>第二点：提示潜在 bug。C 语言中有个很好用的辅助函数，断言（assert宏）。在使用 C编写代码时，我们经常在一些代码执行路径上，使用断言来表达这段执行路径上某种条件一定为真的信心。断言为真，则程序处于正确运行状态，断言为否就是出现了意料之外的问题，而这个问题很可能就是一个潜在的bug，这时我们可以借助断言信息快速定位到问题所在。</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/encoding/json/encode.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *reflectWithString)</span></span> resolve() <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">switch</span> w.k.Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<br>        w.ks = strconv.FormatInt(w.k.Int(), <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br>        w.ks = strconv.FormatUint(w.k.Uint(), <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unexpected map key type&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们也看到，去掉这行代码并不会对resolve方法的逻辑造成任何影响，但真正出现问题时，开发人员就缺少了“断言”潜在bug 提醒的辅助支持了。在 Go 标准库中，大多数 panic的使用都是充当类似断言的作用的。</p><ul><li>第三点：不要混淆异常与错误。在日常编码中，我经常会看到一些 Go语言初学者，尤其是一些有过 Java 语言编程经验的程序员，会因为习惯了 Java那种基于try-catch-finally的错误处理思维，而将 Go panic 当成 Java的“checked exception”去用，这显然是混淆了 Go 中的异常与错误，这是 Go错误处理的一种反模式。在 Go 中，作为 API 函数的作者，你一定不要将 panic当作错误返回给 API 调用者。</li></ul><h2 id="使用-defer-简化函数实现">使用 defer 简化函数实现</h2><p>对函数设计来说，如何实现简洁的目标是一个大话题。你可以从通用的设计原则去谈，比如函数要遵守单一职责，职责单一的函数肯定要比担负多种职责的函数更简单。你也可以从函数实现的规模去谈，比如函数体的规模要小，尽量控制在80 行代码之内等。但我们这个是 Go 语言的课程，所以我们的角度更侧重于 Go中是否有现成的语法元素，可以帮助我们简化 Go函数的设计和实现。我也把答案剧透给你，有的，它就是 defer。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br><br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    err = doWithResources() <br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r3.Close()<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    r3.Close()<br>    r2.Close()<br>    r1.Close()<br>    mu.Unlock()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，这类代码的特点就是在函数中会申请一些资源，并在函数退出前释放或关闭这些资源，比如这里的互斥锁mu 以及资源 r1~r3 就是这样。</p><p>函数的实现需要确保，无论函数的执行流是按预期顺利进行，还是出现错误，这些资源在函数退出时都要被及时、正确地释放。为此，我们需要尤为关注函数中的错误处理，在错误处理时不能遗漏对资源的释放。</p><p>但这样的要求，就导致我们在进行资源释放，尤其是有多个资源需要释放的时候，比如上面示例那样，会大大增加开发人员的心智负担。同时当待释放的资源个数较多时，整个代码逻辑就会变得十分复杂，程序可读性、健壮性也会随之下降。但即便如此，如果函数实现中的某段代码逻辑抛出panic，传统的错误处理机制依然没有办法捕获它并尝试从 panic 恢复。</p><p>defer 是 Go 语言提供的一种延迟调用机制，defer的运作离不开函数。怎么理解呢？这句话至少有以下两点含义： * 在 Go中，只有在函数（和方法）内部才能使用 defer； * defer关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。defer将它们注册到其所在 Goroutine 中，用于存放 deferred函数的栈数据结构中，这些 deferred 函数将在执行 defer的函数退出前，按后进先出（LIFO）的顺序被程序调度执行</p><p>而且，无论是执行到函数体尾部返回，还是在某个错误处理分支显式return，又或是出现 panic，已经存储到 deferred函数栈中的函数，都会被调度执行。所以说，deferred函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。</p><p>刚才那个例子可以改成</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br><br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r1.Close()<br><br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r2.Close()<br><br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r3.Close()<br><br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    <span class="hljs-keyword">return</span> doWithResources() <br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，使用 defer后对函数实现逻辑的简化是显而易见的。而且，这里资源释放函数的 defer注册动作，紧邻着资源申请成功的动作，这样成对出现的惯例就极大降低了遗漏资源释放的可能性，我们开发人员也不用再小心翼翼地在每个错误处理分支中检查是否遗漏了某个资源的释放动作。同时，代码的简化也意味代码可读性的提高，以及代码健壮度的增强。</p><h3 id="defer-使用的几个注意事项">defer 使用的几个注意事项</h3><ul><li>第一点：明确哪些函数可以作为 deferred函数。对于自定义的函数或方法，defer可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在deferred函数被调度执行的时候被自动丢弃。append、cap、len、make、new、imag等内置函数都是不能直接作为 deferred 函数的，而close、copy、delete、print、recover 等内置函数则可以直接被 defer 设置为deferred 函数。</li><li>第二点：注意 defer 关键字后面表达式的求值时机。defer关键字后面的表达式，是在将 deferred 函数注册到 deferred函数栈的时候进行求值的。</li><li>第三点：知晓 defer 带来的性能损耗。在 Go 1.13 前的版本中，defer带来的开销还是很大的。使用 defer 的函数的执行时间是没有使用 defer 函数的8 倍左右。但从 Go 1.13 版本开始，Go 核心团队对 defer性能进行了多次优化，到现在的 Go 1.17 版本，defer的开销已经足够小了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-复合类型</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="数组类型">数组类型</h1><p>Go语言的数组是一个长度固定的、由同构类型元素组成的连续序列。通过这个定义，我们可以识别出Go的数组类型包含两个重要属性：元素的类型和数组长度（元素的个数）。这两个属性也直接构成了Go 语言中数组类型变量的声明：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [N]T<br></code></pre></div></td></tr></table></figure><p>如果两个数组类型的元素类型 T 与数组长度 N都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(arr [5]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr3 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><br>    foo(arr1) <span class="hljs-comment">// ok</span><br>    foo(arr2) <span class="hljs-comment">// 错误：[6]int与函数foo参数的类型[5]int不是同一数组类型</span><br>    foo(arr3) <span class="hljs-comment">// 错误：[5]string与函数foo参数的类型[5]int不是同一数组类型</span><br>&#125;  <br></code></pre></div></td></tr></table></figure><p>数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。Go编译器在为数组类型的变量实际分配内存时，会为 Go数组分配一整块、可以容纳它所有元素的连续内存。</p><p>从这个数组类型的内存表示中可以看出来，这块内存全部空间都被用来表示数组元素，所以说这块内存的大小，就等于各个数组元素的大小之和。如果两个数组所分配的内存大小不同，那么它们肯定是不同的数组类型。Go提供了预定义函数 <code>len</code>可以用于获取一个数组类型变量的长度，通过 <code>unsafe</code> 包提供的<code>Sizeof</code>函数，我们可以获得一个数组变量的总大小，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;数组长度：&quot;</span>, <span class="hljs-built_in">len</span>(arr))           <span class="hljs-comment">// 6</span><br>fmt.Println(<span class="hljs-string">&quot;数组大小：&quot;</span>, unsafe.Sizeof(arr)) <span class="hljs-comment">// 6 * 8 = 48</span><br></code></pre></div></td></tr></table></figure><p>和基本数据类型一样，我们声明一个数组类型变量的同时，也可以显式地对它进行初始化。我们需要在右值中显式放置数组类型，并通过大括号的方式给各个元素赋值（如下面代码中的arr2）。如果不进行显式初始化，那么数组中的元素值就是它类型的零值。我们也可以忽略掉右值初始化表达式中数组类型的长度，用“…”替代，Go编译器会根据数组元素的个数，自动计算出数组长度。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// [0 0 0 0 0 0]</span><br><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>,<br>&#125; <span class="hljs-comment">// [11 12 13 14 15 16]</span><br><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-type">int</span> &#123; <br>    <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>,<br>&#125; <span class="hljs-comment">// [21 22 23]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr3) <span class="hljs-comment">// [3]int</span><br><br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-number">99</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">// 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr4) <span class="hljs-comment">// [100]int</span><br></code></pre></div></td></tr></table></figure><h1 id="多维数组">多维数组</h1><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mArr [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></div></td></tr></table></figure><p>多维数组也不难理解，我们以上面示例中的多维数组类型为例，我们从左向右逐维地去看，这样我们就可以将一个多维数组分层拆解成这样</p><p><img src="/page/2022-05/mArr.png" /></p><p>虽然数组类型是 Go语言中最基础的复合数据类型，但是在使用中它也会有一些问题。数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。这点与C 语言完全不同，在 C语言中，数组变量可视为指向数组第一个元素的指针。这样一来，无论是参与迭代，还是作为实际参数传给一个函数/ 方法，Go传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。虽然可以使用指针的方式，来向函数传递数组，但这样做的确可以避免性能损耗，但这更像是C 语言的惯用法。其实，Go 语言为我们提供了一种更为灵活、更为地道的方式，切片，来解决这个问题。它的优秀特性让它成为了 Go语言中最常用的同构复合类型。</p><h1 id="切片">切片</h1><p>初始化切片</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></div></td></tr></table></figure><p>与数组声明相比，切片声明仅仅是少了一个“长度”属性。去掉“长度”这一束缚后，切片展现出更为灵活的特性，这些特性我们后面再分析。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 6</span><br><br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">7</span>) <span class="hljs-comment">// 切片变为[1 2 3 4 5 6 7]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure><p>上面代码，表示的是通过len获取切片长度，通过append追加7到切片后面，长度也会对应变化。</p><h2 id="切片的底层实现">切片的底层实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer<br>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每个切片包含三个字段：</p><ul><li>array: 是指向底层数组的指针；</li><li>len: 是切片的长度，即切片中当前元素的个数；</li><li>cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len值。</li></ul><h3 id="其他切片的创建方式">其他切片的创建方式</h3><p><strong>方法一：通过 make函数来创建切片，并指定底层数组的长度。</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 其中10为cap值，即底层数组长度，6为切片的初始长度</span><br></code></pre></div></td></tr></table></figure><p>如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len</p><p><strong>方法二：采用 array[low : high :max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>sl := arr[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>]<br></code></pre></div></td></tr></table></figure><p>我们基于数组 arr 创建了一个切片 sl，这个切片 sl在运行时中的表示是这样</p><p><img src="/page/2022-05/slice.png" /></p><p>我们看到，基于数组创建的切片，它的起始元素从 low所标识的下标值开始，切片的长度（len）是 high - low，它的容量是 max -low。而且，由于切片 sl 的底层数组就是数组 arr，对切片 sl中元素的修改将直接影响数组 arr 变量。比如，如果我们将切片的第一个元素加10，那么数组 arr 的第四个元素将变为 14。</p><p>切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。这有些类似于我们操作文件之前打开的“文件描述符”（Windows上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。可以说，切片之于数组就像是文件描述符之于文件。</p><p>针对一个已存在的数组，我们还可以建立多个操作数组的切片，这些切片共享同一底层数组，切片对底层数组的操作也同样会反映到其他切片中。</p><p><strong>方法三：基于切片创建切片</strong></p><p>这种切片的运行时表示原理与上面的是一样的</p><h2 id="切片的动态扩容">切片的动态扩容</h2><p>“动态扩容”指的就是，当我们通过 append操作向切片追加数据的时候，如果这时切片的 len 值和 cap值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。前面的切片变量nums 之所以可以存储下新追加的值，就是因为 Go对其进行了动态扩容，也就是重新分配了其底层数组，从一个长度为 6的数组变成了一个长为 12 的数组。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">11</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//1 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">13</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//3 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">14</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//4 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">15</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//5 8</span><br></code></pre></div></td></tr></table></figure><p>append操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">u := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;array:&quot;</span>, u) <span class="hljs-comment">// [11, 12, 13, 14, 15]</span><br>s := u[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s) <span class="hljs-comment">// [12, 13]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">24</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 24, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 24, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">25</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 25, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 25, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">26</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 26, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 26, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span><br>fmt.Println(<span class="hljs-string">&quot;after reassign 1st elem of slice, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br></code></pre></div></td></tr></table></figure><p>运行这段代码，我们得到这样的结果</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br><span class="hljs-keyword">slice</span>(len=<span class="hljs-number">2</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">24</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">15</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">24</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">3</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">25</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">25</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">4</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">26</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">26</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">5</span>, cap=<span class="hljs-number">8</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]<br><span class="hljs-keyword">after</span> <span class="hljs-keyword">reassign</span> <span class="hljs-number">1</span>st elem <span class="hljs-keyword">of</span> <span class="hljs-keyword">slice</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> <span class="hljs-keyword">reassign</span> <span class="hljs-number">1</span>st elem <span class="hljs-keyword">of</span> <span class="hljs-keyword">slice</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">5</span>, cap=<span class="hljs-number">8</span>): [<span class="hljs-number">22</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]<br></code></pre></div></td></tr></table></figure><p>这里，在 append 25 之后，切片的元素已经触碰到了底层数组 u的边界了。然后我们再 append 26 之后，append 发现底层数组已经无法满足append 的要求，于是新创建了一个底层数组（数组长度为 cap(s) 的 2 倍，即8），并将 slice 的元素拷贝到新数组中了。</p><p>在这之后，我们即便再修改切片的第一个元素值，原数组 u的元素也不会发生改变了，因为这个时候切片 s 与数组 u已经解除了“绑定关系”，s 已经不再是数组 u的“描述符”了。这种因切片的自动扩容而导致的“绑定关系”解除，有时候会成为实践道路上的一个小陷阱，一定要注意这一点。</p><h1 id="map-类型">Map 类型</h1><p>map 是 Go语言提供的一种抽象数据类型，它表示一组无序的键值对。在后面的讲解中，我们会直接使用key 和 value 分别代表 map 的键和值。而且，map 集合中每个 key都是唯一的。和切片类似，作为复合类型的 map，它在 Go 中的类型表示也是由key 类型与 value 类型组成的，就像下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[key_type]value_type<br></code></pre></div></td></tr></table></figure><p>这里，我们要注意，map 类型对 value 的类型没有限制，但是对 key的类型却有严格要求，因为 map 类型要保证 key 的唯一性。Go 语言中要求，key的类型必须支持<code>==</code>和<code>!=</code>两种比较操作符。</p><p>在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil的比较，而不支持同类型两个变量的比较。如果像下面代码这样，进行这些类型的比较，Go编译器将会报错：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><span class="hljs-built_in">println</span>(s1 == s2) <span class="hljs-comment">// 错误：invalid operation: s1 == s2 (slice can only be compared to nil)</span><br><span class="hljs-built_in">println</span>(f1 == f2) <span class="hljs-comment">// 错误：invalid operation: f1 == f2 (func can only be compared to nil)</span><br><span class="hljs-built_in">println</span>(m1 == m2) <span class="hljs-comment">// 错误：invalid operation: m1 == m2 (map can only be compared to nil)</span><br></code></pre></div></td></tr></table></figure><p>因此在这里，你一定要注意：函数类型、map类型自身，以及切片类型是不能作为 map 的 key 类型的。</p><h2 id="map-变量的声明和初始化">map 变量的声明和初始化</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 一个map[string]int类型的变量</span><br></code></pre></div></td></tr></table></figure><p>和切片类型变量一样，如果我们没有显式地赋予 map 变量初值，map类型变量的默认值为 nil。不过切片变量和 map变量在这里也有些不同。初值为零值 nil 的切片类型变量，可以借助内置的append 的函数进行操作，这种在 Go 语言中被称为“零值可用”。但 map类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的map变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// m = nil</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-number">1</span>         <span class="hljs-comment">// 发生运行时异常：panic: assignment to entry in nil map</span><br></code></pre></div></td></tr></table></figure><p>为 map类型变量显式赋值有两种方式：一种是使用复合字面值；另外一种是使用 make这个预声明的内置函数。</p><p><strong>方法一：使用复合字面值初始化 map 类型变量。</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>这里，我们显式初始化了 map 类型变量 m。不过，你要注意，虽然此时 map类型变量 m 中没有任何键值对，但变量 m 也不等同于初值为 nil 的 map变量。这个时候，我们对 m 进行键值对的插入操作，不会引发运行时异常。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-number">1</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val1_1&quot;</span>, <span class="hljs-string">&quot;val1_2&quot;</span>&#125;,<br>    <span class="hljs-number">3</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val3_1&quot;</span>, <span class="hljs-string">&quot;val3_2&quot;</span>, <span class="hljs-string">&quot;val3_3&quot;</span>&#125;,<br>    <span class="hljs-number">7</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val7_1&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123; <br>    x <span class="hljs-type">float64</span> <br>    y <span class="hljs-type">float64</span><br>&#125;<br><br>m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    Position&#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    Position&#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    Position&#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go 还提供了“语法糖”。这种情况下，Go 允许省略字面值中的元素类型。因为map 类型表示中包含了 key 和 value 的元素类型，Go编译器已经有足够的信息，来推导出字面值中各个值的类型了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    &#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    &#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    &#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二：使用 make 为 map类型变量进行显式初始化。</strong></p><p>和切片通过 make 进行初始化一样，通过 make 的初始化方式，我们可以为map类型变量指定键值对的初始容量，但无法进行具体的键值对赋值，就像下面代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 未指定初始容量</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 指定初始容量为8</span><br></code></pre></div></td></tr></table></figure><p>map类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量后，Go运行时会自动增加 map 类型的容量，保证后续键值对的正常插入。</p><h2 id="map-基本操作">Map 基本操作</h2><p><strong>操作一：插入新键值对。</strong></p><p>面对一个非 nil 的 map 类型变量，我们可以在其中插入符合 map类型定义的任意新键值对。插入新键值对的方式很简单，我们只需要把 value赋值给 map 中对应的 key 就可以了：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value1&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;value2&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;value3&quot;</span><br></code></pre></div></td></tr></table></figure><p>不过，如果我们插入新键值对的时候，某个 key 已经存在于 map中了，那我们的插入操作就会用新值覆盖旧值：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 11会覆盖掉&quot;key1&quot;对应的旧值1</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment">// 此时m为map[key1:11 key2:2 key3:3]</span><br></code></pre></div></td></tr></table></figure><p><strong>操作二：获取键值对数量。</strong></p><p>和切片一样，map 类型也可以通过内置函数len，获取当前变量已经存储的键值对数量:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 2</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure><p>这里要注意的是我们不能对 map 类型变量调用 cap，来获取当前容量，这是map 类型与切片类型的一个不同点。</p><p><strong>操作三：查找和数据读取</strong></p><p>和写入相比，map类型更多用在查找和数据读取场合。所谓查找，就是判断某个 key是否存在于某个 map 中。有了前面向 map插入键值对的基础，我们可能自然而然地想到，可以用下面代码去查找一个键并获得该键对应的值：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v := m[<span class="hljs-string">&quot;key1&quot;</span>]<br></code></pre></div></td></tr></table></figure><p>乍一看，第二行代码在语法上好像并没有什么不当之处，但其实通过这行语句，我们还是无法确定键key1 是否真实存在于 map中。这是因为，当我们尝试去获取一个键对应的值的时候，如果这个键在 map中并不存在，我们也会得到一个值，这个值是 value 元素类型的零值。</p><p>那么在 map 中查找 key 的正确姿势是什么呢？Go 语言的 map类型支持通过用一种名为“comma ok”的惯用法，进行对某个 key的查询。接下来我们就用“comma ok”惯用法改造一下上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br>    <span class="hljs-comment">// &quot;key1&quot;不在map中</span><br>&#125;<br><br><span class="hljs-comment">// &quot;key1&quot;在map中，v将被赋予&quot;key1&quot;键对应的value</span><br></code></pre></div></td></tr></table></figure><p>如果我们并不关心某个键对应的 value，而只关心某个键是否在于 map中，我们可以使用空标识符替代变量 v，忽略可能返回的 value：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>_, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br>... ...<br></code></pre></div></td></tr></table></figure><p>因此，一定要记住：在 Go 语言中，请使用“comma ok”惯用法对 map进行键查找和键值读取操作。</p><p><strong>操作四：删除数据。</strong></p><p>在 Go 中，我们需要借助内置函数 delete 来从 map 中删除数据。使用delete 函数的情况下，传入的第一个参数是我们的 map类型变量，第二个参数就是我们想要删除的键。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key2&quot;</span>) <span class="hljs-comment">// 删除&quot;key2&quot;</span><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1]</span><br></code></pre></div></td></tr></table></figure><p>这里要注意的是，delete 函数是从 map 中删除键的唯一方法。即便传给delete 的键在 map 中并不存在，delete函数的执行也不会失败，更不会抛出运行时的异常。</p><p><strong>操作五：遍历 map 中的键值数据</strong></p><p>遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range语句对 map 数据进行遍历。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们只关心每次迭代的键，我们可以使用下面的方式对 map进行遍历：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> m &#123; <br>  <span class="hljs-comment">// 使用k</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 使用k</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们只关心每次迭代返回的键所对应的value，我们同样可以通过空标识符替代变量 k，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 使用v</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到，对同一 map做多次遍历的时候，每次遍历元素的次序都不相同。这是 Go 语言 map类型的一个重要特点，也是很容易让 Go初学者掉入坑中的一个地方。所以这里你一定要记住：程序逻辑千万不要依赖遍历map 所得到的的元素次序。</p><h2 id="map-变量的传递开销">map 变量的传递开销</h2><p>和切片类型一样，map 也是引用类型。这就意味着 map类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”</p><h2 id="map-的内部实现">map 的内部实现</h2><p>和切片相比，map 类型的内部实现要更加复杂。Go运行时使用一张哈希表来实现抽象的 map 类型。运行时实现了 map类型操作的所有功能，包括查找、插入、删除等。在编译阶段，Go 编译器会将 Go语法层面的 map操作，重写成运行时对应的函数调用。大致的对应关系是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 创建map类型变量实例</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)<br><span class="hljs-comment">// 插入新键值对或给键重新赋值</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span> → v := runtime.mapassign(maptype, m, <span class="hljs-string">&quot;key&quot;</span>) v是用于后续存储value的空间的地址<br><span class="hljs-comment">// 获取某键的值 </span><br>v := m[<span class="hljs-string">&quot;key&quot;</span>]      → v := runtime.mapaccess1(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br>v, ok := m[<span class="hljs-string">&quot;key&quot;</span>]  → v, ok := runtime.mapaccess2(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">// 删除某键</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key&quot;</span>)   → runtime.mapdelete(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/page/2022-05/map1.png" /></p><p>我们可以看到，和切片的运行时表示图相比，map的实现示意图显然要复杂得多。接下来，我们结合这张图来简要描述一下 map在运行时层的实现原理。我们重点讲解一下一个 map变量在初始状态、进行键值对操作后，以及在并发场景下的 Go运行时层的实现原理。</p><h3 id="初始状态">初始状态</h3><p>从图中我们可以看到，与语法层面 map 类型变量（m）一一对应的是<code>*runtime.hmap</code> 的实例，即 <code>runtime.hmap</code>类型的指针，也就是我们前面在讲解 <code>map</code>类型变量传递开销时提到的 <code>map</code> 类型的描述符。hmap 类型是 map类型的头部结构（header），它存储了后续 map类型操作所需的所有信息，包括：</p><p><img src="/page/2022-05/map2.png" /></p><p>真正用来存储键值对数据的是桶，也就是 <code>bucket</code>，每个<code>bucket</code> 中存储的是 Hash 值低 bit位数值相同的元素，默认的元素个数为 BUCKETSIZE（值为 8，Go 1.17 版本中在<code>$GOROOT/src/cmd/compile/internal/reflectdata/reflect.go</code>中定义，与 <code>runtime/map.go</code> 中常量 <code>bucketCnt</code>保持一致）。</p><p>当某个 <code>bucket</code>（比如 <code>buckets[0]</code>) 的 8 个空槽slot）都填满了，且 <code>map</code>尚未达到扩容的条件的情况下，运行时会建立<code>overflow bucket</code>，并将这个 <code>overflow bucket</code>挂在上面<code>bucket</code>（如 <code>buckets[0]</code>）末尾的<code>overflow</code> 指针上，这样两个<code>buckets</code>形成了一个链表结构，直到下一次 map扩容之前，这个结构都会一直存在。从图中我们可以看到，每个<code>bucket</code> 由三部分组成，从上到下分别是 <code>tophash</code>区域、key 存储区域和 value 存储区域。</p><h3 id="tophash-区域">tophash 区域</h3><p>当我们向 map 插入一条数据，或者是从 map 按 key查询数据的时候，运行时都会使用哈希函数对 key做哈希运算，并获得一个哈希值（hashcode）。这个 hashcode非常关键，运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定bucket，高位区的值用于在某个 bucket 中确定 key的位置。我把这一过程整理成了下面这张示意图，你理解起来可以更直观：</p><p><img src="/page/2022-05/map3.png" /></p><p>因此，每个 bucket 的 tophash 区域其实是用来快速定位 key位置的，这样就避免了逐个 key 进行比较这种代价较大的操作。尤其是当 key 是size较大的字符串类型时，好处就更突出了。这是一种以空间换时间的思路。</p><h3 id="key-存储区域">key 存储区域</h3><p>我们看 tophash 区域下面是一块连续的内存区域，存储的是这个 bucket承载的所有 key 数据。运行时在分配 bucket 的时候需要知道 key 的Size。</p><p>当我们声明一个 map 类型变量，比如 <code>var m map[string]int</code>时，Go 运行时就会为这个变量对应的特定 map类型，生成一个<code>runtime.maptype</code>实例。如果这个实例已经存在，就会直接复用。maptype实例的结构是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> maptype <span class="hljs-keyword">struct</span> &#123;<br>    typ        _type<br>    key        *_type<br>    elem       *_type<br>    bucket     *_type <span class="hljs-comment">// internal type representing a hash bucket</span><br>    keysize    <span class="hljs-type">uint8</span>  <span class="hljs-comment">// size of key slot</span><br>    elemsize   <span class="hljs-type">uint8</span>  <span class="hljs-comment">// size of elem slot</span><br>    bucketsize <span class="hljs-type">uint16</span> <span class="hljs-comment">// size of bucket</span><br>    flags      <span class="hljs-type">uint32</span><br>&#125; <br></code></pre></div></td></tr></table></figure><p>我们可以看到，这个实例包含了我们需要的 map类型中的所有"元信息"。我们前面提到过，编译器会把语法层面的 map操作重写成运行时对应的函数调用，这些运行时函数都有一个共同的特点，那就是第一个参数都是maptype 指针类型的参数。</p><p>Go 运行时就是利用 maptype 参数中的信息确定 key 的类型和大小的。map所用的 hash 函数也存放在 maptype.key.alg.hash(key, hmap.hash0) 中。同时maptype 的存在也让 Go 中所有 map 类型都共享一套运行时 map操作函数，而不是像 C++ 那样为每种 map 类型创建一套 map操作函数，这样就节省了对最终二进制文件空间的占用。</p><h3 id="value-存储区域">value 存储区域</h3><p>key 存储区域下方的另外一块连续的内存区域，这个区域存储的是 key 对应的value。和 key 一样，这个区域的创建也是得到了 <code>maptype</code>中信息的帮助。Go 运行时采用了把 key 和 value分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。</p><p><code>map[int8]int64</code> 为例，看看下面的存储空间利用率对比图</p><p><img src="/page/2022-05/map4.png" /></p><p>当前 Go 运行时使用的方案内存利用效率很高，而 kv紧邻存储的方案在<code>map[int8]int64</code>这样的例子中内存浪费十分严重，它的内存利用率是<code>72/128=56.25%</code>，有近一半的空间都浪费掉了。另外，还有一点要强调一下，如果key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket中直接存储数据，而是会存储 key 或 value 数据的指针。目前 Go运行时定义的最大 key 和 value 的长度是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/map.go</span><br><span class="hljs-keyword">const</span> (<br>    maxKeySize  = <span class="hljs-number">128</span><br>    maxElemSize = <span class="hljs-number">128</span><br>)<br></code></pre></div></td></tr></table></figure><h3 id="map-扩容">map 扩容</h3><p>我们前面提到过，map会对底层使用的内存进行自动管理。因此，在使用过程中，当插入元素个数超出一定数值后，map一定会存在自动扩容的问题，也就是怎么扩充 bucket 的数量，并重新在 bucket间均衡分配数据的问题。那么 map 在什么情况下会进行扩容呢？Go 运行时的 map实现中引入了一个 LoadFactor（负载因子），当 count &gt; LoadFactor * 2^B或 overflow bucket 过多时，运行时会自动对 map 进行扩容。目前 Go 最新1.17 版本 LoadFactor 设置为 6.5（loadFactorNum/loadFactorDen）。这里是Go 中与 map 扩容相关的部分源码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/map.go</span><br><span class="hljs-keyword">const</span> (<br>  ... ...<br><br>  loadFactorNum = <span class="hljs-number">13</span><br>  loadFactorDen = <span class="hljs-number">2</span><br>  ... ...<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>  ... ...<br>  <span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>    hashGrow(t, h)<br>    <span class="hljs-keyword">goto</span> again <span class="hljs-comment">// Growing the table invalidates everything, so try again</span><br>  &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这两方面原因导致的扩容，在运行时的操作其实是不一样的。如果是因为overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的bucket 数组，然后在 assign 和 delete时做排空和迁移。如果是因为当前数据数量超出 LoadFactor指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。原bucket 数组会挂在 hmap 的 oldbuckets 指针下面，直到原 buckets数组中所有数据都迁移到新数组后，原 buckets数组才会被释放。你可以结合下面的 map扩容示意图来理解这个过程，这会让你理解得更深刻一些：</p><p><img src="/page/2022-05/map5.png" /></p><h3 id="map-与并发">map 与并发</h3><p>接着我们来看一下 map 和并发。从上面的实现原理来看，充当 map描述符角色的 hmap实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说map 实例不是并发写安全的，也不支持并发读写。如果我们对 map实例进行并发读写，程序运行时就会抛出异常。看看下面这个并发读写 map的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doIteration</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        _ = fmt.Sprintf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        m[k] = v + <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>            doIteration(m)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>            doWrite(m)<br>        &#125;<br>    &#125;()<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行这个示例程序，我们会得到下面的执行错误结果： <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fatal <span class="hljs-type">error</span>: concurrent <span class="hljs-keyword">map</span> iteration and <span class="hljs-keyword">map</span> write<br></code></pre></div></td></tr></table></figure></p><p>不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9版本中引入了支持并发写安全的 sync.Map类型，可以用来在并发读写的场景下替换掉map，如果你有这方面的需求，可以查看一下sync.Map 的手册。另外，考虑到 map可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以Go 不允许获取 map 中 value的地址，这个约束是在编译期间就生效的。下面这段代码就展示了 Go编译器识别出获取 map 中 value 地址的语句后，给出的编译错误：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">p := &amp;m[key]  <span class="hljs-comment">// cannot take the address of m[key]</span><br>fmt.Println(p)<br></code></pre></div></td></tr></table></figure> <strong>特别注意：</strong></p><ul><li>不要依赖 map 的元素遍历顺序；</li><li>map 不是线程安全的，不支持并发读写；</li><li>不要尝试获取 map 中元素（value）的地址。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-变量、常量、数据类型</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="变量声明">变量声明</h1><p>在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为变量，变量所绑定的内存区域是要有一个明确的边界的。动态语言（比如Python、Ruby等）的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。而静态编程语言在这方面的“体验略差”。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了“变量声明”。</p><h2 id="go-语言的变量声明方法">Go 语言的变量声明方法</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>这个变量声明分为四个部分：var 是修饰变量声明的关键字；a 为变量名；int为该变量的类型；10 是变量的初值。Go语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型的前面。如果没有显式为变量赋予初值，Go编译器会为变量赋予这个类型的零值。对于整数类型，零值为0；浮点数，零值为0.0；布尔类型，零值为False；字符串类型，零值为""；指针，接口，切片，channel，map和函数类型，零值为nil。</p><p>除了单独声明每个变量外，Go语言还提供了变量声明块（block）的语法形式，可以用一个 var关键字将多个变量声明放在一起，像下面代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a <span class="hljs-type">int</span> = <span class="hljs-number">128</span><br>    b <span class="hljs-type">int8</span> = <span class="hljs-number">6</span><br>    s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>    c <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>    t <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>)<br><br><br><span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br><br><br><span class="hljs-keyword">var</span> (<br>    a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br>    c, d, e <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span><br>) <br></code></pre></div></td></tr></table></figure><h2 id="go语言的语法糖">go语言的语法糖</h2><h3 id="省略类型信息的声明">省略类型信息的声明</h3><p>在通用的变量声明的基础上，Go编译器允许我们省略变量声明中的类型信息，它的标准范式是<code>var varName = initExpression</code>，比如下面就是一个省略了类型信息的变量声明：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-number">13</span><br></code></pre></div></td></tr></table></figure><p>Go编译器会根据右侧变量初值自动推导出变量的类型，并给这个变量赋予初值所对应的默认类型。比如，整型值的默认类型int，浮点值的默认类型为 float64，复数值的默认类型为complex128。其他类型值的默认类型就更好分辨了，在 Go语言中仅有唯一与之对应的类型，比如布尔值的默认类型只能是bool，字符值默认类型只能是 rune，字符串值的默认类型只能是 string等。</p><p>如果我们不接受默认类型，而是要显式地为变量指定类型，除了通用的声明形式，我们还可以通过显式类型转型达到我们的目的：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-type">int32</span>(<span class="hljs-number">13</span>)<br></code></pre></div></td></tr></table></figure></p><p>但是这种省略类型信息声明的“语法糖”仅适用于在变量声明的同时显式赋予变量初值的情况，下面这种没有初值的声明形式是不被允许的：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b<br></code></pre></div></td></tr></table></figure></p><p>结合多变量声明，我们可以使用这种变量声明“语法糖”声明多个不同类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b, c = <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="短变量声明">短变量声明</h3><p>Go语言还为我们提供了最简化的变量声明形式：短变量声明。使用短变量声明时，我们甚至可以省去var关键字以及类型信息，它的标准范式是<code>varName := initExpression</code>。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a := <span class="hljs-number">12</span><br>b := <span class="hljs-string">&#x27;A&#x27;</span><br>c := <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><p>短变量声明将通用变量声明中的四个部分省去了两个，但它并没有使用赋值操作符<code>=</code>，而是使用了短变量声明专用的<code>:=</code>。这个原理和上一种省略类型信息的声明语法糖一样，短变量声明中的变量类型也是由Go 编译器自动推导出来的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a, b, c := <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><h1 id="常量声明">常量声明</h1><p>go语言中常量的特点： * 支持无类型常量； * 支持隐式自动转型； *可用于实现枚举。</p><p>Go语言的常量是一种在源码编译期间被创建的语法元素。这是在说这个元素的值可以像变量那样被初始化，但它的初始化表达式必须是在编译期间可以求出值来的。而且，Go常量一旦声明并被初始化后，它的值在整个程序的生命周期内便保持不变。这样，我们在并发设计时就不用考虑常量访问的同步，并且被创建并初始化后的常量还可以作为其他常量的初始表达式的一部分。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi <span class="hljs-type">float64</span> = <span class="hljs-number">3.14159265358979323846</span> <span class="hljs-comment">// 单行常量声明</span><br><br><span class="hljs-comment">// 以const代码块形式声明常量</span><br><span class="hljs-keyword">const</span> (<br>    size <span class="hljs-type">int64</span> = <span class="hljs-number">4096</span><br>    i, j, s = <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-string">&quot;bar&quot;</span> <span class="hljs-comment">// 单行声明多个常量</span><br>)<br></code></pre></div></td></tr></table></figure><p>Go 语言规范规定，Go 常量的类型只局限于 Go基本数据类型，包括数值类型、字符串类型，以及只有两个取值（true 和false）的布尔类型。</p><h2 id="无类型常量">无类型常量</h2><p>声明方式 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> n = <span class="hljs-number">13</span><br></code></pre></div></td></tr></table></figure></p><p>常量 n 在声明时并没有显式地被赋予类型，在 Go中，这样的常量就被称为无类型常量（UntypedConstant）。不过，无类型常量也不是说就真的没有类型，它也有自己的默认类型，不过它的默认类型是根据它的初值形式来决定的。像上面代码中的常量n 的初值为整数形式，所以它的默认类型为 int。</p><p><strong>Go语言对类型安全是有严格要求的：即便两个类型拥有着相同的底层类型，但它们仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算。</strong></p><p>但是对于无类型常量，以下代码是可以编译通过的 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><br><span class="hljs-keyword">const</span> n = <span class="hljs-number">13</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a myInt = <span class="hljs-number">5</span><br>    fmt.Println(a + n)  <span class="hljs-comment">// 输出：18</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>因为这里存在一个隐式转型的机制</p><h3 id="隐式转型">隐式转型</h3><p>隐式转型说的就是，对于无类型常量参与的表达式求值，Go编译器会根据上下文中的类型信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进行的。但由于转型的对象是一个常量，所以这并不会引发类型安全问题，Go编译器会保证这一转型的安全性。</p><p>不过隐式转型中，无法转化成目标类型会报错误 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> m = <span class="hljs-number">1333333333</span><br><br><span class="hljs-keyword">var</span> k <span class="hljs-type">int8</span> = <span class="hljs-number">1</span><br>j := k + m <span class="hljs-comment">// 编译器报错：constant 1333333333 overflows int8</span><br></code></pre></div></td></tr></table></figure></p><h2 id="实现枚举">实现枚举</h2><p>Go 语言并没有原生提供枚举类型，但是我们可以使用 const代码块定义的常量集合，来实现枚举。</p><h3 id="两个机制">两个机制</h3><p><strong>隐式重复前一个非空表达式</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Strawberry, Grape <br>    Pear, Watermelon <br>)<br></code></pre></div></td></tr></table></figure><p>这个代码里，常量定义的后两行并没有被显式地赋予初始值，所以 Go编译器就为它们自动使用上一行的表达式，也就获得了下面这个等价的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Strawberry, Grape  = <span class="hljs-number">11</span>, <span class="hljs-number">22</span> <span class="hljs-comment">// 使用上一行的初始化表达式</span><br>    Pear, Watermelon  = <span class="hljs-number">11</span>, <span class="hljs-number">22</span> <span class="hljs-comment">// 使用上一行的初始化表达式</span><br>)<br></code></pre></div></td></tr></table></figure><p><strong>iota</strong></p><p>iota 是 Go 语言的一个预定义标识符，它表示的是 const声明块（包括单行声明）中，每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的iota自身也是一个无类型常量，可以像前面我们提到的无类型常量那样，自动参与到不同类型的求值过程中来，不需要我们再对它进行显式转型操作。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/sync/mutex.go </span><br><span class="hljs-keyword">const</span> ( <br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span><br>    mutexWoken<br>    mutexStarving<br>    mutexWaiterShift = <span class="hljs-literal">iota</span><br>    starvationThresholdNs = <span class="hljs-number">1e6</span><br>)<br></code></pre></div></td></tr></table></figure><p>第一行：<code>mutexLocked = 1 &lt;&lt; iota</code> ，iota的值是这行在 const 块中的偏移，因此 iota 的值为 0，我们得到<code>mutexLocked</code> 这个常量的值为 1 &lt;&lt; 0，也就是 1。</p><p>第二行：<code>mutexWorken</code> ，因为这个 const声明块中并没有显式的常量初始化表达式，所以我们根据 const声明块里“隐式重复前一个非空表达式”的机制，这一行就等价于<code>mutexWorken = 1 &lt;&lt; iota</code>。而且，又因为这一行是 const块中的第二行，所以它的偏移量 iota 的值为 1，我们得到<code>mutexWorken</code> 这个常量的值为 1 &lt;&lt; 1，也就是 2。</p><p>第三行：同第二行，只不过这一行的<code>iota=3</code></p><p>第四行：<code>mutexWaiterShift = iota</code> ，这一行为常量<code>mutexWaiterShift</code>做了显式初始化，这样就不用再重复前一行了。由于这一行是第四行，而且作为行偏移值的iota 的值为 3，因此 <code>mutexWaiterShift</code> 的值就为 3。</p><p>第五行：代码中直接用了一个具体值 1e6 给常量<code>starvationThresholdNs</code> 进行了赋值，那么这个常量值就是 1e6本身了。</p><p>iota其他应方式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">10</span> <span class="hljs-comment">// 0, 10 (iota = 0)</span><br>    Strawberry, Grape <span class="hljs-comment">// 1, 11 (iota = 1)</span><br>    Pear, Watermelon  <span class="hljs-comment">// 2, 12 (iota = 2)</span><br>)<br></code></pre></div></td></tr></table></figure><p>如果我们要略过 iota = 0，从 iota = 1 开始正式定义枚举常量</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/syscall/net_js.go</span><br><span class="hljs-keyword">const</span> (<br>    _ = <span class="hljs-literal">iota</span><br>    IPV6_V6ONLY  <span class="hljs-comment">// 1</span><br>    SOMAXCONN    <span class="hljs-comment">// 2</span><br>    SO_ERROR     <span class="hljs-comment">// 3</span><br>)<br></code></pre></div></td></tr></table></figure><p>同理，略过中间值的话</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    _ = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    Pin1<br>    Pin2<br>    Pin3<br>    _<br>    Pin5    <span class="hljs-comment">// 5   </span><br>)<br></code></pre></div></td></tr></table></figure><h1 id="数据类型">数据类型</h1><h2 id="整形">整形</h2><p>Go语言的整型，主要用来表示现实世界中整型数量，比如：人的年龄、班级人数等。它可以分为<strong>平台无关整型</strong>和<strong>平台相关整型</strong>这两种，它们的区别主要就在，这些整数类型在不同CPU 架构或操作系统下面，它们的长度是否是一致的。</p><p><strong>平台无关整形</strong></p><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">长度</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">int8</td><td style="text-align: center;">1</td><td style="text-align: center;">[-128, 127]</td></tr><tr class="even"><td style="text-align: center;">int16</td><td style="text-align: center;">2</td><td style="text-align: center;">[-32768, 32767]</td></tr><tr class="odd"><td style="text-align: center;">int32</td><td style="text-align: center;">4</td><td style="text-align: center;">[-2147483648, 2147483647]</td></tr><tr class="even"><td style="text-align: center;">int64</td><td style="text-align: center;">8</td><td style="text-align: center;">[-9223372036854775808,9223372036854775807]</td></tr><tr class="odd"><td style="text-align: center;">uint8</td><td style="text-align: center;">1</td><td style="text-align: center;">[0, 255]</td></tr><tr class="even"><td style="text-align: center;">uint16</td><td style="text-align: center;">2</td><td style="text-align: center;">[0, 65535]</td></tr><tr class="odd"><td style="text-align: center;">uint32</td><td style="text-align: center;">4</td><td style="text-align: center;">[0, 4294967295]</td></tr><tr class="even"><td style="text-align: center;">uint64</td><td style="text-align: center;">8</td><td style="text-align: center;">[0, 18446744073709551615]</td></tr></tbody></table><p>注: 这些平台无关的整型也可以分成两类：有符号整型（int8 ~int64）和无符号整型（uint8 ~uint64）。两者的本质差别在于最高二进制位（bit位）是否被解释为符号位，这点会影响到无符号整型与有符号整型的取值范围。其取值范围为<spanclass="math inline">\([-2^{8 \times n-1}, 2^{8 \times n - 1}-1]\)</span>和 <span class="math inline">\([0, 2^{8 \times n}-1]\)</span></p><p><strong>平台相关整形</strong></p><table><thead><tr class="header"><th>类型</th><th>说明</th><th>32位长度</th><th>64位长度</th></tr></thead><tbody><tr class="odd"><td>int</td><td>默认有符号整型</td><td>4 字节</td><td>8 字节</td></tr><tr class="even"><td>uint</td><td>默认无符号整型</td><td>4 字节</td><td>8 字节</td></tr><tr class="odd"><td>uintptr</td><td>无符号整型</td><td>大到足以存储任何指针的值</td><td></td></tr></tbody></table><p>在这里我们要特别注意一点，由于这三个类型的长度是平台相关的，所以我们在编写有移植性要求的代码时，千万不要强依赖这些类型的长度。</p><h3 id="整型的溢出问题">整型的溢出问题</h3><p>无论哪种整型，都有它的取值范围，也就是有它可以表示的值边界。如果这个整型因为参与某个运算，导致结果超出了这个整型的值边界，我们就说发生了整型溢出的问题。</p><h3 id="字面值与格式化输出">字面值与格式化输出</h3><p>Go 语言在设计开始，就继承了 C 语言关于数值字面值（NumberLiteral）的语法形式。</p><p>声明 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//最初版本</span><br>a := <span class="hljs-number">53</span>        <span class="hljs-comment">// 十进制</span><br>b := <span class="hljs-number">0700</span>      <span class="hljs-comment">// 八进制，以&quot;0&quot;为前缀</span><br>c1 := <span class="hljs-number">0xaabbcc</span> <span class="hljs-comment">// 十六进制，以&quot;0x&quot;为前缀</span><br>c2 := <span class="hljs-number">0Xddeeff</span> <span class="hljs-comment">// 十六进制，以&quot;0X&quot;为前缀</span><br><br><span class="hljs-comment">//1.13 以后</span><br>d1 := <span class="hljs-number">0</span>b10000001 <span class="hljs-comment">// 二进制，以&quot;0b&quot;为前缀</span><br>d2 := <span class="hljs-number">0</span>B10000001 <span class="hljs-comment">// 二进制，以&quot;0B&quot;为前缀</span><br>e1 := <span class="hljs-number">0</span>o700      <span class="hljs-comment">// 八进制，以&quot;0o&quot;为前缀</span><br>e2 := <span class="hljs-number">0</span>O700      <span class="hljs-comment">// 八进制，以&quot;0O&quot;为前缀</span><br><br><span class="hljs-comment">//增加可读性，可以用下划线分割</span><br>a := <span class="hljs-number">5</span>_3_7   <span class="hljs-comment">// 十进制: 537</span><br>b := <span class="hljs-number">0</span>b_1000_0111  <span class="hljs-comment">// 二进制位表示为10000111 </span><br>c1 := <span class="hljs-number">0</span>_700  <span class="hljs-comment">// 八进制: 0700</span><br>c2 := <span class="hljs-number">0</span>o_700 <span class="hljs-comment">// 八进制: 0700</span><br>d1 := <span class="hljs-number">0</span>x_5c_6d <span class="hljs-comment">// 十六进制：0x5c6d</span><br></code></pre></div></td></tr></table></figure></p><p>输出 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">59</span><br>fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, a) <span class="hljs-comment">//输出二进制：111011</span><br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a) <span class="hljs-comment">//输出十进制：59</span><br>fmt.Printf(<span class="hljs-string">&quot;%o\n&quot;</span>, a) <span class="hljs-comment">//输出八进制：73</span><br>fmt.Printf(<span class="hljs-string">&quot;%O\n&quot;</span>, a) <span class="hljs-comment">//输出八进制(带0o前缀)：0o73</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(小写)：3b</span><br>fmt.Printf(<span class="hljs-string">&quot;%X\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(大写)：3B</span><br></code></pre></div></td></tr></table></figure></p><h2 id="浮点型">浮点型</h2><h3 id="浮点型的二进制表示">浮点型的二进制表示</h3><p>IEEE 754 是 IEEE 制定的二进制浮点数算术标准，它是 20 世纪 80年代以来最广泛使用的浮点数运算标准，被许多 CPU与浮点运算器采用。现存的大部分主流编程语言，包括 Go 语言，都提供了符合IEEE 754 标准的浮点数格式与算术运算。</p><p>IEEE 754 标准规定了四种表示浮点数值的方式：单精度（32位）、双精度（64 位）、扩展单精度（43 比特以上）与扩展双精度（79比特以上，通常以 80位实现）。后两种其实很少使用，我们重点关注前面两个就好了。</p><p>Go 语言提供了 float32 与 float64 两种浮点类型，它们分别对应的就是IEEE 754 中的单精度与双精度浮点数值类型。</p><p><strong>不过，这里要注意，Go 语言中没有提供 float 类型。</strong></p><p>浮点数在内存中的二进制表示（BitRepresentation）要比整型复杂得多，IEEE 754规范给出了在内存中存储和表示一个浮点数的标准形式，见下表</p><table><thead><tr class="header"><th>符号位 S</th><th>阶码 E</th><th>尾数 M</th></tr></thead><tbody><tr class="odd"><td>sign</td><td>exponent</td><td>maintissa</td></tr></tbody></table><p>我们看到浮点数在内存中的二进制表示分三个部分：符号位、阶码（即经过换算的指数），以及尾数。这样表示的一个浮点数，它的值等于：<span class="math display">\[(-1)^S \times 1.M \times 2^{E-offset}\]</span> 其中浮点值的符号由符号位决定：当符号位为 1时，浮点值为负值；当符号位为 0 时，浮点值为正值。公式中 offset被称为阶码偏移值。</p><p>单精度（float32）与双精度（float64）浮点数在阶码和尾数上的不同</p><table><thead><tr class="header"><th>浮点类型</th><th>符号位</th><th>阶码</th><th>阶码偏移值</th><th>尾数</th></tr></thead><tbody><tr class="odd"><td>单精度</td><td>1</td><td>8</td><td>127</td><td>23</td></tr><tr class="even"><td>双精度</td><td>1</td><td>11</td><td>1023</td><td>52</td></tr></tbody></table><p>单精度浮点类型（float32）为符号位分配了 1 个 bit，为阶码分配了 8 个bit，剩下的 23 个 bit分给了尾数。而双精度浮点类型，除了符号位的长度与单精度一样之外，其余两个部分的长度都要远大于单精度浮点型，阶码可用的bit 位数量为 11，尾数则更是拥有了 52 个 bit 位。</p><h3 id="十进制小数转二进制小数">十进制小数转二进制小数</h3><p>以139.8125为例</p><ul><li>步骤一：<ul><li>整数部分 139d → 10001011b；除二取余</li><li>小数部分 0.8125d → 0.1101b；乘二取整</li><li>这样 139.8125d 就转化为 10001011.1101b</li></ul></li><li>步骤二：<ul><li>移动小数点，直到整数部分仅有一个 1，即10001011.1101b →1.00010111101b，小数点向左移了 7 位，这样指数就为 7，尾数为00010111101b。</li></ul></li><li>步骤三：<ul><li>IEEE754规定不能将小数点移动而得到的指数，一直填到阶码部分，指数到阶码还需要一个转换过程。对于float32 的单精度浮点数而言，阶码 = 指数 + 偏移值。偏移值的计算公式为<span class="math inline">\(2^{e-1}-1\)</span>，其中 e 为阶码部分的 bit位数，这里为 8，于是单精度浮点数的阶码偏移值就为 2^(8-1)-1 =127。这样在这个例子中，阶码 = 7 + 127 = 134d = 10000110b。</li></ul></li><li>步骤四：<ul><li><p>将符号位、阶码和尾数填到各自位置，得到最终浮点数的二进制表示。尾数位数不足23 位，可在后面补 0。</p></li><li><table><thead><tr class="header"><th>符号位</th><th>阶码</th><th>尾数</th></tr></thead><tbody><tr class="odd"><td>0</td><td>10000110</td><td>00010111101(000000000000)</td></tr></tbody></table></li></ul></li></ul><p>最终浮点数 139.8125d 的二进制表示就为0b_0_10000110_00010111101_000000000000。</p><p>代码验证：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> f <span class="hljs-type">float32</span> = <span class="hljs-number">139.8125</span><br>    bits := math.Float32bits(f)<br>    fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, bits)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="字面值与格式化输出-1">字面值与格式化输出</h3><p>Go浮点类型字面值大体可分为两类，一类是直白地用十进制表示的浮点值形式。这一类，我们通过字面值就可直接确定它的浮点值，比如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-number">3.1415</span><br><span class="hljs-number">.15</span>  <span class="hljs-comment">// 整数部分如果为0，整数部分可以省略不写</span><br><span class="hljs-number">81.80</span><br><span class="hljs-number">82.</span> <span class="hljs-comment">// 小数部分如果为0，小数点后的0可以省略不写</span><br></code></pre></div></td></tr></table></figure><p>另一类则是科学计数法形式。采用科学计数法表示的浮点字面值，我们需要通过一定的换算才能确定其浮点值。而且在这里，科学计数法形式又分为十进制形式表示的，和十六进制形式表示的两种。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-number">6674.28e-2</span> <span class="hljs-comment">// 6674.28 * 10^(-2) = 66.742800</span><br><span class="hljs-number">.12345E+5</span>  <span class="hljs-comment">// 0.12345 * 10^5 = 12345.000000</span><br><br><span class="hljs-number">0x2</span>.p10  <span class="hljs-comment">// 2.0 * 2^10 = 2048.000000</span><br><span class="hljs-number">0x1</span>.Fp+<span class="hljs-number">0</span> <span class="hljs-comment">// 1.9375 * 2^0 = 1.937500</span><br></code></pre></div></td></tr></table></figure><p>十六进制科学计数法的整数部分、小数部分用的都是十六进制形式，但指数部分依然是十进制形式，并且字面值中的p/P 代表的幂运算的底数为 2。</p><p>浮点型的字面值后，和整型一样，fmt包也提供了针对浮点数的格式化输出。我们最常使用的格式化输出形式是%f。通过 %f，我们可以输出浮点数最直观的原值形式。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">123.45678</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f) <span class="hljs-comment">// 123.456780</span><br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, f) <span class="hljs-comment">// 1.234568e+02</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, f) <span class="hljs-comment">// 0x1.edd3be22e5de1p+06</span><br></code></pre></div></td></tr></table></figure><p>其中 %e 输出的是十进制的科学计数法形式，而 %x输出的则是十六进制的科学计数法形式。</p><h2 id="字符串类型">字符串类型</h2><h3 id="原生支持字符串有什么好处">原生支持字符串有什么好处？</h3><p>这样定义的非原生字符串在使用过程中会有很多问题，比如： *不是原生类型，编译器不会对它进行类型校验，导致类型安全性差；字符串操作时要时刻考虑结尾的’\0’，防止缓冲区溢出；*以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问题；* 获取一个字符串的长度代价较大，通常是 O(n) 时间复杂度； * C语言没有内置对非 ASCII 字符（如中文字符）的支持。</p><h4id="string-类型的数据是不可变的提高了字符串的并发安全性和存储利用率">1.string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</h4><p>Go语言规定，字符串类型的值在它的生命周期内是不可改变的。这就是说，如果我们声明了一个字符串类型的变量，那我们是无法通过这个变量改变它对应的字符串值的，但这并不是说我们不能为一个字符串类型变量进行二次赋值。</p><p>Go这样的“字符串类型数据不可变”的性质给开发人员带来的最大好处，就是我们不用再担心字符串的并发安全问题。这样，Go字符串可以被多个 Goroutine（Go语言的轻量级用户线程，后面我们会详细讲解）共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。另外，也由于字符串的不可变性，针对同一个字符串值，无论它在程序的几个位置被使用，Go编译器只需要为它分配一块存储就好了，大大提高了存储利用率。</p><h4id="没有结尾0而且获取长度的时间复杂度是常数时间消除了获取字符串长度的开销">2.没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</h4><p>Go 语言修正了这个缺陷，Go字符串中没有结尾’\0’，获取字符串长度更不需要结尾’\0’作为结束标志。并且，Go获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，我们都可以快速得到字符串的长度值。</p><h4id="原生支持所见即所得的原始字符串大大降低构造多行字符串时的心智负担">3.原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</h4><p>Go 语言通过一对反引号原生支持构造“所见即所得”的原始字符串（RawString）</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">`         ,_---~~~~~----._</span><br><span class="hljs-string">    _,,_,*^____      _____*g*\&quot;*,--,</span><br><span class="hljs-string">   / __/ /&#x27;     ^.  /      \ ^@q   f</span><br><span class="hljs-string">  [  @f | @))    |  | @))   l  0 _/</span><br><span class="hljs-string">   \/   \~____ / __ \_____/     \</span><br><span class="hljs-string">     |           _l__l_           I</span><br><span class="hljs-string">    &#125;          [______]           I</span><br><span class="hljs-string">    ]            | | |            |</span><br><span class="hljs-string">    ]             ~ ~             |</span><br><span class="hljs-string">    |                            |</span><br><span class="hljs-string">     |                           |`</span><br>fmt.Println(s)<br></code></pre></div></td></tr></table></figure><h4id="对非-ascii-字符提供原生支持消除了源码在不同环境下显示乱码的可能">4.对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</h4><p>Go 语言源文件默认采用的是 Unicode 字符集，Unicode字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非 ASCII字符（包括中文字符）。Go 字符串中的每个字符都是一个 Unicode字符，并且这些 Unicode 字符是以 UTF-8 编码格式存储在内存当中的。</p><h3 id="go-字符串的组成">Go 字符串的组成</h3><p>一种是字节视角，也就是和所有其它支持字符串的主流语言一样，Go语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;the length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i]) <span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>如果要表意，我们就需要从字符串的另外一个视角来看，也就是字符串是由一个可空的字符序列构成。这个时候我们再看下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;the character count in s is&quot;</span>, utf8.RuneCountInString(s)) <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, c) <span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>0x4e2d 0x56fd 0x4eba分别是中国人在unicode中的码点</p><h3 id="go-字符串类型的内部表示">Go 字符串类型的内部表示</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/reflect/value.go</span><br><br><span class="hljs-comment">// StringHeader是一个string的运行时表示</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>string类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。</p><p>[[Pasted image 20220330102747.png]]</p><p>Go 编译器把源码中的 string 类型映射为运行时的一个二元组（Data,Len），真实的字符串值数据就存储在一个被 Data 指向的底层数组中。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dumpBytesArray</span><span class="hljs-params">(arr []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;[&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> arr &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, b)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;]\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span><br>    hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="hljs-comment">// 将string类型变量地址显式转型为reflect.StringHeader</span><br>    fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, hdr.Data) <span class="hljs-comment">// 0x10a30e0</span><br>    p := (*[<span class="hljs-number">5</span>]<span class="hljs-type">byte</span>)(unsafe.Pointer(hdr.Data)) <span class="hljs-comment">// 获取Data字段所指向的数组的指针</span><br>    dumpBytesArray((*p)[:]) <span class="hljs-comment">// [h e l l o ]   // 输出底层数组的内容</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码利用了 unsafe.Pointer 的通用指针转型能力，按照 StringHeader给出的结构内存布局，“顺藤摸瓜”，一步步找到了底层数组的地址，并输出了底层数组内容。</p><p>可以得到这样一个结论，那就是我们直接将 string 类型通过函数 /方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</p><h3 id="go-字符串类型的常见操作">Go 字符串类型的常见操作</h3><h4 id="下标操作">下标操作</h4><p>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作。<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xe4：字符“中” utf-8编码的第一个字节</span><br></code></pre></div></td></tr></table></figure></p><h4 id="字符迭代">字符迭代</h4><p>Go 有两种迭代形式：常规 for 迭代与 for range迭代。你要注意，通过这两种形式的迭代对字符串进行操作得到的结果是不同的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>两种不同方法分别输出的按字节和按字符输出的</p><h4 id="字符串连接">字符串连接</h4><p>字符串内容是不可变的，但这并不妨碍我们基于已有字符串创建新字符串。Go原生支持通过 +/+= 操作符进行字符串连接</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Rob Pike, &quot;</span><br>s = s + <span class="hljs-string">&quot;Robert Griesemer, &quot;</span><br>s += <span class="hljs-string">&quot; Ken Thompson&quot;</span><br><br>fmt.Println(s) <span class="hljs-comment">// Rob Pike, Robert Griesemer, Ken Thompson</span><br></code></pre></div></td></tr></table></figure><p>虽然通过 +/+=进行字符串连接的开发体验是最好的，但连接性能就未必是最快的了。除了这个方法外，Go还提供了 strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作。</p><h4 id="字符串比较">字符串比较</h4><p>Go 字符串类型支持各种比较关系操作符，包括 = =、!=、&gt;=、&lt;=、&gt; 和 &lt;。在字符串的比较上，Go采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// ==</span><br>        s1 := <span class="hljs-string">&quot;世界和平&quot;</span><br>        s2 := <span class="hljs-string">&quot;世界&quot;</span> + <span class="hljs-string">&quot;和平&quot;</span><br>        fmt.Println(s1 == s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// !=</span><br>        s1 = <span class="hljs-string">&quot;Go&quot;</span><br>        s2 = <span class="hljs-string">&quot;C&quot;</span><br>        fmt.Println(s1 != s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &lt; and &lt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;23456&quot;</span><br>        fmt.Println(s1 &lt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &lt;= s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &gt; and &gt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;123&quot;</span><br>        fmt.Println(s1 &gt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &gt;= s2) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="字符串转换">字符串转换</h4><p>Go 支持字符串与字节切片、字符串与 rune切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换就可以了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></div></td></tr></table></figure><p>这样的转型看似简单，但无论是 string 转切片，还是切片转string，这类转型背后也是有着一定开销的。这些开销的根源就在于 string是不可变的，运行时要为转换后的类型分配新内存。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch简单食用笔记</title>
    <link href="/2022-03/Pytorch%E7%AE%80%E5%8D%95%E9%A3%9F%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022-03/Pytorch%E7%AE%80%E5%8D%95%E9%A3%9F%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在学习深度学习的过程中，主要用到的工具为<code>PyTorch</code>，本文主要记录了一些基础的语法功能，以方便更进一步的深度网络的学习设计。</p><h1 id="张量">1.张量</h1><p>在pytorch中主要的计算单元，我的理解一个n阶张量就是一个n维数组，pytorch赋予了更多计算手段，以便于之后的高阶张量的计算。</p><p>在定义上，张量表示由一个数值组成的数组，这个数组可能有多个维度。具有一个轴的张量对应数学上的向量（vector）；具有两个轴的张量对应数学上的矩阵（matrix）；具有两个轴以上的张量没有特殊的数学名称。</p><h2 id="张量的创建">1.1张量的创建</h2><p>pytorch提供了多种多样的张量创建方式</p><ul><li><code>arange(n)</code> 函数类似python原来的range(n)，创建一个张量，其元素是从0到n-1的整数，其形状为(1, n)</li><li><code>zeros((a1, a2, a3, ...))</code>创建一个元素全为0的张量，其形状为(a1, a2, a3, ...)</li><li><code>ones((a1, a2, a3, ...))</code>创建一个元素全为1的张量，其形状为(a1, a2, a3, ...)</li><li><code>rand((a1, a2, a3, ...))</code>创建一个元素随机的张量，取值范围为[0, 1)，其形状为(a1, a2, a3, ...)</li><li><code>randn((a1, a2, a3, ...))</code>创建一个元素满足均值为0，方差为1的正态分布张量，其形状为(a1, a2, a3,...)</li><li><code>normal(mean=n, std=m, size=(a1, a2, a3, ...))</code>创建一个元素满足均值为n，方差为m的正态分布张量，其形状为(a1, a2, a3,...)当<code>mean=0</code>，<code>std=1</code>时，等价与<code>randn()</code></li><li><code>tensor(arr)</code> 通过python的列表类型，创建一个张量</li></ul><h2 id="张量的操作">1.2 张量的操作</h2><p>pytorch中重构了运算符以及提供其他函数，使张量的运算更加方便</p><h3 id="基础运算符">1.2.1 基础运算符</h3><p>对于基础的运算符，张量间的运算方法如下</p><ul><li><code>+</code> 按元素求和</li><li><code>-</code> 按元素求差</li><li><code>*</code> 按元素求积</li><li><code>/</code> 按元素求商</li><li><code>**</code> 按元素求幂</li><li><code>%</code> 按元素求余</li><li><code>exp()</code> 按元素求e的指数</li><li><code>==</code> 按元素判断是否相等</li></ul><h3 id="函数操作">1.2.2 函数操作</h3><ul><li><code>shape</code> 函数返回张量的形状</li><li><code>size()</code> 函数返回张量的形状</li><li><code>reshape(a1, a2, a3, ...)</code>函数返回一个新的张量，其形状为指定的形状，形状为(a1, a2, a3,...)，是进一步的<code>view()</code></li><li><code>sum()</code> 对张量中的所有元素进行求和，会产生一个单元素张量<ul><li><code>sum(axis = n)</code>在张量中，按维度求和，会产生一个张量，阶数低于计算之前的张量</li></ul></li><li><code>numpy()</code> 将张量转化为NumPy张量</li><li><code>item()</code> 将张量转化为python的数字或者python原本的float(x)int(x)也可以将张量转化为python的数字，但是仅限只有一个元素的时候</li><li><code>torch.cat((X, Y), dim = n)</code>按照第n维度，将X和Y连结在一起，需要除了第n维度的其他形状相同</li><li><code>mean()</code> 对张量的所有元素求平均值<ul><li><code>mean(axis = n)</code> 对张量的第n维元素求平均值</li></ul></li></ul><h3 id="广播机制">1.2.3 广播机制</h3><p>当两个张量的形状不同时，可以通过广播机制，将其中一个张量的形状转换成另一个张量的形状，能够广播的前提是参与运算的两个张量的形状在逻辑上可一通过复制扩充达到一致。<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">X = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>Y = torch.tensor([[<span class="hljs-number">4</span>], [<span class="hljs-number">5</span>]])<br>X + Y<br></code></pre></div></td></tr></table></figure> <figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">tensor(<span class="hljs-string">[[5, 6, 7],</span><br><span class="hljs-string">        [6, 7, 8]]</span>)<br></code></pre></div></td></tr></table></figure></p><h3 id="索引和切片">1.2.4 索引和切片</h3><p>torch的索引与python索引机制一致，这里记录一些常用操作</p><ul><li><code>X[-1]</code> 在第一维选择最后一个元素</li><li><code>X[1:3]</code> 在第一维选择下标[1, 3)的连续元素</li><li><code>X[1:3, 2:4]</code>在第一维选择索引[1,3)的元素，在第二维选择索引为[2,4)的元素</li><li><code>X[1, 2, ...]</code> = n 修改张量里具体位置的值</li></ul><h3 id="内存节省方法">1.2.5 内存节省方法</h3><p>如果使用<code>Y=X+Y</code>这种运算方法的话，会导致额外的内存分配，通常使用<code>Y[:]=X+Y</code>或<code>Y+=X</code>来减少内存开销</p><h1 id="层与块">2. 层与块</h1><p>为了实现一些复杂的网络，我们引入了神经网络块的概念。块（block）可以描述单个层、由多个层组成的组件或整个模型本身。使用块进行抽象的一个好处是可以将一些块组合成更大的组件，这一过程通常是递归的，如下图所示<img src="/page/2022-03/161550.png" alt="层与块" /></p><p>从编程的⻆度来看，块由类（class）表示。它的任何子类都必须定义一个将其输入转换为输出的前向传播函数，并且必须存储任何必需的参数。注意，有些块不需要任何参数。最后，为了计算梯度，块必须具有反向传播函数。</p><h2 id="自定义块">2.1 自定义块</h2><h3 id="简单的自定义块">2.1.1 简单的自定义块</h3><p>每个块必须提供的基本功能：</p><ol type="1"><li>将输入数据作为其前向传播函数的参数。</li><li>通过前向传播函数来生成输出。请注意，输出的形状可能与输入的形状不同。</li><li>计算其输出关于输入的梯度，可通过其反向传播函数进行访问。通常这是自动发生的。</li><li>存储和访问前向传播计算所需的参数。</li><li>根据需要初始化模型参数。</li></ol><p>在下面的代码片段中，我们从零开始编写一个块。它包含一个多层感知机，其具有256个隐藏单元的隐藏层和一个10维输出层。注意，下面的MLP类继承了表示块的类。我们的实现<strong>只</strong>需要提供我们自己的构造函数（Python中的__init__函数）和前向传播函数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MLP</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.hidden = nn.Linear(<span class="hljs-number">20</span>, <span class="hljs-number">256</span>)<br>        self.out = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-keyword">return</span> self.out(F.relu(self.hidden(X)))<br></code></pre></div></td></tr></table></figure><p>新建网络和执行<code>forward()</code>方法 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net = MLP()<br>net(X)<br></code></pre></div></td></tr></table></figure></p><h3 id="在向前传播中执行其他计算代码">2.1.2在向前传播中执行其他计算代码</h3><p>在对于向前传播中，pytorch可以做很多操作，来满足各种各样的架构的复杂运算，如下所示代码，它的向前传播进行四步计算：1.全连接层；2.常数参数乘积计算，全元素+1后计算relu；3.全连接层；4.第一范数大于1，全元素/2；5.返回全元素和。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>    X = self.linear(X)<br>    X = self.relu(torch.mm(self.con_weight, X) + <span class="hljs-number">1</span>)<br>    X = self.linear(X)<br>    <span class="hljs-keyword">while</span> X.<span class="hljs-built_in">abs</span>().<span class="hljs-built_in">sum</span>() &gt; <span class="hljs-number">1</span>:<br>        X /= <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> X.<span class="hljs-built_in">sum</span>()<br></code></pre></div></td></tr></table></figure><p>那么我们可以随心所欲的在<code>forward</code>中实现我们复杂的数学计算，（只要数学公式是正确的）</p><h3 id="块与块的嵌套">2.1.3 块与块的嵌套</h3><p>我们可以使用<code>Sequential()</code>来简单连接不同的块，当然，使用一个大的块来进行更复杂网络设计也是可行的<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">chimera = nn.Sequential(NestMLP(), nn.Linear(<span class="hljs-number">16</span>,<span class="hljs-number">20</span>), FixedHiddenMLP())<br></code></pre></div></td></tr></table></figure></p><h3 id="不带参数的自定义层">2.1.4 不带参数的自定义层</h3><p>我们如果想要减去均值，那么可以有如下定义的层，它是一个不包含任何参数的层<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CenteredLayer</span>(nn.Module):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>    <span class="hljs-keyword">return</span> X - X.mean()<br></code></pre></div></td></tr></table></figure></p><h3 id="带参数的自定义层">2.1.5 带参数的自定义层</h3><p>同样，参数我们也可以自己来定义，定义方式如下，我们也可以通过forward来定义向前传播的计算方法<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinear</span>(nn.Module):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_units, units</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>        self.weight = nn.Parameter(torch.randn(in_units, units))<br>        self.bias = nn.Parameter(torch.randn(units,))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>    linear = torch.matmul(X,self.weight.data) + self.bias.data<br>        <span class="hljs-keyword">return</span> F.relu(linear)<br></code></pre></div></td></tr></table></figure></p><h2 id="块的参数管理">2.2 块的参数管理</h2><p>对于块的参数实际上是一个个张量，我只要访问到张量，通过张量的访问方式就能访问到参数。</p><h3 id="参数访问">2.2.1 参数访问</h3><p>当通过<code>Sequential</code>类定义模型时，我们可以通过索引来访问模型的任意层。这就像模型是一个列表一样，每层的参数都在其属性中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(net[<span class="hljs-number">2</span>].state_dict())<br></code></pre></div></td></tr></table></figure><p>注意，每个参数都表示为参数类的一个实例。要对参数执行任何操作，首先我们需要访问底层的数值。有几种方法可以做到这一点。有些比较简单，而另一些则比较通用。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(net[<span class="hljs-number">2</span>].bias))<br><span class="hljs-built_in">print</span>(net[<span class="hljs-number">2</span>].bias)<br><span class="hljs-built_in">print</span>(net[<span class="hljs-number">2</span>].bias.data)<br></code></pre></div></td></tr></table></figure><p>参数是复合的对象，包含值、梯度和额外信息。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net[<span class="hljs-number">2</span>].weight.grad==<span class="hljs-literal">None</span><br></code></pre></div></td></tr></table></figure><p>通过for-each可以方便的遍历所有参数 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(*[(name, param.shape)<span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net[<span class="hljs-number">0</span>].named_parameters()])<br><span class="hljs-built_in">print</span>(*[(name, param.shape)<span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net.named_parameters()])<br></code></pre></div></td></tr></table></figure></p><p>输出： <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">(<span class="hljs-string">&#x27;weight&#x27;</span>, torch.Size([<span class="hljs-number">8</span>,<span class="hljs-number">4</span>])) (<span class="hljs-string">&#x27;bias&#x27;</span>, torch.Size([<span class="hljs-number">8</span>]))<br>(<span class="hljs-string">&#x27;0.weight&#x27;</span>, torch.Size([<span class="hljs-number">8</span>,<span class="hljs-number">4</span>])) (<span class="hljs-string">&#x27;0.bias&#x27;</span>, torch.Size([<span class="hljs-number">8</span>])) (<span class="hljs-string">&#x27;2.weight&#x27;</span>, torch.,Size([<span class="hljs-number">1</span>,<span class="hljs-number">8</span>])) (<span class="hljs-string">&#x27;2.bias&#x27;</span>, torch.Size([<span class="hljs-number">1</span>]))<br></code></pre></div></td></tr></table></figure></p><p>根据结果，我们不难得到一种新的访问方式 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net.state_dict()[<span class="hljs-string">&#x27;2.bias&#x27;</span>].data<br></code></pre></div></td></tr></table></figure></p><p>对于嵌套块的，可以像嵌套列表索引一样访问它们</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">rgnet[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].bias.data<br></code></pre></div></td></tr></table></figure><h3 id="参数初始化">2.2.2 参数初始化</h3><p>通过<code>net.apply(init_func)</code>的方法来初始化参数，如下所示</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_normal</span>(<span class="hljs-params">m</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(m) == nn.Linear:<br> nn.init.normal_(m.weight, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">0.01</span>)<br>        nn.init.zeros_(m.bias)<br>net.apply(init_normal)<br></code></pre></div></td></tr></table></figure><p>其中<code>.normal_()</code>与<code>.zero_()</code>与之前的创建张量的函数有着相同的作用。常用的内置初始化函数有</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">nn.init.normal_(m.weight, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">0.01</span>)<br>nn.init.uniform_(m.weight, -<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>nn.init.constant_(m.weight,<span class="hljs-number">1</span>)<br>nn.init.xavier_uniform_(m.weight)<br>nn.init.zeros_(m.bias)<br></code></pre></div></td></tr></table></figure><p>当然我们随时都可以直接访问每一层的每一个参数，那么我们能够在初始化函数中，写的一些比较复杂的初始化操作。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net[<span class="hljs-number">0</span>].weight.data[:]+=<span class="hljs-number">1</span><br>net[<span class="hljs-number">0</span>].weight.data[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=<span class="hljs-number">42</span><br>net[<span class="hljs-number">0</span>].weight.data[<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h1 id="文件读写">3. 文件读写</h1><p>有时我们希望保存训练的模型，以备将来在各种环境中使用，pytorch也提供了一系列方法用来保存数据。</p><h2 id="加载与保存张量">3.1 加载与保存张量</h2><p>对于单个张量，我们可以直接调用load和save函数分别读写它们。<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.arange(<span class="hljs-number">4</span>)<br>torch.save(x,<span class="hljs-string">&#x27;x-file&#x27;</span>)<br>x2 = torch.load(<span class="hljs-string">&#x27;x-file&#x27;</span>)<br></code></pre></div></td></tr></table></figure></p><p>存储词典，可以用来存储一些权重之类的信息 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">mydict = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: x,<span class="hljs-string">&#x27;y&#x27;</span>: y&#125;<br>torch.save(mydict,<span class="hljs-string">&#x27;mydict&#x27;</span>)<br>mydict2 = torch.load(<span class="hljs-string">&#x27;mydict&#x27;</span>)<br></code></pre></div></td></tr></table></figure></p><h2 id="加载与保存模型参数">3.2 加载与保存模型参数</h2><p>保存单个权重向量（或其他张量）确实有用，但是如果我们想保存整个模型，并在以后加载它们，单独保存每个向量则会变得很麻烦。毕竟，我们可能有数百个参数散布在各处。因此，pytorch提供了内置函数来保存和加载整个网络。需要注意的一个重要细节是，这将保存模型的参数而不是保存整个模型。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net = MLP()<br>torch.save(net.state_dict(),<span class="hljs-string">&#x27;mlp.params&#x27;</span>)<br><br>clone = MLP()<br>clone.load_state_dict(torch.load(<span class="hljs-string">&#x27;mlp.params&#x27;</span>))<br></code></pre></div></td></tr></table></figure><h1 id="gpu">4. GPU</h1><h2 id="获取计算设备">4.1 获取计算设备</h2><p>在pytorch中，CPU和GPU可以用<code>torch.device('cpu')</code>和<code>torch.device('cuda')</code>表示。应该注意的是，cpu设备意味着所有物理CPU和内存，这意味着pytorch的计算将尝试使用所有CPU核心。然而，gpu设备只代表一个卡和相应的显存。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>), torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>), torch.device(<span class="hljs-string">&#x27;cuda:1&#x27;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">(device(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;cpu&#x27;</span>), device(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;cuda&#x27;</span>), device(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;cuda&#x27;</span>, index=<span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure><p>我们还可一获取GPU设备的数量 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">torch.cuda.device_count()<br></code></pre></div></td></tr></table></figure></p><p>我们可以定义这样的函数来快速获取设备信息 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">deftry_gpu(i = <span class="hljs-number">0</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    如果存在，则返回gpu(i)，否则返回cpu()</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> torch.cuda.device_count() &gt;= i+<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> torch.device(<span class="hljs-string">f&#x27;cuda:<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_all_gpus</span>():<span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    返回所有可用的GPU，如果没有GPU，则返回[cpu(),]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    devices = [torch.device(<span class="hljs-string">f&#x27;cuda:<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(torch.cuda.device_count())]<br>    <span class="hljs-keyword">return</span> devices <span class="hljs-keyword">if</span> devices <span class="hljs-keyword">else</span> [torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>)]<br></code></pre></div></td></tr></table></figure></p><h2 id="计算设备的选择">4.2 计算设备的选择</h2><p>对于张量，如果想使用GPU的话，在创建时可以添加参数<code>device=cuda:0</code>，那么将会在第一块GPU上创建这个张量</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">X = torch.ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, device=try_gpu()<br></code></pre></div></td></tr></table></figure><p>也可以通过复制的手段，将向量添加到另一块GPU上</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Z = X.cuda(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>对于模型参数，可以通过<code>model.to(device='cuda:0')</code>来将整个参数放到GPU上</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net = nn.Sequential(nn.Linear(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br>net = net.to(device=try_gpu())<br></code></pre></div></td></tr></table></figure><h3 id="其他注意事项">4.3 其他注意事项</h3><p>深度学习框架要求计算的所有输入数据都在同一设备上，无论是CPU还是GPU。</p><p>不经意地移动数据可能会显著降低性能。一个典型的错误如下：计算GPU上每个小批量的损失，并在命令行中将其报告给用戶（或将其记录在NumPyndarray中）时，将触发全局解释器锁，从而使所有GPU阻塞。最好是为GPU内部的日志分配内存，并且只移动较大的日志。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>深度学习</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2022-03/Hello%20Hexo/"/>
    <url>/2022-03/Hello%20Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hello-hexo">Hello Hexo</h1><p>突发奇想，想要自己搭建一个博客，在网上大多数人都说使用hexo会比较容易搭建，体验了一下雀食不错，所以就简单记录下配置过程，以及相关操作。</p><h2 id="hexo-安装">Hexo 安装</h2><p><ahref="https://hexo.io/zh-cn/index.html">Hexo(https://hexo.io/zh-cn/index.html)</a>的官网上记录了基本的安装与运行方式，这里就不在细说了。</p><h2 id="fluid-主题">fluid 主题</h2><p><a href="https://hexo.fluid-dev.com/docs/">fluid 主题文档</a>文档中也记录相关的配置资料，这个主题整体看起来比较简洁干净，是我比较喜欢的样式。</p><h3 id="主题安装">主题安装</h3><p>在hexo项目的目录下执行指令,来通过node包管理安装主题</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">yarn add --save hexo-theme-fluid<br><span class="hljs-comment"># or</span><br>npm install --save hexo-theme-fluid<br></code></pre></div></td></tr></table></figure><p>然后在<code>_config.yml</code>中将<code>theme: landscape</code> 改为<code>theme: fluid</code>在启动hexo就能看到使用fluid主题的博客页面了。</p><h3 id="主题配置">主题配置</h3><p>这个就跟着文档，按需修改配置好了，我这里开启了Latex数学公式支持，修改了壁纸，其他除了改点博客信息好像也没干什么，就不记录了。</p><h2 id="hexo-操作">Hexo 操作</h2><h3 id="hexo-新建文档">Hexo 新建文档</h3><p>执行指令 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo new post post_name<br></code></pre></div></td></tr></table></figure>这样子可以新建一篇博客，会在<code>source</code>目录下生成一个<code>post_name.md</code>的markdown文件，博客内容就可以写在生成的markdown文件中。</p><h3 id="hexo-页面生成">Hexo 页面生成</h3><p>执行指令 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo generate<br></code></pre></div></td></tr></table></figure>在hexo项目中<code>public</code>目录下会生成编译得到<code>html</code>文件，确定生成的文件展示效果与运行hexo展示一致后(可以用<code>vscode</code>的<code>live server</code>插件来测试一下)，再将其文件部署到有page服务的代码仓库，如<code>github</code>就相当于将网站发布到互联网上了。</p><h3 id="hexo-自动部署">Hexo 自动部署</h3><p>刚才说的将<code>public</code>中的内容部署到<code>github</code>或其他仓库的这一步操作也是可以自动完成的，需要进行一下配置。文档中也有关于一键部署的介绍<ahref="https://hexo.io/docs/one-command-deployment">one-command-deployment</a></p><ol type="1"><li><p>提交本地公钥</p><p>通过指令 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">ssh-keygen -t rsa -C <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></div></td></tr></table></figure>将生成在<code>.ssh</code>目录下的<code>id_rsa.pub</code>文件内容添加到<code>github</code>的<code>SSH keys</code>中,然后执行<figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">ssh -T git@github.com<br></code></pre></div></td></tr></table></figure>如果显示<code>Hi XXXXX! You've successfully authenticated,...</code>则添加成功</p></li><li><p>创建<code>github page</code>仓库,<ahref="https://pages.github.com/">功能介绍</a></p></li><li><p>安装<code>hexo-deployer-git</code>工具 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">yarn add hexo-deployer-git<br></code></pre></div></td></tr></table></figure></p></li><li><p>修改<code>_config.yml</code>的<code>deploy</code>中的内容<figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:xxxx/xxxx.github.io.git</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure>云服务器的仓库也是一样的流程，配置好ssh就能实现指令部署了</p></li><li><p>然后执行<code>hexo deploy</code>就可一键部署内容了。</p></li></ol><h2 id="其他">其他</h2><h3 id="部署清理">部署清理</h3><p>每一次部署博客时，最好清理重新生成后推送，不然可能有一堆乱七八糟的麻烦。<figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></div></td></tr></table></figure></p><h3 id="动态更新">动态更新</h3><p>安装组件<code>hexo-browsersync</code>后执行<code>hexo s</code>，在更新markdown文档时，自动重新生成网页，不需要重启服务。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

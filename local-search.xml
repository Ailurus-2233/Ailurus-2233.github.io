<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络I/O面试题</title>
    <link href="/2022-05/%E7%BD%91%E7%BB%9CI-O%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022-05/%E7%BD%91%E7%BB%9CI-O%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="io到底是什么">I/O到底是什么?</h1><p>I/O 其实就是 input 和 output 的缩写，即输入/输出。</p><p>网络 I/O指的是网卡与内存之间的输入输出。当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。</p><p>总结下：I/O 就是指内存与外部设备之间的交互（数据拷贝）。</p><h1 id="为什么网络-io-会被阻塞">为什么网络 I/O 会被阻塞？</h1><p>详细来看这个问题要从建连和通讯涉及到个各个方法来入手，分别是accept、connect、read、write 。</p><h2 id="服务端操作">服务端操作</h2><h3 id="创建-socket">创建 socket</h3><p>首先服务端需要先创建一个 socket。在 Linux 中一切都是文件，那么创建的socket也是文件，每个文件都有一个整型的文件描述符（fd）来指代这个文件。<code>socket(domain, type, protocol)</code>：* domain：这个参数用于选择通信的协议族，比如选择 IPv4 通信，还是 IPv6通信等等 * type：选择套接字类型，可选字节流套接字、数据报套接字等等。 *protocol：指定使用的协议。</p><h3 id="bind">bind</h3><p>现在我们已经创建了一个 socket，但现在还没有地址指向这个socket。众所周知，服务器应用需要指明 IP和端口，这样客户端才好找上门来要服务，所以此时我们需要指定一个地址和端口来与这个socket 绑定一下。</p><h3 id="listen">listen</h3><p>执行了 socket、bind 之后，此时的 socket 还处于 closed的状态，也就是不对外监听的，然后我们需要调用 listen 方法，让 socket进入被动监听状态，这样的 socket才能够监听到客户端的连接请求。这时会有两个队列来存储连接队列和半连接队列</p><h3 id="accept">accept</h3><p>现在我们已经初始化好监听套接字了，此时会有客户端连上来，然后我们需要处理这些已经完成建连的连接。这时候，我们就需要从已完成连接队列中拿到连接进行处理，这个拿取动作就由accpet 来完成。拿到的已完成连接的 socket 的文件描述符，之后操作这个socket 就可以进行通信了。如果已完成连接队列没有连接可以取，那么调用accept 的线程会<strong>阻塞等待</strong>。</p><h2 id="客户端操作">客户端操作</h2><h3 id="connent">connent</h3><p>客户端也需要创建一个 socket，也就是调用socket()，这里就不赘述了，我们直接开始建连操作。客户端创建完 socket并调用 connect 之后，连接就处于 SYN_SEND 状态，当收到服务端的 SYN+ACK之后，连接就变为 ESTABLISHED 状态，此时就代表三次握手完毕。</p><p>至此有两个阻塞点： * connect：需要阻塞等待三次握手的完成。 *accept：需要等待可用的已完成的连接，如果已完成连接队列为空，则被阻塞。</p><h3 id="readwrite">read、write</h3><p>read为读数据，从服务端来看就是等待客户端的请求，如果客户端不发请求，那么调用read 会处于阻塞等待状态，没有数据可以读，这个应该很好理解。</p><p>write为写数据，一般而言服务端接受客户端的请求之后，会进行一些逻辑处理，然后再把结果返回给客户端，这个写入也可能会被阻塞。</p><p>关于写入阻塞的原因：因为我们用的是 TCP 协议，TCP协议需要保证数据可靠地、有序地传输，并且给予端与端之间的流量控制。所以说发送不是直接发出去，它有个发送缓冲区，我们需要把数据先拷贝到TCP 的发送缓冲区，由 TCP自行控制发送的时间和逻辑，有可能还有重传什么的。如果我们发的过快，导致接收方处理不过来，那么接收方就会通过TCP协议告知：别发了！忙不过来了。发送缓存区是有大小限制的，由于无法发送，还不断调用write 那么缓存区就满了，满了就不然你 write 了，所以 write也会发生阻塞。</p><p><strong>所以为什么网络 I/O 会发生阻塞？</strong></p><p>因为建连和通信涉及到的 accept、connect、read、write这几个方法都可能会发生阻塞。阻塞会占用当前执行的线程，使之不能进行其他操作，并且频繁阻塞唤醒切换上下文也会导致性能的下降。由于阻塞的缘故，起初的解决的方案就是建立多个线程，但是随着互联网的发展，用户激增，连接数也随着激增，需要建立的线程数也随着一起增加，到后来就产生了C10K 问题。</p><p><strong>C10K 问题解决方案：</strong></p><p>优化网络I/O：非阻塞套接字，然后 I/O多路复用、信号驱动I/O、异步I/O</p><h1 id="io模型有哪些">I/O模型有哪些？</h1><p>以 read 调用，即读取网络数据为例子来展开 I/O 模型。</p><h2 id="同步阻塞-io">同步阻塞 I/O</h2><p><img src="/page/2022-05/同步阻塞.png" /></p><p>当用户程序的线程调用 read获取网络数据的时候，首先这个数据得有，也就是网卡得先收到客户端的数据，然后这个数据有了之后需要拷贝到内核中，然后再被拷贝到用户空间内，这整一个过程用户线程都是被阻塞的。</p><p>假设没有客户端发数据过来，那么这个用户线程就会一直阻塞等着，直到有数据。即使有数据，那么两次拷贝的过程也得阻塞等着。</p><p>所以这称为同步阻塞 I/O 模型。</p><p>它的优点很明显，简单。调用 read之后就不管了，直到数据来了且准备好了进行处理即可。</p><p>缺点也很明显，一个线程对应一个连接，一直被霸占着，即使网卡没有数据到来，也同步阻塞等着。</p><h2 id="同步非阻塞-io">同步非阻塞 I/O</h2><p><img src="/page/2022-05/同步非阻塞.png" /></p><p>从图中我们可以很清晰的看到，同步非阻塞I/O 基于同步阻塞I/O进行了优化：</p><p>在没数据的时候可以不再傻傻地阻塞等着，而是直接返回错误，告知暂无准备就绪的数据！</p><p>这里要注意，从内核拷贝到用户空间这一步，用户线程还是会被阻塞的。</p><p>这个模型相比于同步阻塞 I/O 而言比较灵活，比如调用 read如果暂无数据，则线程可以先去干干别的事情，然后再来继续调用 read看看有没有数据。</p><p>但是如果你的线程就是取数据然后处理数据，不干别的逻辑，那这个模型又有点问题了。</p><p>等于你不断地进行系统调用，如果你的服务器需要处理海量的连接，那么就需要有海量的线程不断调用，上下文切换频繁，CPU也会忙死，做无用功而忙死。</p><h2 id="io-多路复用">I/O 多路复用</h2><p><img src="/page/2022-05/多路复用.png" /></p><p>从图上来看，好像和上面的同步非阻塞 I/O差不多啊，其实不太一样，线程模型不一样。</p><p>既然同步非阻塞 I/O 在太多的连接下频繁调用太浪费了，那就招个专员吧。</p><p>这个专员工作就是管理多个连接，帮忙查看连接上是否有数据已准备就绪。</p><p>也就是说，可以只用一个线程查看多个连接是否有数据已准备就绪。</p><p>具体到代码上，这个专员就是 select ，我们可以往 select注册需要被监听的连接，由 select来监控它所管理的连接是否有数据已就绪，如果有则可以通知别的线程来 read读取数据，这个 read 和之前的一样，还是会阻塞用户线程。</p><p>这样一来就可以用少量的线程去监控多条连接，减少了线程的数量，降低了内存的消耗且减少了上下文切换的次数，很舒服。</p><h2 id="信号驱动式io">信号驱动式I/O</h2><p><img src="/page/2022-05/信号驱动式.png" /></p><p>上面的 select虽然不阻塞了，但是他得时刻去查询看看是否有数据已经准备就绪，那是不是可以让内核告诉我们数据到了而不是我们去轮询呢？</p><p>信号驱动 I/O就能实现这个功能，由内核告知数据已准备就绪，然后用户线程再去read（还是会阻塞）。</p><p><strong>听起来是不是比 I/O 多路复用好呀？那为什么好像很少听到信号驱动I/O？为什么市面上用的都是 I/O 多路复用而不是信号驱动?</strong></p><p>因为我们的应用通常用的都是 TCP 协议，而 TCP 协议的 socket可以产生信号事件有七种。也就是说不仅仅只有数据准备就绪才会发信号，其他事件也会发信号，而这个信号又是同一个信号，所以我们的应用程序无从区分到底是什么事件产生的这个信号。所以我们的应用基本上用不了信号驱动I/O，但如果你的应用程序用的是 UDP 协议，那是可以的，因为 UDP没这么多事件。因此，这么一看对我们而言信号驱动 I/O 也不太行。</p><h2 id="异步-io">异步 I/O</h2><p>信号驱动 I/O 虽然对 TCP不太友好，但是这个思路对的：往异步发展，但是它并没有完全异步，因为其后面那段read还是会阻塞用户线程，所以它算是半异步。其实思路很清晰：让内核直接把数据拷贝到用户空间之后再告知用户线程，来实现真正的非阻塞I/O！</p><p><img src="/page/2022-05/异步.png" /></p><p>所以异步 I/O 其实就是用户线程调用 aio_read，然后包括将数据从内核拷贝到用户空间那步，所有操作都由内核完成，当内核操作完毕之后，再调用之前设置的回调，此时用户线程就拿着已经拷贝到用户控件的数据可以继续执行后续操作。</p><p>在整个过程中，用户线程没有任何阻塞点，这才是真正的非阻塞I/O。</p><p><strong>为什么常用的还是I/O多路复用，而不是异步I/O？</strong></p><p>因为 Linux 对异步 I/O的支持不足，你可以认为还未完全实现，所以用不了异步 I/O。像 Tomcat都实现了AIO的实现类，其实像这些组件或者你使用的一些类库看起来支持了AIO(异步I/O)，实际上底层实现是用 epoll 模拟实现的。而 Windows是实现了真正的 AIO，不过我们的服务器一般都是部署在 Linux上的，所以主流还是 I/O 多路复用。</p><h1 id="同步和异步的区别">同步和异步的区别？</h1><p>同步和异步指的是：当前线程是否需要等待方法调用执行完毕。</p><p>比如你调用一个搬运一百块石头的方法：</p><ul><li>同步指的是调用这个方法，你的线程需要等待这一百块石头搬完，然后得到搬完了的结果，接着再继续执行剩下的代码逻辑。</li><li>异步指的是调用这个方法，立马就直接返回，不必等候这一百块石头还未搬完，可以立马执行后面的代码逻辑，然后利用回调或者事件通知的方式得到石头已经搬完的结果。</li></ul><h1 id="阻塞和非阻塞的区别">阻塞和非阻塞的区别？</h1><p>阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。就是当前线程还处于CPU时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出CPU。</p><p>所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出CPU。</p><p>而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。</p><p>至此我们可以得到一个结论：</p><ul><li>同步&amp;异步指：当数据还未处理完成时，代码的逻辑处理方式不同。</li><li>阻塞&amp;非阻塞指：当数据还未处理完成时(未就绪)，线程的状态。</li></ul><p>所以同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。</p><h1id="同步异步阻塞非阻塞的io的区别">同步、异步、阻塞、非阻塞的I/O的区别？</h1><p>前提：程序和硬件之间隔了个操作系统，而为了安全考虑，Linux系统分了：用户态和内核态</p><p>在这个前提下，我们再明确 I/O 操作有两个步骤：</p><ol type="1"><li>发起 I/O 请求</li><li>实际 I/O 读写，即数据从内核缓存拷贝到用户空间</li></ol><p>阻塞 I/O 和非阻塞I/O。按照上文，其实指的就是用户线程是否被阻塞，这里指代的步骤1（发起I/O请求）。</p><ul><li>阻塞 I/O，指用户线程发起 I/O请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），就会阻塞当前线程，让出CPU。</li><li>非阻塞 I/O，指用户线程发起 I/O请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），也不会阻塞当前线程，可以继续执行后续的任务。</li></ul><p>可以发现，这里的阻塞和非阻塞其实是指用户线程是否会被阻塞。</p><p>同步 I/O 和异步 I/O。按照上文，我们可以得知这就是根据 I/O响应方式不同而划分的。</p><ul><li>同步 I/O，指用户线程发起 I/O请求的时候，数据是有的，那么将进行步骤2（实际 I/O读写，即数据从内核缓存拷贝到用户空间），这个过程用户线程是要等待着拷贝完成。</li><li>异步 I/O，指用户线程发起 I/O请求的时候，数据是有的，那么将进行步骤2（实际 I/O读写，即数据从内核缓存拷贝到用户空间），拷贝的过程中不需要用户线程等待，用户线程可以去执行其它逻辑，等内核将数据从内核空间拷贝到用户空间后，用户线程会得到一个“通知”。</li></ul><p>再仔细思考下，在 I/O场景下同步和异步说的其实是内核的实现，因为拷贝的执行者是内核，一种是同步将数据拷贝到用户空间，用户线程是需要等着的。一个是通过异步的方式，用户线程不用等，在拷贝完之后，内核会调用指定的回调函数。</p><h1 id="bionioaio">BIO、NIO、AIO？</h1><p>BIO指的是同步阻塞I/O，在这种模型下只能是来一个连接用一个线程，连接多并发大的话服务器顶不住这么多线程的。</p><p>NIO 指的是同步非阻塞I/O，我们熟知的 IO多路复用就是NIO，适合用在连接多、每次传输较为短的场景。</p><p>AIO指的是异步I/O，调用了之后就不管了，数据来了自动会执行回调方法。异步可以有效的减少线程的等待，减少了用户线程拷贝数据的那段等待，效率更高。</p><h1 id="什么是-channel">什么是 Channel？</h1><p>翻译过来就是通道。</p><p>我们可以往通道里写数据，也可以从通道里读数据，它是双向的，而与之配套的是Buffer，也就是你想要往一个通道里写数据，必须要将数据写到一个 Buffer中，然后写到通道里。</p><p>从通道里读数据，必须将通道的数据先读取到一个 Buffer中，然后再操作。</p><p>在 NIO 中 Channel 有多种类型：</p><ul><li>SocketChannel</li><li>ServerSocketChannel</li><li>DatagramChannel</li><li>FileChannel</li></ul><h2 id="socketchannel">SocketChannel</h2><p>通过 SocketChannel ，我们在可以利用 TCP 协议进行读写网络数据。</p><p>SocketChannel 主要在两个地方出现：</p><ol type="1"><li>客户端，客户端创建一个 SocketChannel 用于连接至远程的服务端。</li><li>服务端，服务端利用 ServerSocketChannel 接收新连接之后，为其创建一个SocketChannel 。</li></ol><p>随后，客户端和服务端就可以通过这两个 SocketChannel相互发送和接收数据。</p><h2 id="serversocketchannel">ServerSocketChannel</h2><p>它的作用就是监听新建连的 TCP 连接，为新进一个连接创建对应的SocketChannel。之后，通过新建的 SocketChannel就可以进行网络数据的读写，与对端交互。</p><p>可以看到它主要是用来接待新连接，这功能主要就是服务端做的，所以叫ServerSocketChannel。</p><p>ServerSocketChannel主要出现在一个地方：服务端。服务端需要绑定一个端口，然后监听新连接的到来，这个活儿就由ServerSocketChannel来干。服务端内常常会利用一个线程，一个死循环，不断地接收新连接的到来。</p><h2 id="datagramchannel">DatagramChannel</h2><p>看到 Datagram 应该就知道是 UDP 协议了，是无连接协议。</p><p>利用 DatagramChannel 可以直接通过 UDP 进行网络数据的读写。</p><h2 id="filechannel">FileChannel</h2><p>文件通道，用来进行文件的数据读写。</p><h1 id="什么是-buffer">什么是 Buffer？</h1><p>Buffer说白了就是内存中可以读写的一块地方，叫缓冲区，用于缓存数据。</p><p><strong>为什么 Channel 必须和 Buffer 搭配使用？</strong></p><p>其实网络数据是面向字节的，但是我们读写的数据往往是多字节的，假设不用Buffer，那我们就得一个字节一个字节的调用读和调用写，想想是不是很麻烦？所以我们搞个Buffer，把数据拢一拢，这样之后的调用才能更好地处理完整的数据，方便异步的处理等等。</p><h1 id="什么是-selector">什么是 Selector？</h1><p>I/O多路复用的核心玩意。一个 Selector 上可以注册多个 Channel，我们从上面得知一个 Channel 就对应了一个连接，因此一个 Selector可以管理多个 Channel 。</p><p>当任意 Channel 发生读写事件的时候，通过<code>Selector.select()</code>就可以捕捉到事件的发生，因此我们利用一个线程，死循环的调用<code>Selector.select()</code>，这样可以利用一个线程管理多个连接，减少了线程数，减少了线程的上下文切换和节省了线程资源。如果长时间处理某个事件，那么注册到Selector 上的其他连接的事件就不会被及时处理，造成客户端阻塞。</p><h1 id="到底什么是-ractor">到底什么是 Ractor？</h1><p>Reactor 是服务端在网络编程时的一个编程模式，主要由一个基于 Selector（底层是 select/poll/epoll）的死循环线程，也称为 Reactor 线程。将 I/O操作抽象成不同的事件，每个事件都配置对应的回调函数，由 Selector监听连接上事件的发生，再进行分发调用相应的回调函数进行事件的处理。</p>]]></content>
    
    
    <categories>
      
      <category>网络I/O</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面试题目</title>
    <link href="/2022-05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <url>/2022-05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="tcp-是用来解决什么问题的-tcp是干什么的-tcp有什么作用">TCP是用来解决什么问题的？/ TCP是干什么的？/ TCP有什么作用？</h1><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，即Transmission ControlProtocol，可以看到是一个传输控制协议，重点就在这个<strong>控制</strong>。</p><p>作用：<strong>在复杂（不可靠）的网络环境中，提供一种可靠、按序的端与端之间的流量控制方案</strong>。</p><h1 id="为什么要-tcpip-层实现控制不行么">为什么要 TCP，IP层实现控制不行么？</h1><p>原题：我们知道网络是分层实现的，网络协议的设计就是为了通信，从链路层到IP层其实就已经可以完成通信了。你看链路层不可或缺毕竟咱们电脑都是通过链路相互连接的，然后IP 充当了地址的功能，所以通过 IP 咱们找到了对方就可以进行通信了。那加个TCP 层干啥？IP 层实现控制不就完事了嘛？</p><p>答案：之所以要提取出一个 TCP 层来实现控制是因为 IP层涉及到的设备更多，一条数据在网络上传输需要经过很多设备，而设备之间需要靠IP 来寻址。 假设 IP层实现了控制，涉及到的设备都需要关心很多事情，整体传输的效率回大打折扣。</p><h1 id="连接到底是什么">连接到底是什么？</h1><p>所谓的连接其实只是双方都维护了一个状态，通过每一次通信来维护状态的变更，使得看起来好像有一条线关联了对方。</p><h1 id="三次握手">三次握手</h1><p>Client ------&gt; Server 内容：Client的初始化同步序列号(SYN)</p><p>Server ------&gt; Client内容：报文到达确认信息（ACK）；Server的初始化同步序列号（SYN）；</p><p>Client ------&gt; Server 内容：报文到达确认信息（ACK）</p><p>一般ACKnumber的值为SYN+数据长度+1，比较这个值就能判断对方是否接收成功</p><h2 id="为什么要握手">为什么要握手</h2><p>主要为了阻止历史的重复连接初始化造成的混乱问题。</p><p>在网络上很有可能有重发的操作，那么通过接收方返回发送方的 SEQ+1，然后由发送方来判断这个连接是否是老连接，如果是老连接那么SEQ+1的值肯定不对，则发送方则返回 RST中止连接，如果SEQ+1的值正确则返回ACK 建连。</p><h2 id="tcp头中的seqnumber的作用">TCP头中的SeqNumber的作用</h2><p>SYN 的全称是 Synchronize SequenceNumbers，这个序号是用来保证之后传输数据的顺序性。</p><h2 id="为什么三次">为什么三次</h2><ol type="1"><li>一次：首先A发送一个(SYN)到B，意思是A要和B建立连接进行通信；<ul><li>A压根都不知道B是不是收到了这个请求。</li></ul></li><li>两次：B收到A要建立连接的请求之后，发送一个确认(SYN+ACK)给A，意思是收到A的消息了，B这里也是通的，表示可以建立连接；<ul><li>如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。</li></ul></li><li>三次：A如果收到了B的确认消息之后，再发出一个确认(ACK)消息，意思是告诉B，这边是通的，然后A和B就可以建立连接相互通信了；<ul><li>这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。</li></ul></li><li>四次：这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。<ul><li>如果第二个报文段B发出的(SYN+ACK)分别发送的话，也是可以理解为四次，但是被优化了，一起发送了。</li></ul></li></ol><h2 id="初始序列号-isn-的取值">初始序列号 ISN 的取值</h2><p>RFC793 中认为 ISN 要和一个假的时钟绑定在一起 ISN 每四微秒加一，当超过2 的 32 次方之后又从 0 开始，要四个半小时左右发生 ISN 回绕。这样的话 ISN变成一个递增值，除此之外，实现中还需要加一些随机值在里面，防止被不法份子猜到ISN。</p><h1id="syn-超时了怎么处理-client-发送-syn-至-server-然后就挂了此时-server-发送-synack-就一直得不到回复怎么办">SYN超时了怎么处理？/ client 发送 SYN 至 server 然后就挂了，此时 server 发送SYN+ACK 就一直得不到回复，怎么办？</h1><p>尝试重新发送请求，但是不能连续快速重试多次，需要等待对方网络恢复，所以应该采用阶梯性重试。</p><p>eg: 在 Linux 中就是默认重试 5次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。</p><h1 id="syn-flood-攻击">SYN Flood 攻击</h1><p>SYN Flood 攻击：SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向server 发 SYN 但就是不回 server，使得 server 的 SYN队列耗尽，无法处理正常的建连请求。</p><p>解决方案：</p><p>开启 tcp_syncookies；调整 tcp_synack_retries 减少重试的次数；设置tcp_max_syn_backlog 增加 SYN 队列数；设置 tcp_abort_on_overflow SYN队列满了直接拒绝连接。</p><p>tcp_syncookies：根据自己的 ip、端口、然后对方的 ip、端口，对方 SYN的序号，时间戳等一波操作生成一个特殊的序号（即cookie）发回去，如果对方是正常的 client 会把这个序号发回来，然后 server根据这个序号建连。</p><h1 id="四次挥手">四次挥手</h1><p>Client -----&gt; Server 内容：FIN Server -----&gt; Client内容：ACK</p><p>Server -----&gt; Client 内容：FIN Client -----&gt; Server内容：ACK</p><h2 id="挥手一定要四次吗">挥手一定要四次吗？</h2><ol type="1"><li>假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给client 那么它就是先回复 ack ，然后继续发送数据。等 server数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的ACK 这种情况下就会有四次挥手。</li><li>那么假设 client 发送 FIN 给 server 的时候 server 也没数据给client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待client 的 ACK，这样不就三次挥手了</li></ol><h2 id="为什么要有-time_wait">为什么要有 TIME_WAIT?</h2><p>断开连接发起方在接受到接受方的 FIN 并回复 ACK 之后并没有直接进入CLOSED 状态，而是进行了一波等待，等待时间为 2MSL。MSL 是 Maximum SegmentLifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是 2 分钟，Linux实际实现是 30s，那么 2MSL 是一分钟。</p><p><strong>那么为什么要等 2MSL 呢？</strong> *就是怕被动关闭方没有收到最后的ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN，此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。 *假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。</p><h2 id="等待-2msl-会产生什么问题">等待 2MSL 会产生什么问题？</h2><p>如果服务器主动关闭大量的连接，那么会出现大量的资源占用，需要等到 2MSL才会释放资源。如果是客户端主动关闭大量的连接，那么在 2MSL里面那些端口都是被占用的，端口只有 65535个，如果端口耗尽了就无法发起送的连接了，不过我觉得这个概率很低，这么多端口你这是要建立多少个连接？</p><h2 id="如何解决-2msl-产生的问题">如何解决 2MSL 产生的问题？</h2><p>快速回收，即不等 2MSL 就回收， Linux 的参数是 tcp_tw_recycle，还有tcp_timestamps 不过默认是打开的。其实上面我们已经分析过为什么需要等2MSL，所以如果等待时间果断就是出现上面说的那些问题。所以不建议开启，而且Linux 4.12 版本后已经咔擦了这个参数了。</p><h1id="超时重传机制是为了解决什么问题">超时重传机制是为了解决什么问题？</h1><p>TCP要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。TCP的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要 5那说明前面四个包你都收到了。</p><p>不过这里要注意，SeqNum 和 ACK都是以字节数为单位的，也就是说假设你收到了1、2、4 但是 3 没有收到你不能ACK 5，如果你回了 5那么发送方就以为你5之前的都收到了。所以只能回复确认最大连续收到包，也就是3。而发送方不清楚 3、4这两个包到底是还没到呢还是已经丢了，于是发送方需要等待，这等待的时间就比较讲究了，这里有挺多算法关于计算等待时间的，不过都是关于RTT（RoundTrip Time）的计算，应该不会深问。</p><h1 id="为什么还需要快速重传机制">为什么还需要快速重传机制？</h1><p>超时重传是按时间来驱动的，如果是网络状况真的不好的情况，超时重传没问题，但是如果网络状况好的时候，只是恰巧丢包了，那等这么长时间就没必要。</p><p>就是发送方如果连续三次收到对方相同的确认号，那么马上重传数据。因为连续收到三次相同ACK 证明当前网络状况是 ok的，那么确认是丢包了，于是立马重发，没必要等这么久。 ## 存在问题</p><p>看起来好像挺完美的，但是发送1、2、3、4这4个包，就 2对方没收到，1、3、4都收到了，然后不管是超时重传还是快速重传反正对方就回ACK 2。这时候要重传 2、3、4 呢还是就 2 呢？</p><h1 id="sack-的引入是为了解决什么问题">SACK的引入是为了解决什么问题？</h1><p>SACK 即 SelectiveAcknowledgment，它的引入就是为了解决发送方不知道该重传哪些数据的问题。SACK就是接收方会回传它已经接受到的数据，这样发送方就知道哪一些数据对方已经收到了，所以就可以选择性的发送丢失的数据。通过ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500我收到了，6000-7000的数据我收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999的那一波数据应该是丢了，于是重传。而且如果数据是多段不连续的， SACK也可以发送，比如 SACK0-500,1000-1500，2000-2500。就表明这几段已经收到了。</p><h2 id="d-sack">D-SACK</h2><p>D-SACK 其实是 SACK 的扩展，它利用 SACK的第一段来描述重复接受的不连续的数据序号，如果第一段描述的范围被 ACK覆盖，说明重复了，比如我都 ACK 到6000了你还给我回 SACK 5000-5500呢？说白了就是从第一段的反馈来和已经接受到的 ACK 比一比，参数是tcp_dsack，Linux 2.4 之后默认开启。</p><p>那知道重复了有什么用呢？1、知道重复了说明对方收到刚才那个包了，所以是回来的ACK 包丢了。 2、是不是包乱序的，先发的包后到？3、是不是自己太着急了，RTO 太小了？4、是不是被数据复制了，抢先一步呢？</p><h1 id="滑动窗口是干什么用的">滑动窗口是干什么用的？</h1><p>因为网络是复杂多变的，有时候就会阻塞住，而有时候又很通畅。所以发送方需要知道接收方的情况，好控制一下发送的速率，不至于蒙着头一个劲儿的发然后接受方都接受不过来。因此TCP就有个叫滑动窗口的东西来做流量控制，也就是接收方告诉发送方我还能接受多少数据，然后发送方就可以根据这个信息来进行数据的发送。</p><h2 id="如果接收方回复的窗口一直是-0-怎么办">如果接收方回复的窗口一直是0 怎么办？</h2><p>TCP 有一个 Zero Window Probe 技术，发送方得知窗口是 0之后，会去探测探测这个接收方到底行不行，也就是发送 ZWP包给接收方。具体看实现了，可以发送多次，然后还有间隔时间，多次之后都不行可以直接RST。</p><h2id="已经有滑动窗口了为什么还要拥塞控制">已经有滑动窗口了为什么还要拥塞控制？</h2><p>前面我已经提到了，加了拥塞控制是因为 TCP不仅仅就管两端之间的情况，还需要知晓一下整体的网络情形，毕竟只有大家都守规矩了道路才会通畅。前面我们提到了重传，如果不管网络整体的情况，肯定就是对方没给ACK，那我就无脑重传。如果此时网络状况很差，所有的连接都这样无脑重传，是不是网络情况就更差了，更加拥堵了？然后越拥堵越重传，一直冲冲冲！然后就GG 了。</p><h1 id="阻塞控制如何实现">阻塞控制如何实现？</h1><p>主要有一下几个步骤： 1. 慢启动 2. 拥塞避免，感觉差不多了减速看看 3.拥塞发生快速重传/恢复</p><p>慢启动，就是初始化 cwnd（Congestion Window）为 1，然后每收到一个 ACK就 cwnd++ 并且每过一个 RTT ，cwnd = 2*cwnd。线性中带着指数，指数中又夹杂着线性增。</p><p>然后到了一个阈值，也就是 ssthresh（slow startthreshold）的时候就进入了拥塞避免阶段。这个阶段是每收到一个 ACK 就 cwnd= cwnd + 1/cwnd并且每一个 RTT 就 cwnd++。可以看到都是线性增。</p><p>然后就是一直增，直到开始丢包的情况发生，前面已经分析到重传有两种，一种是超时重传，一种是快速重传。</p><p>如果发生超时重传的时候，那说明情况有点糟糕，于是直接把 ssthresh置为当前 cwnd 的一半，然后 cwnd 直接变为 1，进入慢启动阶段。</p><p>对于快速重传，也可像超时重传那样处理（TCP Tahoe）；另一种方案：TCPReno如果发生快速重传，说明网络状态还不错，最主要的问题就是确定重传那些包，这个实现是把cwnd = cwnd/2 ，然后把 ssthresh 设置为当前的 cwnd。然后进入快速恢复阶段，将 cwnd = cwnd + 3（因为快速重传有三次），重传DACK 指定的包，如果再收到一个DACK则 cwnd++，如果收到是正常的 ACK那么就将 cwnd 设为 ssthresh 大小，进入拥塞避免阶段。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>恶意代码检测汇报</title>
    <link href="/2022-05/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%AF%86%E5%88%AB%E6%B1%87%E6%8A%A5/"/>
    <url>/2022-05/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E8%AF%86%E5%88%AB%E6%B1%87%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>恶意软件是任何旨在损害计算机，服务器或计算机网络的软件。恶意软件在植入或以某种方式引入目标计算机后会造成损害，并可采取可执行代码，脚本，活动内容和其他软件的形式。该代码除计算机病毒，蠕虫，特洛伊木马，勒索软件，间谍软件，广告软件，恐慌软件外，还包括其他形式的恶意代码。</p><p>一般来说，恶意软件的植入是分时间段的，放在软件的生命周期中来看，有预发布阶段和发布后阶段。内部威胁或者内部人员通常是唯一能够在将软件发布给最终用户之前将恶意软件插入软件的黑客类型。其他黑客人员或者组织在发布后阶段插入恶意软件。</p><p>恶意软件在未明确提示用户或未经用户许可的情况下，在计算机上安装运行，一般具有下述行为的一种或多种：强制安装、浏览器劫持、窃取、修改用户数据、恶意收集用户信息、恶意卸载、恶意捆绑及其他侵犯用户知情权、选择权的恶意行为等。这些行为将严重侵犯用户合法权益，甚至将为用户及他人带来巨大的经济或其他形式的利益损失。所以，研究恶意软件检测技术，不仅仅是学术界的一个研究方向，也是维护网络世界安全的重要责任。</p><h1 id="传统恶意软件检测与分析技术">传统恶意软件检测与分析技术</h1><p>恶意软件检测技术的发展有几十年历史，各种技术及技术组合被用来检测和分类恶意软件。根据是否执行恶意软件代码，这些技术可以被粗略分为静态分析检测技术和动态分析检测技术。</p><h2 id="静态分析检测技术">静态分析检测技术</h2><p>静态分析不需要执行代码，一般利用被分析文件的字节特征对代码进行评判，具体特征包括文件结构信息、程序字符串常量、调用函数等，更深层次的会反汇编二进制文件以得到文件指令等信息。特征检测法属于早期主流的静态分析检测技术，很多传统反病毒产品都是采用此类技术。</p><p><img src="/page/2022-05/传统恶意检测方法.png" /></p><p><strong>优点</strong>：这里的特征为描述文件的简单特征，如字符串、字节序列、文件名等特征；检测速度较快</p><p><strong>缺点</strong>：恶意代码分析需要人为的判断；只能检测已有恶意代码，难以应对未知威胁；特征库往往泛化能力不足，容易受到混淆感染；特征库需要频繁更新；随着特征库更新检测效率会大幅降低；而且对文件是敏感的，如果恶意代码存在被感染的文件中，就可能无法命中。</p><h2 id="动态分析与检测技术">动态分析与检测技术</h2><p>动态分析与检测技术是指在被分析程序在运行的情况下，通过监控记录运行状态和行为，从中抽取动态特征进行检测和分类的方法，沙箱检测法是这种技术中最常见的一种。</p><p>通过诱使程序在一个仿真的系统环境下运行，如果检测该程序存在可疑行为，则判定为恶意程序。具体分析将深入程序运行过程，可能会涉及内存分析、进程和系统服务分析以网络分析，需要对系统调用序列、API调用序列、注册表行为、文件行为、网络行为等进行监控，一旦发现结束反病毒软件进程、修改反病毒软件注册表、卸载其他进程主模块、反查杀行为、查找当前已存在的反病毒进程或者服务、挂全局消息钩子、将自己的文件载体拷贝到系统目录、主动向外界通讯、未经授权自动添加启动项以及启动服务、未经允许获取更高权限、修改浏览器的默认选项等可疑行为，则可能启动沙箱报警规则。</p><p>由于动态分析检测方法根据运行时行为信息对恶意软件进行分析，因此与静态分析检测方法相比，动态分析具有更好的有效性和准确率，同时无需对待分析程序进行解包和反汇编操作。相对的，动态分析也有其缺点和不足，例如对待分析程序缺乏全局认识，通常仅关注程序运行时的小部分行为，依赖对程序行为的跟踪技术，一般需要一定的跟踪时长才能奏效，消耗计算资源较大。</p><p><strong>优点</strong>：具有更好的有效性和准确率；无需进行解包和反汇编操作</p><p><strong>缺点</strong>：需要对软件操作敏感；依赖对程序行为的跟踪技术，一般需要一定的跟踪时长才能奏效，消耗计算资源较大。</p><h2 id="section"></h2>]]></content>
    
    
    <categories>
      
      <category>组会汇报</category>
      
    </categories>
    
    
    <tags>
      
      <tag>恶意代码检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malware Detection by Eating a Whole EXE 文章翻译</title>
    <link href="/2022-05/Malware-Detection-by-Eating-a-Whole-EXE/"/>
    <url>/2022-05/Malware-Detection-by-Eating-a-Whole-EXE/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>恶意软件的检测是网络安全中的重要问题，尤其是随着社会越来越多地依赖于计算系统。恶意软件的单一事件已经会导致数百万美元的损失(Anderson等人2013)。防病毒产品提供了一些针对恶意软件的保护，但对这个问题越来越无效。当前的反病毒技术使用基于签名的方法，其中签名是一组手动制定的规则，旨在识别恶意软件的一小部分。这些签名通常是特定的，即使使用相同的功能，通常也无法识别新的恶意软件。这种方法是不够的，因为大多数环境将拥有以前从未见过的独特二进制文件（Liet al.2017），并且每天都会发现数百万个新的恶意软件样本。多年来，反病毒提供商和行业专家已经认识到签名的局限性(Spafford2014)。开发推广到新恶意软件的技术的需求将使恶意软件检测的任务似乎非常适合机器学习，尽管存在重大挑战。</p><p>要构建恶意软件检测系统，我们必须首先确定要使用的特征集。一种直观的选择是使用通过监视程序执行获得的功能(称为apis，执行的指令，访问的ip地址等)。这被称为动态分析。在直观地吸引人的同时，动态分析在实践中存在许多问题。为了进行动态分析，恶意软件必须在特殊仪器环境中运行，例如定制的虚拟机(VM)，这会带来很高的计算要求。此外，在某些情况下，恶意软件有可能在对其进行分析时进行检测。当恶意软件检测到对其进行分析的尝试时，恶意软件可以改变其行为，从而避免被发现（Raffetseder、Kruegel和 Kirda 2007；Garfinkel 等人 2007；Carpenter、Liston 和 Skoudis2007）。即使当恶意软件不表现出这种行为时，分析环境也可能不反映恶意软件的目标环境，从而在所收集的训练数据与现实环境之间产生差异(Rossow等人2012)。虽然动态分析组件可能是长期解决方案的重要组件，但由于其增加的复杂性，我们此时会避免使用它。</p><p>相反，我们采用静态分析方法，我们从二进制程序中查看无需运行即可获得的信息。特别是，我们查看文件本身的原始字节，并构建一个神经网络来确定恶意。神经网络在从图像（Szegedyet al.2015）、信号（Graves、Mohamed和Hinton 2013）和文本（Zhang和LeCun2015）问题的原始输入中学习特征方面表现出色。在恶意软件领域复制这种成功可能有助于简化用于检测恶意软件的工具并提高准确性。由于恶意软件可能会利用错误并忽略格式规范，因此解析恶意文件并使用需要域知识的功能可能需要大量而非平凡的工作。由于恶意软件是由真正的实时对手编写的，因此此类代码还需要维护和改进以适应恶意软件作者不断变化的行为。</p><p>由于我们希望从原始字节输入中学习一个系统，从中构建更高级别的表示，我们选择使用基于神经网络的方法。但是，该领域存在许多其他任务中没有遇到的挑战和差异。从机器学习的角度来看，这些挑战使恶意软件检测的研究本质上变得有趣且相关，而不仅仅是将这些技术引入新的领域。对于MicrosoftWindows可移植可执行（PE）恶意软件，这些挑战包括但不限于：</p><ol type="1"><li>恶意软件中的字节可以具有多种形式的信息。这意味着任何特定字节的含义是上下文相关的，并且可以是编码人类可读文本(例如，来自导入表的函数名称) 、二进制代码、诸如图像的任意对象(来自二进制的资源/数据部分) 等等。</li><li>二进制文件的内容表现出多种类型的空间相关性。函数中的代码指令在空间上是内在相关的，但是这种相关性与函数调用和跳转命令具有不连续性。此外，如果正确地校正了地址，则可以任意地重新排列功能级别的内容。</li><li>将每个字节视为序列中的一个单元，我们正在处理200万时间步长顺序的序列分类问题。据我们所知，这远远超过了以前任何基于神经网络的序列分类器的输入长度。</li><li>随着时间的推移，我们的问题有多个层次的概念漂移。开发人员使用的应用程序、构建工具和库自然会得到更新，替代品也会受到青睐。仅此一项就会导致概念漂移。但是恶意软件是由现实生活中的对手编写的，并且经常被故意调整以避免被发现。</li></ol><p>我们在这项工作中的贡献是开发了第一个网络体系结构，该体系结构可以成功处理超过200万个步骤的原始字节序列。其他人已经尝试了该任务，但未能超越更简单的基线或成功处理整个文件(Anderson2017)，部分原因是为信号和图像处理开发的技术并不总是转移到该新域。我们确定了让网络从原始字节中检测恶意软件所涉及的挑战，以及成功训练此类模型的初始方法。我们表明，与以前的无领域知识恶意软件检测方法相比，该模型学习了更广泛的信息类型。我们的工作还突出了批量规范化的失败案例，这最初导致我们的模型无法学习。</p><h1 id="相关工作">相关工作</h1><p>过去的工作有两个主要主题：神经网络在更长序列中的应用，以及神经网络在恶意软件检测中的应用。循环神经网络(rnn)的使用在历史上在涉及序列的任何工作中都很普遍，但是原始字节的处理远远超过了先前工作中尝试的数量级。对于恶意软件检测，所有这些以前的应用程序都使用大量的领域知识进行特征提取。相比之下，我们的目标是尽量减少此类领域知识的使用，并探索在不指定任何此类信息的情况下可以解决多少问题。</p><h2 id="适用于长序列的神经网络">适用于长序列的神经网络</h2><p>在这项工作中探索的层序分类规模方面，几乎没有做过什么工作。就纯序列长度而言，最接近的是WaveNet (Oord et al.2016)。WaveNet试图通过忽略先前的特征工程，而不是使用音频的原始字节作为输入特征和目标，来提高生成音频的最新水平。这导致音频每秒16,000时间步长的序列问题。通过使用扩张的卷积(Yu和Koltun 2016) 并通过训练非常深的体系结构获得了此任务的广泛接受场(4,800步骤)。最终，与我们的恶意软件检测问题相比，他们的工作在序列长度上仍然是两个数量级。</p><p>使用扩张卷积来处理序列长度已经成为一种普遍趋势，例如在用于机器翻译的ByteNet模型中(Kalchbrenner等人2016)。虽然翻译会产生相对较长的序列，但它们的序列长度比WaveNet的音频生成要小。虽然我们在这项工作中确实探索了扩张卷积，但我们没有发现它们在我们的问题上比标准卷积表现得更好或更差。我们怀疑这是由于二进制文件中局部性的不同性质，对于空间上一致的域(例如图像分类)，膨胀的 “孔”中的值更容易假设或插值，但对于二进制内容却没有明显插值。</p><p>我们注意到使用长序列时的另一种趋势:使用以不同频率运行的RNN。Mehri等人 (2017)使用这样的体系结构进行音频分类，但是利用任务的生成性来训练仅512时间步长的子序列。其他使用在多个频率上运行的RNN 的工作类似地处理了不超过数千个时间步长的序列（Koutnik 等人2014；Neil、Pfeiffer 和 Liu 2016）。</p><p>除了在处理我们面临的异常长的序列时遇到困难之外，我们还必须应对缺乏信息流的问题。当对二进制进行良性/恶意分类时，我们仅获得一个错误信号，该信号必须用于通知有关所有200万时间步骤的决策。相比之下，神经翻译模型和自回归模型（如WaveNet）试图预测的不是整体分类，而是下一个单词或字节。这为他们在每个时间步提供了频繁的标签信息，从而在输入大小和传播错误的标签之间形成了接近1:1的映射。这种频繁的梯度信息不适用于我们的问题，甚至在考虑序列长度之前就增加了学习挑战。</p><h2 id="用于恶意软件检测的神经网络">用于恶意软件检测的神经网络</h2><p>到目前为止，在将神经网络应用于恶意软件检测方面几乎没有什么工作，而且我们知道目前没有任何工作试图从整个二进制文件的原始字节中做到这一点。最近已经证明，<strong>当从每个文件(Raff，Sylvester和Nicholas 2017)的PE头仅300字节训练时，全连接和循环网络能够学习恶意软件识别问题</strong>。基于获得的积极结果，当前的工作通过在整个数百万字节长的可执行文件上训练网络来扩展这些结果，并遇到了广泛的潜在字节内容。</p><p>Saxe和Berlin (2015)的工作在特征级别上与我们的工作最接近，因为它使用了特征的字节熵值直方图。除了可以通过静态分析获得的ASCII字符串长度，PE导入和其他元数据的直方图之外。这种方法从整个文件中产生一些小级别的信息，但在这个过程中丢弃了有关二进制文件实际内容的大部分信息，因为它创建了一个固定长度的特征向量，用作网络的输入。</p><p>在将深度学习应用于恶意软件检测方面的最新工作使用了通过动态分析提取的功能，其中二进制文件在虚拟化环境中运行以获取有关其执行的信息。Kolosnjaji等人。（2016）解决了恶意软件家族分类的相关问题（即，特定恶意文件属于哪个家族？）使用卷积的组合，然后使用LSTM 来处理在动态分析下生成的恶意软件文件的 API调用序列。这是在选择只跟踪60个内核API调用之后。</p><p>Huang 和 Stokes (2016) 将 API调用手动特征工程为114个更高级别的概念，并将这些API事件与原始函数调用的输入参数以及三元组相结合。他们不仅仅是预测恶意，而是使用相同的模型(即两个任务之间共享的权重)进行恶意软件检测和家族分类。这种方法提高了模型在两个任务上的性能，并且将与我们在这项工作中的设计兼容。</p><p>这些先前在恶意软件检测中的工作倾向于使用重要的手动功能工程，这需要重要的(如果不是罕见的话)领域专业知识水平。那些使用动态分析的人通常依靠复杂的非公共仿真环境来减轻动态分析的挑战，这大大增加了重现工作的工作量。我们提出的方法消除了这种特定于领域知识的代码和特征处理，减少了专门代码的数量，减少了复制和扩展的障碍。</p><p>我们注意到以前在恶意软件检测方面的许多工作的一个不幸方面，包括我们自己的一些工作，即由于各种原因，使用了公众无法获得的数据。正如我们将在第3章中讨论的那样，公众容易获得的数据通常质量不足以在实践中使用。这也意味着我们无法有意义地比较各个作品的准确性数字，因为不同的数据集与不同的标签程序一起使用。</p><h1 id="训练数据集">训练数据集</h1><p>对于这项工作，我们使用与<strong>Raff等人 (2016)相同的训练和测试数据</strong>。具体来说，我们使用B组培训数据和A&amp;B组测试数据。B组数据由反病毒行业合作伙伴提供，其中良性程序和恶意程序都代表真实计算机上看到的文件。B组训练集由在良性和恶意类之间平均分配的400,000文件组成。测试集有77,349文件，其中40,000是恶意的，其余是良性的。</p><p>A组数据的收集方式与恶意软件识别文献（Schultz et al.2001；Kolter andMaloof2006）中的大多数工作相同，该文献可供公众使用。良性数据（或“goodware”）来自微软Windows的干净安装，以及一些常用安装的应用程序（如Firefox、Flash等），恶意软件来自VirusShare语料库（Roberts2011）。A组测试集包含43967个恶意测试文件和21854个良性测试文件。</p><p>研究发现，对A组数据的培训会导致严重的过度拟合（Raff等人，2016年），学习识别“来自微软”而不是“良性”，这不会推广到新数据。也就是说，在a组上训练的模型不会推广到B组，但是在B组上训练的模型会推广到A组。因此，我们仅使用B组训练数据进行实验，并在两组上进行测试。以这种方式进行测试使我们能够更好地量化泛化能力，因为数据来自不同的来源。这样可以最大程度地减少共享偏差，并为我们提供了预期准确性的潜在上限和下限。</p><p>我们使用两组的测试集，因为这使我们能够更好地判断模型的泛化能力。B组的测试性能很重要，因为它应该代表野外数据，但由于 B组数据的收集方式，可能存在共同的偏见。对以不同方式收集的 A组数据进行测试是一种更强的泛化测试，因为该数据与 B组的常见偏差较少。因此，我们认为A组的测试性能比B组更有趣。我们还希望我们的模型在两个测试集上具有相似的性能，这将表明所学习的功能非常有用。</p><p>此外，与作者和原始公司接触，我们获得了更大的2,011,786二进制文件的培训语料库，1,000,020良性和1,011,766恶意。我们使用这个更大的数据集来表明，随着训练数据的增加，我们新的MalConv体系结构不断改进，而字节n-gram方法在性能方面似乎已经趋于稳定。</p><h1 id="模型架构">模型架构</h1><p>在设计我们的模型时，需要三个特性：1) 能够很好地随序列长度扩展，2)在检查整个文件时考虑本地和全局上下文的能力，以及 3)帮助分析标记的恶意软件的解释能力。这个模型的框图，我们称之为 MalConv，在1 中给出，更详细的图表在补充材料中。</p><p>可执行文件的大量位置变化影响了我们在可执行文件中的位置选择。在较高的级别上，PE二进制文件的内容几乎可以任意顺序重新排列。唯一的固定常量是MS-DOS 标头，它以指向 PE-Header开头的指针结束。然后，PE标头可以位于任何位置，并且它的一部分可以位于整个文件中。PE头本身包含指向二进制文件所有其他内容（代码、资源等）的指针。这允许在不改变含义的情况下对字节内容进行宏重组。类似地，即使在二进制代码的代码部分中，只要正确调整代码中使用的集合的地址，函数的定义也可以重新排序。这是可能发生的另一个空间重组水平。这种宏观级别的重新排序代表了二进制文件中许多类型的空间属性之一，但我们认为它是最重要的解决方案。功能级别的空间不连续性仍然很困难，但对于模型学习来说并非不可克服。可能会遗漏大范围的相关性；我们希望在未来的工作中获取这些信息。</p><p>为了最好地捕获这种高级位置不变性，我们选择使用卷积网络体系结构。在进入全连接层之前，将卷积激活与max-pooling相结合，使我们的模型能够产生其激活，而不管检测到的特征的位置如何。而不是对原始字节值执行卷积(即，使用从0到255的字节值的缩放版本)，我们使用嵌入层将每个字节映射到固定长度(而不是学习)的特征向量。我们避免使用原始字节值，因为它暗示了一种解释，即某些字节值本质上比其他字节值“更接近”彼此，我们先验地知道这是假的，因为字节值的含义取决于上下文。与卷积一起训练嵌入甚至可以让我们的浅层网络激活更广泛的输入模式。这也使它在面​​对字节值的微小变化时具有一定程度的鲁棒性。使用字节n-grams的先前工作缺乏这种质量，因为它们依赖于精确的字节匹配(Kolter和Maloof 2006; Raff等人2016)。</p><p>我们注意到，在为如此长的输入序列开发神经网络体系结构时，必须做出许多困难的设计选择。实践中的一个主要限制是第一个卷积层中的GPU内存消耗。无论卷积大小如何，在第一次卷积后存储激活以进行正向传播很容易在反向传播期间导致内存不足错误。我们选择使用大卷积滤波器和步幅来控制这些早期层中激活所使用的记忆。</p><p>试图在如此长的序列上构建深度架构需要我们的数据层之间的积极共享，这导致了不平衡的内存使用。这使得Tensorflow等框架中的模型并行性难以实现。相反，我们选择创建一个浅层架构，该架构具有500字节的大过滤器宽度和积极的500步伐。这使我们能够使用PyTorch(Paszke，Gross和Chintala 2016)以数据并行的方式更好地平衡计算工作量。我们的卷积结构使用Dauphin等人(2016) 之后的门控卷积方法，并带有128滤波器。</p><p><strong>Regularization</strong>跨测试架构的一致结果是过度拟合的倾向。这并不奇怪，因为我们的输入特征空间很大（200万个时间步），我们必须从中学习基于单个损失的良性/恶意分类。特别是，我们注意到从B组训练数据到B组测试数据以及B组训练数据到A组测试数据的推广困难。在开发过程中，我们发现DeCov 正则化 (Cogswell et al. 2016)最有帮助，它会惩罚倒数第二层隐藏状态激活之间的相关性。</p><p>我们工作中的一个重大挑战是发现批处理规范化阻止了我们的模型学习这个问题。批量归一化已成为深度学习文献中的一个常见工具，既能更快地收敛，又能产生正则化效果，通常可提高泛化（Ioffe和Szegedy2015）。这使得我们数据上的批量标准化失败成为一个有趣且独特的结果，我们将在5.3 中讨论。</p><p><img src="/page/2022-05/MalConv.png" /></p><h2 id="关于失败的架构">关于失败的架构</h2><p>针对这个问题测试了大量的替代架构设计，包括多达 13层卷积、使用各种（双向）RNN和不同的注意力模型。提MalConv体系结构在许多候选中表现最好。我们在这里回顾了其他高级替代架构策略，它们未能超越我们更简单的MalConv的原因，以及它们如何与最终设计相关联。其他详细信息可在附录中找到。</p><p>由于上述用于反向传播的大量内存使用，因此可以以减少批处理大小为代价添加更多的层。我们使用多达13层卷积对此进行了测试，发现性能只会下降。其中许多实验尝试了较小的卷积场，因此神经元的总感受野在500 到 1000个时间步长的范围内。这些方法的问题是，除了将训练时间增加到无法预估的程度之外，由于标准方法是在每轮池化之后将卷积滤波器的数量增加一倍以保持每层的状态量大致相等，因此这是不可能的。200万步后的卷积状态太大，无法合理计算。因此，需要快速压缩每层的状态大小，但这最终会抑制学习。在我们的方法中，我们在一次卷积中将大量信息移动到宽的滤波器宽度中，允许我们在不增加内存使用的情况下练习和保留信息。</p><p>另一种设计选择是在一个大卷积中同时处理整个文件。一个吸引人的想法是将输入分解为500到10,000字节的块，并独立处理每个块，因为这将大大降低训练要求。我们测试了这种方法，虽然它达到了95%的合理精度，但通常无法推广到65-80%范围内的新数据获取测试精度。这是因为给定二进制文件的大部分内容可能对恶意决策完全没有意义，在随机数据块上进行训练并假设恶意标签会鼓励模型过度拟合训练数据，并记住内容以产生正确的决策。我们的MalConv模型可以访问整个文件，这使模型能够检测到少数信息特征，而不管位置如何。这对于避免上述各种过度拟合是必要的，并且对于在通常良性程序已将恶意软件注入其中的情况下工作是客观必要的。在这种常见情况下，大部分文件应该正确地指示一个良性程序，而只有一小部分内容是恶意的。</p><p>信息稀疏性问题也是我们选择使用时间最大池而不是平均池的一个因素。除了提供更好的可解释性外，maxpooling还提供了相对于平均池的卓越性能。后者强制要求信息特征应该广泛出现在基础文件中。但是许多特征在文件中只会出现一次，因此当与平均池结合使用时，该特征在二进制文件的一个区域中的高响应将被文件中产生低激活的其余大部分部分冲走。Maxpooling避免了这个问题，同时仍然允许我们解决可变长度问题。</p><p>虽然RNNs是任何序列相关任务的通用工具，但我们发现它们在卷积后应用时降低了测试精度，方法是将每次卷积后的输出分解为多个固定大小的块(最后一个块包含填充)。虽然要采取直观的步骤，但这也将先验引入到模型中，即来自卷积的数据必须在固定频率下定期产生相同的激活模式。这是因为RNN 的输入将 CNN的时间输出重新整形为非时间矩阵乘法，因此要求时间信息出现在一致的位置，其周期等于确定的任何块大小。这是因为RNN 的输入将 CNN的时间输出重新整形为非时间矩阵乘法，因此要求时间信息出现在一致的位置，其周期等于确定的任何块大小。</p><h1 id="结果">结果</h1><p>现在，我们介绍神经网络模型的结果。为了评估其性能和有效性，我们将研究5.1中准确性的标准度量，研究5.2中学习的特征的泛化能力，并解决5.3中的批标准化问题。我们还将花一点时间注意构建此模型所需的计算约束。为了使模型及时收敛，我们必须使用相对较大的批次大小，每批次256个样品。由于该体系结构的极端内存使用，因此无法在单个GPU上执行此操作。我们能够在400k组B组上使用DGX-1的8个gpu上的数据并行性训练该模型，每个时期16.75小时，持续10个时期，并使用所有可用的GPUmemory。在同一系统上对较大的200万进行培训需要一个月。</p><h2 id="恶意软件分类">恶意软件分类</h2><p>在评估我们模型的预测性能时，我们使用平衡准确度 (Brodersen et al.2010)（即准确度加权，以便良性和恶意样本均匀计数）和 AUC (Bradley1997)。我们使用平衡的准确性，以便我们在A组和B组测试集中的结果可直接比较，因为它们具有不同比例的良性和恶意样本。由于需要执行恶意软件分类，AUC是一个特别相关的指标，其中基于优先级结构(Jang，Brumley和Venkataraman 2011)创建了要查看的二进制文件队列。最好让最恶意的文件在队列中排名最高，以便尽早识别和隔离它们。分析师的时间很昂贵，并且表征单个二进制文件可能需要超过10个小时(Mohaisen和Alrawi2013)。高AUC得分对应于大多数恶意软件在最好软件之上的成功排名，使其成为直接适用的评估指标。我们特别注意A组测试集的准确性，因为它与B组训练集的相关性最少。因此，组A上的精度性能是泛化性能的更强度量。在这种情况下，我们还对哪些模型在组A和B之间的性能差异最小感兴趣，这表明模型并未过度适合源分布。</p><p>尽管手头的任务很困难，但我们发现我们的网络往往会在训练语料库仅经过三个时期后迅速收敛。这在某些方面是有益的，因为每个时期的训练时间很重要。我们相信这种快速融合可能部分归因于我们架构的小尺寸，它具有(仅!)134,632可训练参数。精度结果如表1所示。我们的模型在经过正规化和非正规化训练时都能够实现较高的AUC，这表明它们对于恶意软件分类非常有用，有助于对工作队列进行排序。</p><p>查看结果，我们可以看到我们的 MalConv模型在指标和测试集上的性能都是最好的或次优的。它在A组和B组测试集之间的性能差异也最小，表明该模型使用的特征可以很好地概括分布。字节n-gram模型在B组测试集上具有较高的精度和AUC，但该模型在a组和B组性能之间也存在较大差距，表明过拟合(Raff等人2016)。字节n-gram模型对于输入中的单字节变化也很脆弱，这将导致特征从模型的考虑中有效地“消失”。当我们认为恶意软件是由能够影响此类更改的对手编写时，这一点很重要，这使得字节n语法成为次优方法。我们的MalConv架构没有同样的问题，需要做更多的工作才能解决。使用在PE-Header上训练的模型很好地推广到a组测试数据，实现了比MalConv略高的精度，但在精度和AUC方面显着降低了B组的性能。这显示了一些健壮性，但在指定的相同功能并没有在域之间平等使用。总体而言，MalConv在所有数据和指标上提供了最令人鼓舞的性能平衡。</p><p>Dekov正则化的应用显着提高了A组和B组测试集的模型精度。这是一个有点不寻常的属性，因为看来dekov的主要影响是改善决策阈值的校准，而不是模型学到的基本概念。这是Raff，Sylvester和Nicholas(2017)为他们的PE头网络指出的一个问题。应用DeCov成功地改善了模型输出概率的校准，将精度提高了4.8点。</p><p>使用更大的200万文件语料库，我们还可以看到MalConv模型提高了性能，将a组和B组的精度提高了5.9和1.3点，将B组的AUC提高了2.4点。我们还复制了原始B 组训练数据使用的字节 n-gram 模型，发现在 A 组测试集上的准确率下降了4.4 分，AUC 下降了 5.0 分。 B组的测试成绩也有所下降，但并不显着。这突出了预测的脆性和用于恶意软件检测的字节n-g的过拟合的倾向(Raff等人2016)。我们的MalConv网络的改进与更多的数据突出了它的优势，它有更大的能力来解决这个问题比以前的领域知识免费的方法。</p><h2 id="人工分析">人工分析</h2><p>使用我们的架构设计，我们能够对模型学到的内容进行适度的手动分析。我们通过调整Zhou 等人使用的方法来做到这一点。(2016)，它为输出中的每个类生成一个类激活图(CAM)。我们在工作中使用全局最大池化层，而不是最初提出的平均池化。这样做会产生一个自然稀疏的激活图，它有助于可解释性，我们称之为稀疏CAM。考虑到我们二进制文件的极端序列长度，这是一个关键的设计选择，因为检查所有200 万字节是不切实际的。 这种稀疏 CAM 设计将返回一个 500字节区域作为每个卷积滤波器的“重要”区域； 由于我们的模型使用 128个过滤器，因此每个二进制文件最多标记 128 个区域。</p><p>这种方法使我们能够为表示学习网络的良性或恶意的区域生成 CAM映射。这种对良性或恶意的偏好由生成的激活图的符号决定。使用PE文件库（Carrera2007），我们可以将大多数二进制文件解析到不同的区域。这些区域对应于二进制格式的不同部分。例如，有一个PE头指定文件的区域。我们期望任何方法都能从该区域学习重要信息，因为它是二进制文件中最结构化和最易于访问的部分。然后，PE头标识二进制文件的哪些部分存储了可执行代码(.text或代码段) 、全局变量 (.data)等。通过确定每个稀疏CAM发生在哪个区域，我们可以了解模型正在学习的内容。我们将结果应用于从A 组测试集中随机选择的 224 个（7 个小批量）二进制文件。这使我们能够最好地评估网络的广义知识，结果如图 3 所示。</p><p>以前在该数据上建立字节n-gram模型的工作发现字节n-gram从PE-Header获得了几乎所有的信息(Raff等人2016)。基于sparseCAM位置，我们发现MalConv正在使用的信息中只有58-61%也来自PE标头，这表明正在使用更多的信息类型。.rsrc部分指示资源目录的使用，其中可以存储文件图标（但也包括可执行代码）等内容。重要的是，我们还看到.text 和 CODE部分激活，这表明我们的模型正在使用一些可执行代码作为功能。同样，在 .data和 .rdata中找到的应用程序数据表明我们的模型可能正在检测二进制文件之间的常见结构模式。</p><p>我们特别注意到，正如我们的网络所了解到的那样，UPX1部分既表示了良性二进制文件，也表示了恶意二进制文件。UPX1部分表示包装的使用，特别是广泛使用的UPX封隔器(Oberhumer、moln á r和Reiser1996)。打包会将大部分二进制文件压缩或加密到一个在运行时提取的归档文件中。这使得简单的静态分析变得困难，恶意软件作者中普遍存在打包现象，从而阻碍恶意软件分析。然而，单独打包并不是一个可靠的恶意软件指标，因为许多良性应用程序也被打包（Guo、Ferrie和 Chiueh2008）。打包恶意可执行文件的盛行导致许多模型学习“打包”和“恶意”之间的直接（但无益的）等价性。我们的结果表明我们的模型可能避免了这种关联。我们希望可解释模型的进一步进展将帮助我们确认这种行为，并确定哪些微小的细节允许模型改变其倾向。</p><h2 id="批量标准化的失败">批量标准化的失败</h2><p>我们的结果似乎与许多其他作品中报告的结果相冲突，因为在 MalConv中添加批量标准化在几个 epoch后始终无法学习。用批标准化训练的模型充其量将获得 60% 的训练和 50%的测试准确度。这种现象发生在所有架构设计变体中。我们对这个结果的惊讶促使我们在PyTorch、Tensorflow、Chainer 和 Theano中使用批量标准化来实现这个和其他架构。 Batch-norm在所有情况下都无法收敛或泛化。</p><p>为了诊断这个问题，我们从批量标准化假设数据应该重新拟合到单位正态分布这一事实开始。然后，我们绘制了网络中各层的预激活函数响应以及高斯分布的响应，如图2所示。该图显示了在图像或二进制可执行文件上训练的网络中早期层响应的核密度估计。在图像数据上训练的网络显示出近似高斯分布的激活（平滑和单峰），而我们网络的激活分布表现出更大的粗糙度。由于批量归一化假设要归一化的数据是正态分布的，这可能是它在我们的应用程序中无效的原因。我们建议任何对新问题进行批标准化的应用都会产生类似的可视化，作为诊断收敛问题的方法。</p><p>我们假设批处理规范在我们的模型中的无效性是二进制可执行文件训练的产物。大多数当代深度学习研究，包括批量归一化，都是在图像和信号处理领域完成的，自然语言紧随其后。在所有这些领域中，数据的性质相对一致。相比之下，我们的二进制数据呈现了字节值的新的多模态特性。.根据位置的不同，相同的字节值可能具有截然不同的含义，范围从ASCII文本、代码、结构。我们的假设是，这种多模态特性会产生多种激活模式，这违反了batchnormalization的主要假设，导致性能下降。</p><p>我们使用仅500到10,000字节的二进制随机块训练的模型的测试支持此假设。当在这样的随机子区域上训练时，大多数字节在呈现时将具有单个模态，因此呈现更平滑的单峰激活模式。这是唯一的情况，批处理范数能够达到高于我们的数据60%的高训练精度，但仍然没有推广到测试数据 (仅获得50%的随机猜测精度)。从而呈现更平滑的单峰激活模式。这是唯一的情况，批处理范数能够达到高于我们的数据60%的高训练精度，但仍然没有推广到测试数据 (仅获得50% 的随机猜测精度)。</p><h1 id="总结">总结</h1><p>在这项工作中，我们描述了神经网络在整个可执行文件的原始字节上的使用。此解决方案避免了更常见的字节n-gram方法的许多问题，例如脆性特征和过度关注PE标头作为重要信息。尽管学习前所未有的序列问题面临挑战，但它在两个测试集中实现了一致的泛化。</p><p>在更广泛的机器学习背景下，我们已经确定了许多独特的学习挑战，并讨论了解决极长序列分类的技术。我们的工作已将神经网络的应用扩展到图像、语音等领域之外的领域，并扩展到具有更复杂的空间相关行为的领域。在这样做的过程中，我们发现了非常常用的批量标准化的潜在缺陷，并提出了一种检查该技术是否合适的方法（预激活函数响应的正态性测试）。</p><p>在未来的工作中，我们希望进一步开发适用于该领域的架构，进一步探索批量归一化问题，并确定哪些类型的现有归一化或权重初始化方案适用于这种多模态响应。还必须对可以减少该问题的内存密集型性质的方法进行批判性思考，以及哪些类型的架构设计可以让我们更好地捕获二进制中表示的多种信息模式。对程序进行字节级理解的一般方法将有许多超出恶意软件分类的应用，例如静态性能预测和自动代码生成。</p>]]></content>
    
    
    <categories>
      
      <category>Malware Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文翻译</tag>
      
      <tag>恶意代码检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础Web开发-数据库操作</title>
    <link href="/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%914/"/>
    <url>/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%914/</url>
    
    <content type="html"><![CDATA[<h1 id="sql-基础操作">SQL 基础操作</h1><p>SQL(结构化查询语言)，主要两种操作一个是针对表格的操作，一个是针对数据的操作；</p><p>表格操作: - 新建表格: create - 删除表格: drop</p><p>数据操作: - 增: insert - 查: select - 改: update - 删: delete</p><h1 id="go-sql">Go + SQL</h1><p>Go中有这样的一个包<code>database/sql</code>，这是实现数据库链接的通用接口，我们还需要针对不同数据库导入不同的驱动包，例如<code>sqlite</code>需要导入<code>github.com/mattn/go-sqlite3</code>，<code>mysql</code>需要导入<code>github.com/go-sql-driver/mysql</code>这个包，等等。</p><h2 id="项目中使用-以sqlite为例">项目中使用 以sqlite为例</h2><h3 id="连接数据库">连接数据库</h3><p>在项目的主文件中 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 声明数据库变量</span><br><span class="hljs-keyword">var</span> db *sql.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 连接数据库</span><br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    db, err = sql.Open(<span class="hljs-string">&quot;sqlite3&quot;</span>, <span class="hljs-string">&quot;./demo.db&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> db.Close()<br>    <span class="hljs-comment">// ... 其他业务逻辑</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="执行sql语句">执行SQL语句</h3><p><strong>db.Exec(sql)</strong> 一般使用这个语句来执行增删改的操作<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">sql := <span class="hljs-string">`</span><br><span class="hljs-string">    //sql query</span><br><span class="hljs-string">`</span><br>_, err = db.Exec(sql)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%q: %s&quot;</span>, err, sql)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p><strong>db.Query("select query")</strong>这个方法会返回一个rows对象，一般会使用这个函数来执行查询操作。<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">rows, err := db.Query(<span class="hljs-string">&quot;select query where id = ?&quot;</span>, id)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> rows.Close()<br><br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>    <span class="hljs-keyword">var</span> id, title <span class="hljs-type">string</span><br>    <span class="hljs-keyword">if</span> err := rows.Scan(&amp;id, &amp;title); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    fmt.Println(id, title)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>与之类似的还有 <code>db.QueryRow()</code>这个方法只返回一个<code>row</code>对象，可以直接使用<code>scan()</code>来绑定数据。</p><h1 id="orm-对象-关系-映射">ORM 对象-关系 映射</h1><p>其实SQL语句相对于是一个比较固定的写法，如果能够将结构体和数据库中表一一对应起来，那么就能实现对SQL语句的封装。</p><p><strong>GORM</strong>是一个通过Go实现的ORM框架，在代码中实现需要导入<code>gorm.io/gorm</code>，以及对应数据库的框架<code>gorm.io/driver/sqlite</code>。</p><h2 id="连接数据库-1">连接数据库</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> db *gorm.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>    db, err = gorm.Open(sqlite.Open(<span class="hljs-string">&quot;./demo.db&quot;</span>))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    err = db.AutoMigrate(&amp;Bibliography&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>第一步通过<code>gorm.Open()</code>来建立数据库，传入参数是任意数据库的驱动构造，第二步通过<code>db.AutoMigrate(&amp;Obj&#123;&#125;)</code>，将在数据库查询<code>objs</code>与结构体一致的复数名表，并与之构造映射关系。</p><h2 id="数据库操作">数据库操作</h2><p><strong>查询</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> objs []Obj<br>db.Find(&amp;objs)<br></code></pre></div></td></tr></table></figure><p>这样可以将所有结果保存到接片<code>objs</code>中</p><p><strong>保存</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">db.Save(&amp;newObj)<br></code></pre></div></td></tr></table></figure><p>保存一条新的记录，或者更新已有数据</p><p><strong>创建</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">db.Create(&amp;Obj&#123;...&#125;)<br></code></pre></div></td></tr></table></figure><p><strong>获取一条数据</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">db.First(&amp;obj)<br>db.Where(<span class="hljs-string">&quot;id=?&quot;</span>, id).First(&amp;obj)<br>db.First(&amp;obj, <span class="hljs-string">&quot;id=?&quot;</span>, id)<br></code></pre></div></td></tr></table></figure><p>获取一条数据，在中间加<code>.Where()</code>可以附加查询条件，或者传入更多参数。</p><p><strong>更新</strong> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">db.Model(&amp;obj).Update(<span class="hljs-string">&quot;Info&quot;</span>, <span class="hljs-number">200</span>)<br><br>db.Model(&amp;obj).Updates(Obj&#123;Info: <span class="hljs-number">200</span>, Code: <span class="hljs-string">&quot;F42&quot;</span>&#125;)<br>db.Model(&amp;obj).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Info&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-string">&quot;F42&quot;</span>&#125;)<br></code></pre></div></td></tr></table></figure></p><p>通过<code>db.Model(&amp;obj).Update(key, value)</code>来更新obj中的一个字段，或者使用<code>Updates()</code>来更新多个字段，传入参数可以时一个对象那个，或者一个map类型，他只会更新非零值字段。</p><h2 id="其他注意事项">其他注意事项</h2><ol type="1"><li>结构体中多余字段，需要添加标签`gorm:"-:all"`，来告诉Gorm不需要处理这个字段</li><li>默认表明不一致解决方法 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-params">(Obj)</span></span> TableName() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;targetTableName&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="总结">总结</h1><p>Go语言对数据库操作主要是基于<code>database/sql</code>以及对应数据库驱动这两个包，来执行相关sql的语句(仅限于关系型数据库，其他数据库可以查相关文档)，也可以使用<code>GORM</code>一类的<code>ORM</code>框架，来简化对数据库的操作，但是简化操作的代价就是运行时的额外消耗。</p><p>这里只是简单介绍一下怎么使用，之后会在针对这些看课程中出现的问题，有计划的进行学习，主要还是针对面试和项目实现。</p><h2 id="参考文档">参考文档</h2><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1sv4y1K7Bh">这么萌的Go开发课程（4），真的不进来看一下嘛？[Go+数据库]</a></li><li><a href="http://go-database-sql.org/">Go database/sqltutorial</a></li><li><a href="https://pkg.go.dev/database/sql">database/sql</a></li><li><a href="https://gorm.io/zh_CN/docs/index.html">GORM 指南</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Web</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础Web开发-RESTful API开发</title>
    <link href="/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%913/"/>
    <url>/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%913/</url>
    
    <content type="html"><![CDATA[<h1 id="restful-api">RESTful API</h1><p>API(Application Programming Interface)应用程序接口，简单的来说就是访问服务的地址与访问方式，以上个wiki项目举例通过浏览器访问<code>localhost:8080/view/xxx</code>就是一个服务的地址，我们请求的方式为<code>GET</code>请求，就能获取html文本来交给浏览器渲染。当然也有只请求值的数据型API，至于如何展示则只需要交给前端开发来处理了。本文也是以一个小项目为例，来简单实现RESTfulAPI在Go中的开发过程。</p><h1 id="参考文献管理系统">参考文献管理系统</h1><h2 id="api服务设计">API服务设计</h2><table><colgroup><col style="width: 34%" /><col style="width: 11%" /><col style="width: 12%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th style="text-align: center;">请求说明</th><th style="text-align: center;">请求方式</th><th style="text-align: center;">请求地址</th><th style="text-align: center;">额外参数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">获取所有参考文献</td><td style="text-align: center;">GET</td><td style="text-align: center;">/bibs</td><td style="text-align: center;">?f=gbt(格式化为GB/T 7714格式)</td></tr><tr class="even"><td style="text-align: center;">获取指定id的一篇参考文献</td><td style="text-align: center;">GET</td><td style="text-align: center;">/bibs/:id</td><td style="text-align: center;">?f=gbt(格式化为GB/T 7714格式)</td></tr><tr class="odd"><td style="text-align: center;">添加新的参考文献</td><td style="text-align: center;">POST</td><td style="text-align: center;">/bibs</td><td style="text-align: center;"></td></tr></tbody></table><div class="note note-success">            <p>常用的请求方式 GET 获取资源，POST 新建资源，PUT 更新资源，DELETE删除资源</p>          </div><h2 id="初始化项目">初始化项目</h2><p>同样使用<code>go Module</code>工具初始化项目和管理依赖<figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> bib<br><span class="hljs-built_in">cd</span> bib<br>go mod init bib<br></code></pre></div></td></tr></table></figure></p><h2 id="定义数据结构">定义数据结构</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Bibliography <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">string</span><br>Author    <span class="hljs-type">string</span><br>Title     <span class="hljs-type">string</span><br>Type      <span class="hljs-type">string</span> <span class="hljs-comment">// 文献类型</span><br>Publisher <span class="hljs-type">string</span> <span class="hljs-comment">// 出版社或期刊</span><br>Reference <span class="hljs-type">string</span> <span class="hljs-comment">// 引用页码</span><br><br>Comment   <span class="hljs-type">string</span> <span class="hljs-comment">// 对于文献的注释</span><br>Formatter <span class="hljs-type">string</span> <span class="hljs-comment">// 格式化的文本</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中Formatter需要由程序生成，用来支持不同场合不同格式的参考文献格式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bibliography)</span></span> Format(formatter <span class="hljs-type">string</span>, idx <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">switch</span> formmatter &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gbt&quot;</span>:<br>        b.Formatter = fmt.Sprintf(<span class="hljs-string">&quot;[%v] %v. %v[%v]. %v:%v.&quot;</span>,<br>            idx, b.Author, b.Title, b.Type, b.Publisher, b.Reference)<br>    <span class="hljs-keyword">default</span>:<br>        b.Formatter = <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里还需要生成一些假的数据，可以使用mock.js来生成一些随机数据，虽然有些不对劲，但是可以先拿来用。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-string">&quot;list|20&quot;</span>:[<br>      &#123;<br>        <span class="hljs-string">&quot;ID&quot;</span>: <span class="hljs-string">&quot;@guid()&quot;</span>,<span class="hljs-comment">//ID</span><br>        <span class="hljs-string">&quot;Author&quot;</span>: <span class="hljs-string">&quot;@cname&quot;</span>,<br>        <span class="hljs-string">&quot;Title&quot;</span>: <span class="hljs-string">&quot;@ctitle()&quot;</span>,<br>        <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;@integer(1,2)&quot;</span>,<br>        <span class="hljs-string">&quot;Publisher&quot;</span>: <span class="hljs-string">&quot;@name() publisher&quot;</span>,<br>        <span class="hljs-string">&quot;Reference&quot;</span>: <span class="hljs-string">&quot;@integer(1, 50), @integer(50, 100)&quot;</span>,<br><br>        <span class="hljs-string">&quot;Comment&quot;</span>: <span class="hljs-string">&quot;@cparagraph()&quot;</span>,<br>        <span class="hljs-string">&quot;Formatter&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>      &#125;<br>    ]<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="get-bibs-服务的实现">Get /bibs 服务的实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBibs</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    log.Println(r.Method, r.URL.String())<br>    formatter := r.URL.Query().Get(<span class="hljs-string">&quot;f&quot;</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bibs); i++ &#123;<br>        bibs[i].Format(formatter, i+<span class="hljs-number">1</span>)<br>    &#125;<br>    j, _ := json.MarshalIndent(bibs, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;      &quot;</span>)<br>    w.Write(j)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取显示参数是通过<code>r.URL.Query().Get(key)</code>的这个方式获取，<code>json.MarshalIndent(bibs, "", "   ")</code>的意思为，根据<code>bibs</code>构建一个Json字符串，另外两个参数是构成Json的缩进的，然后通过<code>w.Write()</code>返回给请求。</p><h2 id="post-bibs-服务的实现">POST /bibs 服务的实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postBib</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    log.Println(r.Method, r.URL.String())<br>    <span class="hljs-keyword">var</span> newBib Bibliography<br>    body, _ := ioutil.ReadAll(r.Body)<br>    <span class="hljs-keyword">if</span> err := json.Unmarshal(body, &amp;newBib); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    bibs = <span class="hljs-built_in">append</span>(bibs, newBib)<br>    j, _ := json.MarshaIndent(newBib, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;      &quot;</span>)<br>    w.Write(j)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里是使用<code>ioutil.ReadAll(r.Body)</code>读取请求中发送的数据，因为请求发送的是一个Json类型的字符串，所以可以通过<code>json.Unmarshal(string, *obj)</code>将Json字符串绑定到或者说解析到一个对象中。</p><h2 id="get-bibsid-服务的实现">Get /bibs/:id 服务的实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBibsByID</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    log.Println(r.Method, r.URL.String(), fmt.Sprintf(<span class="hljs-string">&quot;id=%v&quot;</span>, id))<br>    id := r.URL.Path[<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;/bibs/&quot;</span>):]<br>    formatter := r.URL.Query().Get(<span class="hljs-string">&quot;f&quot;</span>)<br>    <span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bibs &#123;<br>        <span class="hljs-keyword">if</span> b.ID == id &#123;<br>            b.Format(formatter, i+<span class="hljs-number">1</span>)<br>            j, _ := json.MarshalIndent(b, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;      &quot;</span>)<br>            w.Write(j)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>    j, _ := json.MarshalIndent(<br>        <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;bib not found&quot;</span>&#125;, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;      &quot;</span><br>    )<br>    w.Write(j)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个方法多了一个获取子请求的步骤，这里只是简单的截取请求路径获取子请求参数。</p><h2 id="注册handler">注册handler</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/bibs/&quot;</span>, getBibsByID)<br>    http.HandleFunc(<span class="hljs-string">&quot;/bibs&quot;</span>, getBibs)<br>    http.HandleFunc(<span class="hljs-string">&quot;/bibs&quot;</span>, postBib)<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中<code>/bibs/</code>为监听<code>/bibs/xxx</code>这样的请求，<code>/bibs</code>监听的只有这个请求，但是这样写会有一个问题，handleFunc无法区分<code>GET</code>和<code>POST</code>请求，所以还需要写一个区分请求方式的函数。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleBibs</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> r.Method &#123;<br>    <span class="hljs-keyword">case</span> http.MethodGet:<br>        getBibs(w, r)<br>    <span class="hljs-keyword">case</span> http.MethodPost:<br>        postBib(w, r)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结">总结</h2><p>基于以上操作，便可以实现RESTful接口的开发，但是我们发现如果只通过Go标准库来实现逻辑复杂的话，那么代码将看起来会十分复杂冗余；那么这个时候就需要使用类似Java中springboot这类框架的第三方包，来减轻开发时的神智负担。</p><h1 id="gin-包使用方法">Gin 包使用方法</h1><h2 id="导入gin包">导入Gin包</h2><p>在go文件的import中写入 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    ...<br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>    ...<br>)<br></code></pre></div></td></tr></table></figure></p><p>然后执行<code>go mod tidy</code>，这样这个项目就导入Gin这个Web开发框架</p><h2 id="gin的handler函数">Gin的Handler函数</h2><p>Gin中Handler函数只需要传递一个<code>*gin.Context</code>类型的变量，下面是gin中<code>HandlerFunc()</code>的定义，这Context其实就是<code>http.ResponseWriter</code>和<code>http.Request</code>的整合，具体有哪些功能见下文描述。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><br></code></pre></div></td></tr></table></figure><h2 id="重构get-bibs-服务">重构GET /bibs 服务</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBibs</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>formatter, _ := c.GetQuery(<span class="hljs-string">&quot;f&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bibs); i++ &#123;<br>bibs[i].Format(formatter, i+<span class="hljs-number">1</span>)<br>&#125;<br>c.IndentedJSON(http.StatusOK, bibs)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取显示参数的方式直接改为<code>c.GetQuery(key string)</code>，返回数据的方式也是通过<code>c.JSON(status, data)</code>的方式来简单实现的。</p><h2 id="重构post-bibs-服务">重构POST /bibs 服务</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postBib</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> newBib Bibliography<br><span class="hljs-keyword">if</span> err := c.Bind(&amp;newBib); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>bibs = <span class="hljs-built_in">append</span>(bibs, newBib)<br>c.IndentedJSON(http.StatusCreated, bibs)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获取数据的方式，直接使用<code>c.Bind(*)</code>来将请求中的数据绑定到对应的实例中，然后进行进一步的操作。</p><h2 id="重构get-bibsid-服务">重构GET /bibs/:id 服务</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBibsById</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>formatter, _ := c.GetQuery(<span class="hljs-string">&quot;f&quot;</span>)<br><span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bibs &#123;<br><span class="hljs-keyword">if</span> b.ID == id &#123;<br>b.Format(formatter, i+<span class="hljs-number">1</span>)<br>c.IndentedJSON(http.StatusOK, b)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>c.IndentedJSON(http.StatusNotFound, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;not found&quot;</span>&#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里有这样的一个操作<code>c.Param(key)</code>读取到传进来的id，但是这个获取显示参数还不太一样，这个操作需要配合<code>main()</code>中的注册函数来同一实现</p><h2 id="mian-函数结构">mian() 函数结构</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br>router.GET(<span class="hljs-string">&quot;/bibs&quot;</span>, getBibs)<br>router.GET(<span class="hljs-string">&quot;/bibs/:id&quot;</span>, getBibsById)<br>router.POST(<span class="hljs-string">&quot;/bibs&quot;</span>, postBib)<br>router.Run(<span class="hljs-string">&quot;localhost:8080&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里使用<code>gin.Default()</code>来注册一个路由，路由注册请求的<code>GET</code>，<code>POST</code>，...等方法，和之前<code>http.HandleFunc()</code>一致，他能够将请求绑定到指定函数上，这个函数是前面说的Gin包中的<code>HandlerFunc(*Context)</code>实现。</p><p>而且注意这个函数<code>router.GET("/bibs/:id", getBibsById)</code>，这里请求里加了一个<code>:id</code>，意思将子请求作为参数<code>id</code>，传入到函数中，在函数中通过<code>c.Param("id")</code>来获取这个信息。</p><h1 id="总结-1">总结</h1><p>这篇文章简单记录，一个RESTfulAPI服务通过Go语言实现的具体流程与思路，与Java中SpringBoot类似Go中也有诸如Gin等方便API开发的框架，主要思路就是将对应的请求绑定到一个特定的函数上，通过这个函数来实现相应API定义的功能。</p><h2 id="代码">代码</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Bibliography <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">string</span><br>Author    <span class="hljs-type">string</span><br>Title     <span class="hljs-type">string</span><br>Type      <span class="hljs-type">string</span> <span class="hljs-comment">// 文献类型</span><br>Publisher <span class="hljs-type">string</span> <span class="hljs-comment">// 出版社或期刊</span><br>Reference <span class="hljs-type">string</span> <span class="hljs-comment">// 引用页码</span><br><br>Comment   <span class="hljs-type">string</span> <span class="hljs-comment">// 对于文献的注释</span><br>Formatter <span class="hljs-type">string</span> <span class="hljs-comment">// 格式化的文本</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bibliography)</span></span> Format(formatter <span class="hljs-type">string</span>, idx <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">switch</span> formatter &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gbt&quot;</span>:<br>b.Formatter = fmt.Sprintf(<span class="hljs-string">&quot;[%v] %v. %v[%v]. %v:%v.&quot;</span>,<br>idx, b.Author, b.Title, b.Type, b.Publisher, b.Reference)<br><span class="hljs-keyword">default</span>:<br>b.Formatter = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> bibs = []Bibliography&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBibs</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>formatter, _ := c.GetQuery(<span class="hljs-string">&quot;f&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(bibs); i++ &#123;<br>bibs[i].Format(formatter, i+<span class="hljs-number">1</span>)<br>&#125;<br>c.IndentedJSON(http.StatusOK, bibs)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">postBib</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> newBib Bibliography<br><span class="hljs-keyword">if</span> err := c.Bind(&amp;newBib); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>bibs = <span class="hljs-built_in">append</span>(bibs, newBib)<br>c.IndentedJSON(http.StatusCreated, bibs)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getBibsById</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>formatter, _ := c.GetQuery(<span class="hljs-string">&quot;f&quot;</span>)<br><span class="hljs-keyword">for</span> i, b := <span class="hljs-keyword">range</span> bibs &#123;<br><span class="hljs-keyword">if</span> b.ID == id &#123;<br>b.Format(formatter, i+<span class="hljs-number">1</span>)<br>c.IndentedJSON(http.StatusOK, b)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>c.IndentedJSON(http.StatusNotFound, gin.H&#123;<span class="hljs-string">&quot;error&quot;</span>: <span class="hljs-string">&quot;not found&quot;</span>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br>router.GET(<span class="hljs-string">&quot;/bibs&quot;</span>, getBibs)<br>router.GET(<span class="hljs-string">&quot;/bibs/:id&quot;</span>, getBibsById)<br>router.POST(<span class="hljs-string">&quot;/bibs&quot;</span>, postBib)<br>router.Run(<span class="hljs-string">&quot;localhost:8080&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以发现，通过Gin来实现请求接口时十分方便简洁的。</p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1WF41137yb">这么萌的Go开发课程（3），真的不进来看一下嘛？[RESTfulAPI 开发]</a></li><li><a href="https://go.dev/doc/tutorial/web-service-gin">Tutorial:Developing a RESTful API with Go and Gin</a></li><li><ahref="https://zh.wikipedia.org/wiki/表现层状态转换">Wiki-表现层状态转换</a></li><li><ahref="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构-阮一峰</a></li><li><ahref="https://github.com/gin-gonic/gin">gin-gonic/gin-github</a></li><li><ahref="https://blog.csdn.net/u012419550/article/details/108437927">Gin入门-CDFMLR-CSDN</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础Web开发-简单Wiki系统开发</title>
    <link href="/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%912/"/>
    <url>/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%912/</url>
    
    <content type="html"><![CDATA[<h1 id="新建项目">新建项目</h1><p>一个wiki的主要操作为在访问关键字页面时展示相关信息，并且可以修改并保存相关信息。执行<code>go mod init gowiki</code>新建一个go项目，在目录下新建文件<code>wiki.go</code>作为程序的执行入口</p><h1 id="页面结构设定">页面结构设定</h1><p>对于一个wiki页面，简单来说它包含标题和页面两个部分，所以可以进行如下定义</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Page <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Body []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过下面的方法可以将一个Page保存到本地。其中，<code>save()</code>方法返回了一个错误值，这个错误值是由<code>os.WriteFile()</code>这个函数产生的，用于提示在写入文件时可能出现的异常，<code>os.WriteFile()</code>主要功能就是将<code>p.Body</code>这个字节数组存储到<code>filename</code>中，<code>0600</code>表示用户可以读写。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Page)</span></span> save() <span class="hljs-type">error</span> &#123;<br>    filename := p.Title + <span class="hljs-string">&quot;.txt&quot;</span><br>    <span class="hljs-keyword">return</span> os.WriteFile(filename, p.Body, <span class="hljs-number">0600</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>除了保存到本地，还希望通过一个函数，用本地文件生成一个Page结构，于是编写下面函数。其中，函数返回两个对象，<code>*Page</code>，<code>error</code>，error是如果<code>os.ReadFile()</code>函数返回错误，那么<code>loadPage()</code>返回为<code>nil</code>，<code>err</code>；否则，返回由<code>title</code>和读取<code>body</code>构成的<code>Page</code>结构和<code>nil</code>空错误。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadPage</span><span class="hljs-params">(title <span class="hljs-type">string</span>)</span></span> (*Page, <span class="hljs-type">error</span>) &#123;<br>    filename := title + <span class="hljs-string">&quot;.txt&quot;</span><br>    body, err := os.ReadFile(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;Page&#123;Title: title, Body: body&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="函数测试">函数测试</h2><p>使用<code>vscode</code>中的go插件，可以辅助生成测试函数<code>wiki_test.go</code>，添加相关测试用例后可以执行测试函数。</p><h1 id="web服务编辑">Web服务编辑</h1><h2 id="nethttp包">net/http包</h2><p>net/http是标准库的http客户端、服务器实现，下面是一个简单服务器代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World! %s&quot;</span>, r.URL.Path[<span class="hljs-number">1</span>:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个程序由两部分组成，配置和启动服务的<code>main</code>函数，以及处理请求的<code>handler</code>函数。</p><p><code>main</code>函数中，<code>http.HandleFunc("/", handler)</code>来描述所有的对<code>/</code>的请求，都交给<code>handler</code>函数处理；<code>http.ListenAndServe(":8080", nil)</code>表示监听；<code>log.Fatal()</code>用来记录之前函数的日志。</p><p><code>handler</code>函数，实际上是<code>http.HandlerFunc</code>类型的一个实例，其定义为<code>type HandlerFunc func(ResponseWriter, *Request)</code>；<code>http.Request</code>表示为一次http请求，<code>r.URL.Path</code>也就是请求的URL路径；通过向<code>http.ResponseWriter</code>写入数据，就可以将信息返回给客户端。</p><h2 id="处理页面访问请求">处理页面访问请求</h2><p>定义handler函数，用于处理<code>/view</code>的请求，通过<code>/view/</code>后的字段来访问相应数据页面，如果<code>loadPage()</code>函数抛出异常，则返回跳转到编辑页面</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    log.Println(<span class="hljs-string">&quot;viewHandler: &quot;</span>, r.URL.Path)<br>    title := r.URL.Path[<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;/view/&quot;</span>):]<br>    p, err := loadPage(title)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// http.NotFound(w, r)</span><br>        http.Redirect(w, r, <span class="hljs-string">&quot;/edit/&quot;</span>+title, http.StatusFound)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;&lt;h1&gt;%s&lt;/h1&gt;&lt;div&gt;%s&lt;/div&gt;&quot;</span>, p.Title, p.Body)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="编辑页面访问请求">编辑页面访问请求</h2><p>这里需要两个handler分别处理编辑数据，保存数据的请求。</p><p>其中<code>editHandler()</code>，通过template包将<code>edit.html</code>这个页面执行到w中。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">editHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    title := r.URL.Path[<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;/edit/&quot;</span>):]<br>    p, err := loadPage(title)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        p = &amp;Page&#123;Title: title&#125;<br>    &#125;<br>    t, err := template.ParseFiles(<span class="hljs-string">&quot;edit.html&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    err = t.Execute(w, p)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>saveHandler()</code>将对应的页面信息保存到文件</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    title := r.URL.Path[<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;/save/&quot;</span>):]<br>    body := r.FormValue(<span class="hljs-string">&quot;body&quot;</span>)<br>    p := &amp;Page&#123;Title: title, Body: []<span class="hljs-type">byte</span>(body)&#125;<br>    err := p.save()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        http.Error(w, err.Error(), http.StatusInternalServerError)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Success, page %s saved!&quot;</span>, title)<br>    http.Redirect(w, r, <span class="hljs-string">&quot;/view/&quot;</span>+title, http.StatusFound)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    Editing &#123;&#123;.Title&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/save/&#123;&#123;.Title&#125;&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;body&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span><br>        &#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="处理请求">处理请求</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.HandleFunc(<span class="hljs-string">&quot;/view/&quot;</span>, viewHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/edit/&quot;</span>, editHandler)<br>    http.HandleFunc(<span class="hljs-string">&quot;/save/&quot;</span>, saveHandler)<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样的话基本的服务已经可以启动起来了，接下来就是针对用户体验和开发方便的一系列优化</p><h1 id="其他优化">其他优化</h1><h2 id="输入验证">输入验证</h2><p>添加正则表达式来验证请求只有符合自己规范时才做处理，其他请求均返回404</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> validPath = regexp.MustCompile(<span class="hljs-string">&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    m := validPath.FindStringSubmatch(r.URL.Path)<br>    <span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>        http.NotFound(w, r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;invalid Page Title&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> m[<span class="hljs-number">2</span>], <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="改进代码冗余">改进代码冗余</h2><p>我们发现三个handler其实重复代码非常多，为了代码逻辑清晰，我们需要对复用代码进行整理。</p><p>首先调整handler函数多接受一个参数 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, title <span class="hljs-type">string</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">editHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, title <span class="hljs-type">string</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, title <span class="hljs-type">string</span>)</span></span><br></code></pre></div></td></tr></table></figure></p><p>然后定义一个包装器，接受上面这种类型的函数作为参数</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeHandler</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    fn <span class="hljs-keyword">func</span> (http.ResponseWriter, *http.Request, <span class="hljs-type">string</span>)</span></span><br>) http.HandlerFunc &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>        log.Println(r.URL.Path)<br>        title, err := getTitle(w, r)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        fn(w, r, title)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>修改主函数中的<code>http.HandlerFunc()</code>函数，以及各个handler中的不必要的log以及验证。</p><h2 id="template-其他加载方式">template 其他加载方式</h2><p>viewHandler和editHandler都需要使用template来传输网页，但是每一次都用本地读取是一个十分不明智的选择，template提供一种方法先将所有的html文件载入到内存中，然后直接从内存将网页发送过去</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> templates = template.Must(template.ParseFiles(<span class="hljs-string">&quot;edit.html&quot;</span>, <span class="hljs-string">&quot;view.html&quot;</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">renderTemplate</span><span class="hljs-params">(w http.ResponseWriter, tmpl <span class="hljs-type">string</span>, p *Page)</span></span> &#123;<br>err := templates.ExecuteTemplate(w, tmpl+<span class="hljs-string">&quot;.html&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, err.Error(), http.StatusInternalServerError)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="总结">总结</h1><p>到这里一个基本web服务基本构建完成，这也只是使用很少一部分http包的功能来实现了一个简单的项目，更多的相关资料可以在<ahref="https://pkg.go.dev/net/http">http</a>中查看。</p><p>本项目的文件结构为 <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">wiki<br>    |=data<br>        |-xxx.txt<br>        |-...<br>    |-wiki.go<br>    |-handler.go<br>    |-page.go<br>    |-edit.html<br>    |-view.html<br>    |-go.mod<br></code></pre></div></td></tr></table></figure></p><p>具体的源码如下</p><p><strong>page.go</strong> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-keyword">type</span> Page <span class="hljs-keyword">struct</span> &#123;<br>Title <span class="hljs-type">string</span><br>Body  []<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadPage</span><span class="hljs-params">(title <span class="hljs-type">string</span>)</span></span> (*Page, <span class="hljs-type">error</span>) &#123;<br>filename := <span class="hljs-string">&quot;data/&quot;</span> + title + <span class="hljs-string">&quot;.txt&quot;</span><br>body, err := os.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Page&#123;Title: title, Body: body&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(p *Page)</span></span> <span class="hljs-type">error</span> &#123;<br>filename := <span class="hljs-string">&quot;data/&quot;</span> + p.Title + <span class="hljs-string">&quot;.txt&quot;</span><br><span class="hljs-keyword">return</span> os.WriteFile(filename, p.Body, <span class="hljs-number">0600</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p><strong>handler.go</strong> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;regexp&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> templates = template.Must(template.ParseFiles(<span class="hljs-string">&quot;edit.html&quot;</span>, <span class="hljs-string">&quot;view.html&quot;</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">renderTemplate</span><span class="hljs-params">(w http.ResponseWriter, tmpl <span class="hljs-type">string</span>, p *Page)</span></span> &#123;<br>err := templates.ExecuteTemplate(w, tmpl+<span class="hljs-string">&quot;.html&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, err.Error(), http.StatusInternalServerError)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> validPath = regexp.MustCompile(<span class="hljs-string">&quot;^/(edit|save|view)/([a-zA-Z0-9]+)$&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>m := validPath.FindStringSubmatch(r.URL.Path)<br><span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>http.NotFound(w, r)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;invalid Page Title&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> m[<span class="hljs-number">2</span>], <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, title <span class="hljs-type">string</span>)</span></span> &#123;<br>p, err := loadPage(title)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Redirect(w, r, <span class="hljs-string">&quot;/edit/&quot;</span>+title, http.StatusFound)<br><span class="hljs-keyword">return</span><br>&#125;<br>renderTemplate(w, <span class="hljs-string">&quot;view&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">editHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, title <span class="hljs-type">string</span>)</span></span> &#123;<br>p, err := loadPage(title)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>p = &amp;Page&#123;Title: title&#125;<br>&#125;<br>renderTemplate(w, <span class="hljs-string">&quot;edit&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request, title <span class="hljs-type">string</span>)</span></span> &#123;<br>body := r.FormValue(<span class="hljs-string">&quot;body&quot;</span>)<br>p := &amp;Page&#123;Title: title, Body: []<span class="hljs-type">byte</span>(body)&#125;<br>err := save(p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, err.Error(), http.StatusInternalServerError)<br><span class="hljs-keyword">return</span><br>&#125;<br>http.Redirect(w, r, <span class="hljs-string">&quot;/view/&quot;</span>+title, http.StatusFound)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeHandler</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(http.ResponseWriter, *http.Request, <span class="hljs-type">string</span>)</span></span>) http.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>log.Println(r.URL.Path)<br>title, err := getTitle(w, r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fn(w, r, title)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p><strong>wiki.go</strong> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/view/&quot;</span>, makeHandler(viewHandler))<br>http.HandleFunc(<span class="hljs-string">&quot;/edit/&quot;</span>, makeHandler(editHandler))<br>http.HandleFunc(<span class="hljs-string">&quot;/save/&quot;</span>, makeHandler(saveHandler))<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p><strong>view.html</strong> <figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;.Title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>[<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/edit/&#123;&#123;.Title&#125;&#125;&quot;</span>&gt;</span>edit<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>]<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure></p><p><strong>edit.html</strong> <figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    Editing &#123;&#123;.Title&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/save/&#123;&#123;.Title&#125;&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;body&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;80&quot;</span>&gt;</span>&#123;&#123;printf &quot;%s&quot; .Body&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Save&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></div></td></tr></table></figure></p><h2 id="参考资料">参考资料</h2><ol type="1"><li><ahref="https://www.bilibili.com/video/BV1uR4y1V7n9">这么萌的Go开发课程（2），真的不进来看一下嘛？[Web开发基础]</a></li><li><a href="https://pkg.go.dev/net/http">http package</a></li><li><a href="https://go.dev/doc/articles/wiki/">Writing WebApplications</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Go Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础Web开发-Go模块相关知识</title>
    <link href="/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%911/"/>
    <url>/2022-05/Go%E5%9F%BA%E7%A1%80Web%E5%BC%80%E5%8F%911/</url>
    
    <content type="html"><![CDATA[<h1 id="go-命令行工具">Go 命令行工具</h1><p>本项目通过Go命令行工具来进行项目的编译与安装，通过控制台执行</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">go<br></code></pre></div></td></tr></table></figure><p>可以获得以下信息</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Go is a tool <span class="hljs-keyword">for</span> managing Go <span class="hljs-built_in">source</span> code.<br><br>Usage:<br><br>        go &lt;<span class="hljs-built_in">command</span>&gt; [arguments]<br><br>The commands are:<br><br>        bug         start a bug report<br>        build       compile packages and dependencies<br>        clean       remove object files and cached files<br>        doc         show documentation <span class="hljs-keyword">for</span> package or symbol<br>        <span class="hljs-built_in">env</span>         <span class="hljs-built_in">print</span> Go environment information<br>        fix         update packages to use new APIs<br>        <span class="hljs-built_in">fmt</span>         gofmt (reformat) package sources<br>        generate    generate Go files by processing <span class="hljs-built_in">source</span><br>        get         add dependencies to current module and install them<br>        install     compile and install packages and dependencies<br>        list        list packages or modules<br>        mod         module maintenance<br>        work        workspace maintenance<br>        run         compile and run Go program<br>        <span class="hljs-built_in">test</span>        <span class="hljs-built_in">test</span> packages<br>        tool        run specified go tool<br>        version     <span class="hljs-built_in">print</span> Go version<br>        vet         report likely mistakes <span class="hljs-keyword">in</span> packages<br><br>Use <span class="hljs-string">&quot;go help &lt;command&gt;&quot;</span> <span class="hljs-keyword">for</span> more information about a <span class="hljs-built_in">command</span>.<br><br>Additional <span class="hljs-built_in">help</span> topics:<br><br>        buildconstraint build constraints<br>        packages        package lists and patterns<br>        private         configuration <span class="hljs-keyword">for</span> downloading non-public code<br>        testflag        testing flags<br>        testfunc        testing <span class="hljs-built_in">functions</span><br>        vcs             controlling version control with GOVCS<br><br>Use <span class="hljs-string">&quot;go help &lt;topic&gt;&quot;</span> <span class="hljs-keyword">for</span> more information about that topic.<br></code></pre></div></td></tr></table></figure><p>通过上述帮助信息以及官方文档的说明<ahref="https://pkg.go.dev/cmd/go">gocommand</a>可以获得go命令行工具的基础用法。本项目中使用的相关指令如下:</p><ul><li>go build 用于将Go项目代码编译成可执行文件</li><li>go mod Go的项目包依赖管理工具</li></ul><h1 id="代码结构">代码结构</h1><h2 id="package">Package</h2><p>数个go文件共同构成一个包，同个包下的go文件中声明的变量和函数可以相互访问与使用，一个包的结构如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">package0<br>    |--file1.go<br>    |--file2.go<br>    |--...<br></code></pre></div></td></tr></table></figure><h2 id="module">Module</h2><p>数个包共同构成一个模块，往往一个项目中只有一个模块，当然多个也没有问题。在每个模块根目录下，存放着<code>go.mod</code>文件，一个模块的结构如下</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">Module0<br>    |--package0<br>        |--file1.go<br>        |--file2.go<br>        |--...<br>    |--package1<br>        |--...<br>    |--package2<br>    |--...<br>    |--go.mod<br></code></pre></div></td></tr></table></figure><h2 id="go.mod">go.mod</h2><p><code>go.mod</code>的中记录了项目路径、go的版本和项目依赖</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">module /path/to/project/<br><br>go 1.18.1<br><br>require /path/to/require/project<br></code></pre></div></td></tr></table></figure><p>例如Gin项目中的<code>go.mod</code> <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">//https://github.com/gin-gonic/gin/blob/master/go.mod<br><br>module github.com/gin-gonic/gin<br><br>go 1.18<br><br>require (<br>github.com/gin-contrib/sse v0.1.0<br>github.com/go-playground/validator/v10 v10.10.0<br>github.com/goccy/go-json v0.9.7<br>github.com/json-iterator/go v1.1.12<br>github.com/mattn/go-isatty v0.0.14<br>github.com/stretchr/testify v1.7.1<br>github.com/ugorji/go/codec v1.2.7<br>golang.org/x/net v0.0.0-20210226172049-e18ecbb05110<br>google.golang.org/protobuf v1.28.0<br>gopkg.in/yaml.v2 v2.4.0<br>)<br><br>require (<br>github.com/davecgh/go-spew v1.1.1 // indirect<br>github.com/go-playground/locales v0.14.0 // indirect<br>github.com/go-playground/universal-translator v0.18.0 // indirect<br>github.com/leodido/go-urn v1.2.1 // indirect<br>github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect<br>github.com/modern-go/reflect2 v1.0.2 // indirect<br>github.com/pmezard/go-difflib v1.0.0 // indirect<br>golang.org/x/crypto v0.0.0-20210711020723-a769d52b0f97 // indirect<br>golang.org/x/sys v0.0.0-20210806184541-e5e7981a1069 // indirect<br>golang.org/x/text v0.3.6 // indirect<br>gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect<br>)<br></code></pre></div></td></tr></table></figure></p><p>module记录了项目的下载路径，当然一个本地项目或者非开源项目可以不用写具体到github的仓库地址，但是在编写代码的过程中，一定要保证良好的代码习惯，以便于随时将项目发布出去。</p><h2 id="包依赖的导入">包依赖的导入</h2><p>在一个go文件中，想要导入一个标准库或者一个第三方依赖库，需要在文件开头标注import信息</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;github.com/gin-gonic/gin/&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>标准库的话，只需要写包名即可导入，但是一定要注意，import实际是导入是库路径或者说是模块路径，比如标准库<code>fmt</code>，<code>import</code>中只是用了<code>"fmt"</code>来导入这个标准库，实际上他在告诉go编译器，他要从系统的<code>GOPATH</code>中导入一个路径为<code>$GOPATH/fmt</code>的包，这个包名叫做<code>fmt</code>，所以在主函数中，可以通过<code>package.FuncName()</code>来调用函数，当然在<code>import</code>也可以对这个包重命名，例如</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// package info</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// other code</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">print</span>.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码中的<code>print.Println("hello world")</code> 与上段代码中的<code>fmt.Println("hello world")</code> 是一个效果。</p><p>同理，第三方库的导入也是这个逻辑。但是第三方包需要使用命令<code>go mod tidy</code>来安装，并且修改项目中<code>go.mod</code>文件中的依赖信息，第三方包被安装在<code>$GOPATH$/pkg</code>目录下面，下载速度慢的话，可以试试go国内代理如，<ahref="goproxy.cn">goproxy.cn</a>，移除下载使用<code>go clean -modcache</code>。</p><h1 id="第一个项目">第一个项目</h1><h2 id="使用go-mod新建项目">使用Go mod新建项目</h2><p>在项目文件夹下，输入指令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">go mod init &lt;name&gt;<br></code></pre></div></td></tr></table></figure><p>会在当前文件夹下生成<code>go.mod</code>文件，使用goModule机制来管理依赖包，可以使开发者专注于开发而不必在相关依赖上面花费太多心思。</p><h2 id="构建hello-world程序">构建hello world程序</h2><h3 id="编写代码">编写代码</h3><p>新建文件<code>hello.go</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello, world.&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里<code>main</code>包下的<code>main</code>函数是go程序的执行入口。</p><h3 id="安装编译模块">安装编译模块</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">go install module/path<br>go install .<br>go install<br></code></pre></div></td></tr></table></figure><p>使用该指令会将模块安装到本机的go环境中，windows下在<code>%userprofile%/go/bin/hello.exe</code>或者<code>%GOBIN%</code>目录下，在控制台中直接输入<code>hello</code>就可以运行</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">PS D:\Code-Repo\Go-Web-Demo\hello&gt; go install example/user/hello <br>PS D:\Code-Repo\Go-Web-Demo\hello&gt; hello<br>Hello, world.<br></code></pre></div></td></tr></table></figure><p>通过如下指令来配置go相关的环境信息</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPATH=/somewhere <span class="hljs-comment">#设置相关环境</span><br>go <span class="hljs-built_in">env</span> -u GOBIN <span class="hljs-comment">#恢复初始值</span><br></code></pre></div></td></tr></table></figure><p>当然也可使用其他指令来编译项目</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">go build module/path<br></code></pre></div></td></tr></table></figure><p>或者使用run来解释执行go文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">go run xxx.go<br></code></pre></div></td></tr></table></figure><h3 id="包编写与引用">包编写与引用</h3><p>在项目目录下面，生成文件夹<code>morestrings</code>，在<code>morestrings</code>文件夹中编写文件<code>reverse.go</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> morestrings<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReverseRune</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>r := []<span class="hljs-type">rune</span>(s)<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(r)<span class="hljs-number">-1</span>; i &lt; <span class="hljs-built_in">len</span>(r)/<span class="hljs-number">2</span>; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>r[i], r[j] = r[j], r[i]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(r)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个方法是将Rune字符倒序（也就是汉字字符等特殊字符），在<code>hello.go</code>中修改</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;example/user/hello/morestrings&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(morestrings.ReverseRune(<span class="hljs-string">&quot;Hello, 世界.&quot;</span>))<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>然后编译运行，可以获得正确的结果</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">PS D:\Code-Repo\Go-Web-Demo\hello&gt; go install <br>PS D:\Code-Repo\Go-Web-Demo\hello&gt; hello<br>.界世 ,olleH<br></code></pre></div></td></tr></table></figure><h2 id="模块测试">模块测试</h2><p>在<code>morestrings</code>中，编辑文件<code>test_reverse.go</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> morestrings<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestReveseRune</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>cases := []<span class="hljs-keyword">struct</span> &#123;<br>in, want <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-string">&quot;dlrow olleh&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;hello 世界&quot;</span>, <span class="hljs-string">&quot;界世 olleh&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> cases &#123;<br>got := ReverseRune(c.in)<br><span class="hljs-keyword">if</span> got != c.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;ReverseRunes(%q) == %q, want %q&quot;</span>, c.in, got, c.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行指令<code>go test</code>会自动执行有<code>testing.T</code>的函数，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">PS D:\Code-Repo\Go-Web-Demo\hello\morestrings&gt; go <span class="hljs-built_in">test</span><br>PASS<br>ok      example/user/hello/morestrings  0.193s<br></code></pre></div></td></tr></table></figure><p>以上便是一个完整的模块开发流程，基于以上流程进行之后学习开发GoWeb相关的项目开发。</p>]]></content>
    
    
    <categories>
      
      <category>Go Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-结构体、方法</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h1 id="类型定义type-definition">类型定义（Type Definition）</h1><p><strong>自定义一个新类型</strong></p><p>这也是我们最常用的类型定义方法。在这种方法中，我们会使用关键字type来定义一个新类型 T，具体形式是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T S <span class="hljs-comment">// 定义一个新类型T</span><br></code></pre></div></td></tr></table></figure><p>在这里，S 可以是任何一个已定义的类型，包括 Go原生类型，或者是其他已定义的自定义类型，我们来演示一下这两种情况：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span> <br><span class="hljs-keyword">type</span> T2 T1  <br></code></pre></div></td></tr></table></figure></p><p>这段代码中，新类型 T1 是基于 Go 原生类型 int定义的新自定义类型，而新类型 T2 则是基于刚刚定义的类型T1，定义的新类型。</p><p>这里我们引入一个新概念，底层类型。如果一个新类型是基于某个 Go原生类型定义的，那么我们就叫 Go 原生类型为新类型的底层类型（UnderlyingType)。比如这个例子中，类型 int 就是类型 T1 的底层类型。底层类型在 Go语言中有重要作用，它被用来判断两个类型本质上是否相同（Identical）。</p><p>本质上相同的两个类型，它们的变量可以通过显式转型进行相互赋值，相反，如果本质上是不同的两个类型，它们的变量间连显式转型都不可能，更不要说相互赋值了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> T2 T1<br><span class="hljs-keyword">type</span> T3 <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> n1 T1<br>    <span class="hljs-keyword">var</span> n2 T2 = <span class="hljs-number">5</span><br>    n1 = T1(n2)  <span class="hljs-comment">// ok</span><br>    <br>    <span class="hljs-keyword">var</span> s T3 = <span class="hljs-string">&quot;hello&quot;</span><br>    n1 = T1(s) <span class="hljs-comment">// 错误：cannot convert s (type T3) to type T1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>除了基于已有类型定义新类型之外，我们还可以基于类型字面值来定义新类型，这种方式多用于自定义一个新的复合类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> M <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span><br><span class="hljs-keyword">type</span> S []<span class="hljs-type">string</span><br></code></pre></div></td></tr></table></figure><p>和变量声明支持使用 var 块的方式类似，类型定义也支持通过 type块的方式进行，比如我们可以把上面代码中的 T1、T2 和 T3 的定义放在同一个type 块中：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>   T1 <span class="hljs-type">int</span><br>   T2 T1<br>   T3 <span class="hljs-type">string</span><br>)<br></code></pre></div></td></tr></table></figure><p><strong>类型别名（Type Alias）</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = S <span class="hljs-comment">// type alias</span><br></code></pre></div></td></tr></table></figure><p>我们看到，与前面的第一种类型定义相比，类型别名的形式只是多了一个等号，但正是这个等号让新类型T 与原类型 S 完全等价。完全等价的意思就是，类型别名并没有定义出新类型，T与 S 实际上就是同一种类型，它们只是一种类型的两个名字罢了</p><h1 id="结构体">结构体</h1><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    Field1 T1<br>    Field2 T2<br>    ... ...<br>    FieldN Tn<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据这个定义，我们会得到一个名为 T 的结构体类型，定义中 struct关键字后面的大括号包裹的内容就是一个类型字面值。我们看到这个类型字面值由若干个字段（field）聚合而成，每个字段有自己的名字与类型，并且在一个结构体中，每个字段的名字应该都是唯一的。</p><p>我们前面提到过对现实世界的书进行抽象的情况，其实用结构体类型就可以实现，比如这里，我就用前面的典型方法定义了一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> book<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>     Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>     Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>     Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，只要其他包导入了包 book，我们就可以在这些包中直接引用类型名Book，也可以通过 Book 类型变量引用 <code>Name</code>、<code>Pages</code>等字段，就像下面代码中这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;.../book&quot;</span><br><br><span class="hljs-keyword">var</span> b book.Book<br>b.Title = <span class="hljs-string">&quot;The Go Programming Language&quot;</span><br>b.Pages = <span class="hljs-number">800</span><br></code></pre></div></td></tr></table></figure><p>如果结构体类型只在它定义的包内使用，那么我们可以将类型名的首字母小写；如果你不想将结构体类型中的某个字段暴露给其他包，那么我们同样可以把这个字段名字的首字母小写。</p><p>除了通过类型字面值来定义结构体这种典型操作外，我们还有另外几种特殊的情况。</p><p><strong>定义一个空结构体</strong></p><p>我们可以定义一个空结构体，也就是没有包含任何字段的结构体类型，就像下面示例代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// Empty是一个不包含任何字段的空结构体类型</span><br></code></pre></div></td></tr></table></figure><p>空结构体类型有什么用呢？我们继续看下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s Empty<br><span class="hljs-built_in">println</span>(unsafe.Sizeof(s)) <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure><p>我们看到，输出的空结构体类型变量的大小为0，也就是说，空结构体类型变量的内存占用为0。基于空结构体类型内存零开销这样的特性，我们在日常 Go开发中会经常使用空结构体类型元素，作为一种“事件”信息进行 Goroutine之间的通信，就像下面示例代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Empty) <span class="hljs-comment">// 声明一个元素类型为Empty的channel</span><br>c&lt;-Empty&#123;&#125;               <span class="hljs-comment">// 向channel写入一个“事件”</span><br></code></pre></div></td></tr></table></figure><p>这种以空结构体为元素类建立的 channel，是目前能实现的、内存占用最小的Goroutine 间通信方式。</p><p><strong>使用其他结构体作为自定义结构体中字段的类型。</strong></p><p>我们看这段代码，这里结构体类型 Book 的字段 Author的类型，就是另外一个结构体类型 Person：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>    Addr <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Author Person<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们要访问 Book 结构体字段 Author 中的 Phone字段，我们可以这样操作：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Author.Phone)<br></code></pre></div></td></tr></table></figure><p>不过，对于包含结构体类型字段的结构体类型来说，Go还提供了一种更为简便的定义方法，那就是我们可以无需提供字段的名字，只需要使用其类型就可以了，以上面的Book 结构体定义为例，我们可以用下面的方式提供一个等价的定义：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span><br>    Person<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>以这种方式定义的结构体字段，我们叫做嵌入字段（EmbeddedField）。我们也可以将这种字段称为匿名字段，或者把类型名看作是这个字段的名字。如果我们要访问Person 中的 Phone 字段，我们可以通过下面两种方式进行：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <br><span class="hljs-built_in">println</span>(book.Person.Phone) <span class="hljs-comment">// 将类型名当作嵌入字段的名字</span><br><span class="hljs-built_in">println</span>(book.Phone)        <span class="hljs-comment">// 支持直接访问嵌入字段所属类型中字段</span><br></code></pre></div></td></tr></table></figure><p>第一种方式显然是通过把类型名当作嵌入字段的名字来进行操作的，而第二种方式更像是一种“语法糖”，我们可以“绕过”Person类型这一层，直接访问 Person 中的字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ad-note">Go 语言不支持这种在结构体类型定义中，递归地放入其自身类型字段的定义方式。面对上面的示例代码，编译器就会给出“invalid recursive type T”的错误信息。<br></code></pre></div></td></tr></table></figure><p>同样，下面这两个结构体类型 T1 与 T2的定义也存在递归的情况，所以这也是不合法的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span> &#123;<br>  t2 T2<br>&#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span> &#123;<br>  t1 T1<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然我们不能在结构体类型 T 定义中，拥有以自身类型 T定义的字段，但我们却可以拥有自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为value 类型的 map 类型的字段，比如这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    t  *T           <span class="hljs-comment">// ok</span><br>    st []T          <span class="hljs-comment">// ok</span><br>    m  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]T <span class="hljs-comment">// ok</span><br>&#125;     <br></code></pre></div></td></tr></table></figure><p>一个类型，它所占用的大小是固定的，因此一个结构体定义好的时候，其大小是固定的。但是，如果结构体里面套结构体，那么在计算该结构体占用大小的时候，就会成死循环。但如果是指针、切片、map等类型，其本质都是一个int大小(指针，4字节或者8字节，与操作系统有关)，因此该结构体的大小是固定的，记得老师前几节课讲类型的时候说过，类型就能决定内存占用的大小。因此，结构体是可以接口自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为value 类型的 map 类型的字段，而自己本身不行。</p><h2 id="结构体变量的声明与初始化">结构体变量的声明与初始化</h2><p>和其他所有变量的声明一样，我们也可以使用标准变量声明语句，或者是短变量声明语句声明一个结构体类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book<br><span class="hljs-keyword">var</span> book = Book&#123;&#125;<br>book := Book&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>不过，这里要注意，我们在前面说过，结构体类型通常是对真实世界复杂事物的抽象，这和简单的数值、字符串、数组/切片等类型有所不同，结构体类型的变量通常都要被赋予适当的初始值后，才会有合理的意义。</p><p><strong>零值初始化</strong></p><p>零值初始化说的是使用结构体的零值作为它的初始值。对于 Go原生类型来说，这个默认值也称为零值。Go结构体类型由若干个字段组成，当这个结构体类型变量的各个字段的值都是零值时，我们就说这个结构体类型变量处于零值状态。</p><p>前面提到过，结构体类型的零值变量，通常不具有或者很难具有合理的意义，比如通过下面代码得到的零值book 变量就是这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book <span class="hljs-comment">// book为零值结构体变量</span><br></code></pre></div></td></tr></table></figure><p>如果一种类型采用零值初始化得到的零值变量，是有意义的，而且是直接可用的，称这种类型为“零值可用”类型。可以说，定义零值可用类型是简化代码、改善开发者使用体验的一种重要的手段。</p><p><strong>使用复合字面值</strong></p><p>最简单的对结构体变量进行显式初始化的方式，就是按顺序依次给每个结构体字段进行赋值，比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>    Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>    Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br><br><span class="hljs-keyword">var</span> book = Book&#123;<span class="hljs-string">&quot;The Go Programming Language&quot;</span>, <span class="hljs-number">700</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br></code></pre></div></td></tr></table></figure><p>我们依然可以用这种方法给结构体的每一个字段依次赋值，但这种方法也有很多问题：*首先，当结构体类型定义中的字段顺序发生变化，或者字段出现增删操作时，我们就需要手动调整该结构体类型变量的显式初始化代码，让赋值顺序与调整后的字段顺序一致。*其次，当一个结构体的字段较多时，这种逐一字段赋值的方式实施起来就会比较困难，而且容易出错，开发人员需要来回对照结构体类型中字段的类型与顺序，谨慎编写字面值表达式。*最后，一旦结构体中包含非导出字段，那么这种逐一字段赋值的方式就不再被支持了，编译器会报错：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    F1 <span class="hljs-type">int</span><br>    F2 <span class="hljs-type">string</span><br>    f3 <span class="hljs-type">int</span><br>    F4 <span class="hljs-type">int</span><br>    F5 <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br>或<br><span class="hljs-keyword">var</span> t = T&#123;<span class="hljs-number">11</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125; <span class="hljs-comment">// 错误：implicit assignment of unexported field &#x27;f3&#x27; in T literal</span><br></code></pre></div></td></tr></table></figure><p>Go 语言并不推荐我们按字段顺序对一个结构体类型变量进行显式初始化，甚至Go 官方还在提供的 go vet工具中专门内置了一条检查规则：“composites”，用来静态检查代码中结构体变量初始化是否使用了这种方法，一旦发现，就会给出警告。</p><p>Go推荐我们用“field:value”形式的复合字面值，对结构体类型变量进行显式初始化，这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合，这也是Go 语言的惯用法。这里，我们用“field:value”形式复合字面值，对上面的类型 T的变量进行初始化看看：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t = T&#123;<br>    F2: <span class="hljs-string">&quot;hello&quot;</span>,<br>    F1: <span class="hljs-number">11</span>,<br>    F4: <span class="hljs-number">14</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用这种“field:value”形式的复合字面值对结构体类型变量进行初始化，非常灵活。和之前的顺序复合字面值形式相比，“field:value”形式字面值中的字段可以以任意次序出现。未显式出现在字面值中的结构体字段（比如上面例子中的F5）将采用它对应类型的零值。</p><p>复合字面值作为结构体类型变量初值被广泛使用，即便结构体采用类型零值时，我们也会使用复合字面值的形式，较少使用new 这一个 Go 预定义的函数来创建结构体变量实例。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">t := T&#123;&#125;<br>tp := <span class="hljs-built_in">new</span>(T)<br></code></pre></div></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ad-note">这里值得我们注意的是，我们不能用从其他包导入的结构体中的未导出字段，来作为复合字面值中的 field。这会导致编译错误，因为未导出字段是不可见的。<br></code></pre></div></td></tr></table></figure><p><strong>构造函数</strong></p><p>使用特定的构造函数创建并初始化结构体变量的例子，并不罕见。在 Go标准库中就有很多，其中 time.Timer这个结构体就是一个典型的例子，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-keyword">type</span> runtimeTimer <span class="hljs-keyword">struct</span> &#123;<br>    pp       <span class="hljs-type">uintptr</span><br>    when     <span class="hljs-type">int64</span><br>    period   <span class="hljs-type">int64</span><br>    f        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">uintptr</span>)</span></span> <br>    arg      <span class="hljs-keyword">interface</span>&#123;&#125;<br>    seq      <span class="hljs-type">uintptr</span><br>    nextwhen <span class="hljs-type">int64</span><br>    status   <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span> &#123;<br>    C &lt;-<span class="hljs-keyword">chan</span> Time<br>    r runtimeTimer<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Timer 结构体中包含了一个非导出字段 r，r 的类型为另外一个结构体类型runtimeTimer。这个结构体更为复杂，而且我们一眼就可以看出来，这个runtimeTimer 结构体不是零值可用的，那我们在创建一个 Timer类型变量时就没法使用显式复合字面值的方式了。这个时候，Go标准库提供了一个 Timer 结构体专用的构造函数 NewTimer，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Time, <span class="hljs-number">1</span>)<br>    t := &amp;Timer&#123;<br>        C: c,<br>        r: runtimeTimer&#123;<br>            when: when(d),<br>            f:    sendTime,<br>            arg:  c,<br>        &#125;,<br>    &#125;<br>    startTimer(&amp;t.r)<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，NewTimer 这个函数只接受一个表示定时时间的参数d，在经过一个复杂的初始化过程后，它返回了一个处于可用状态的 Timer类型指针实例。像这类通过专用构造函数进行结构体类型变量创建、初始化的例子还有很多，我们可以总结一下，它们的专用构造函数大多都符合这种模式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(field1, field2, ...)</span></span> *T &#123;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，NewT 是结构体类型 T 的专用构造函数，它的参数列表中的参数通常与T 定义中的导出字段相对应，返回值则是一个 T 指针类型的变量。T的非导出字段在 NewT 内部进行初始化，一些需要复杂初始化逻辑的字段也会在NewT 内部完成初始化。这样，我们只要调用 NewT 函数就可以得到一个可用的 T指针类型变量了。</p><h1 id="方法">方法</h1><p><strong>方法的一般声明形式</strong> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(src *Server)</span></span> ListenAndServeTLS(certFile, keyFile String) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">//method block</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>Go中方法的声明和函数的声明有很多相似之处，从上面这张图我们可以看到，和由五个部分组成的函数声明不同，Go方法的声明有六个组成部分，多的一个就是图中的 receiver 部分。在 receiver部分声明的参数，Go 称之为 receiver 参数，这个 receiver参数也是方法与类型之间的纽带，也是方法与函数的最大不同。</p><p>方法接收器（receiver）参数、函数 /方法参数，以及返回值变量对应的作用域范围，都是函数 /方法体对应的显式代码块。</p><p>这就意味着，receiver部分的参数名不能与方法参数列表中的形参名，以及具名返回值中的变量名存在冲突，必须在这个方法的作用域中具有唯一性。如果这个不唯一不存在，比如像下面例子中那样，Go编译器就会报错：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M(t <span class="hljs-type">string</span>) &#123; <span class="hljs-comment">// 编译器报错：duplicate argument t (重复声明参数t)</span><br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不过，如果在方法体中，我们没有用到 receiver 参数，我们也可以省略receiver 的参数名，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M(t <span class="hljs-type">string</span>) &#123; <br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>仅当方法体中的实现不需要 receiver 参数参与时，我们才会省略 receiver参数名。</p><p>除了 receiver 参数名字要保证唯一外，Go 语言对 receiver参数的基类型也有约束，那就是 receiver参数的基类型本身不能为指针类型或接口类型。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyInt)</span></span> String() <span class="hljs-type">string</span> &#123; <span class="hljs-comment">// r的基类型为MyInt，编译器报错：invalid receiver type MyInt (MyInt is a pointer type)</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, *(*<span class="hljs-type">int</span>)(r))<br>&#125;<br><br><span class="hljs-keyword">type</span> MyReader io.Reader<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r MyReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123; <span class="hljs-comment">// r的基类型为MyReader，编译器报错：invalid receiver type MyReader (MyReader is an interface type)</span><br>    <span class="hljs-keyword">return</span> r.Read(p)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go 对方法声明的位置也是有约束的，Go 要求，方法声明要与 receiver参数的基类型声明放在同一个包内。基于这个约束，我们还可以得到两个推论。 *第一个推论：我们不能为原生类型（诸如 int、float64、map 等）添加方法。 *第二个推论：不能跨越 Go 包为其他包的类型声明新方法。</p><h2 id="方法的本质">方法的本质</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123; <br>    a <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> Get() <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Set(a <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br></code></pre></div></td></tr></table></figure><p>C++ 中的对象在调用方法时，编译器会自动传入指向对象自身的 this指针作为方法的第一个参数。而 Go 方法中的原理也是相似的，只不过我们是将receiver参数以第一个参数的身份并入到方法的参数列表中。按照这个原理，我们示例中的类型T 和 *T 的方法，就可以分别等价转换为下面的普通函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 类型T的方法Get的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(t T)</span></span> <span class="hljs-type">int</span> &#123;  <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br><br><span class="hljs-comment">// 类型*T的方法Set的等价函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Set</span><span class="hljs-params">(t *T, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <br>    t.a = a <br>    <span class="hljs-keyword">return</span> t.a <br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种等价转换后的函数的类型就是方法的类型。只不过在 Go语言中，这种等价转换是由 Go 编译器在编译和生成代码时自动完成的。Go语言规范中还提供了方法表达式（MethodExpression）的概念，可以让我们更充分地理解上面的等价转换，我们来看一下。</p><p>我们还以上面类型 T 以及它的方法为例，结合前面说过的 Go方法的调用方式，我们可以得到下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>t.Get()<br>(&amp;t).Set(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>我们可以用另一种方式，把上面的方法调用做一个等价替换：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>T.Get(t)<br>(*T).Set(&amp;t, <span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>这种直接以类型名 T 调用方法的表达方式，被称为 Method Expression。通过Method Expression 这种形式，类型 T 只能调用 T 的方法集合（MethodSet）中的方法，同理类型 *T 也只能调用 *T 的方法集合中的方法。这种通过Method Expression对方法进行调用的方式，与我们之前所做的方法到函数的等价转换是如出一辙的。所以，Go语言中的方法的本质就是，一个以方法的 receiver参数作为第一个参数的普通函数。</p><h2 id="receiver-参数类型对-go-方法的影响">receiver 参数类型对 Go方法的影响</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1() &lt;=&gt; F1(t T)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &lt;=&gt; F2(t *T)<br></code></pre></div></td></tr></table></figure><p>这个例子中有方法 M1 和 M2。M1 方法是 receiver 参数类型为 T的一类方法的代表，而 M2 方法则代表了 receiver 参数类型为 *T的另一类。下面我们分别来看看不同的 receiver 参数类型对 M1 和 M2的影响。</p><ul><li>首先，当 receiver 参数的类型为 T 时： 当我们选择以 T 作为 receiver参数类型时，M1 方法等价转换为F1(t T)。我们知道，Go函数的参数采用的是值拷贝传递，也就是说，F1 函数体中的 t 是 T类型实例的一个副本。这样，我们在 F1 函数的实现中对参数 t做任何修改，都只会影响副本，而不会影响到原 T 类型实例。</li></ul><p>据此我们可以得出结论：当我们的方法 M1 采用类型为 T 的 receiver参数时，代表 T 类型实例的 receiver 参数以值传递方式传递到 M1方法体中的，实际上是 T 类型实例的副本，M1方法体中对副本的任何修改操作，都不会影响到原 T 类型实例。</p><ul><li>第二，当 receiver 参数的类型为 *T 时： 当我们选择以 *T 作为 receiver参数类型时，M2 方法等价转换为F2(t *T)。同上面分析，我们传递给 F2 函数的t 是 T 类型实例的地址，这样 F2 函数体中对参数 t做的任何修改，都会反映到原 T 类型实例上。</li></ul><p>据此我们也可以得出结论：当我们的方法 M2 采用类型为 *T 的 receiver参数时，代表 *T 类型实例的 receiver 参数以值传递方式传递到 M2方法体中的，实际上是 T 类型实例的地址，M2 方法体通过该地址可以对原 T类型实例进行任何修改操作。</p><h3 id="选择-receiver-参数类型的第一个原则">选择 receiver参数类型的第一个原则</h3><p>基于上面的影响分析，我们可以得到选择 receiver参数类型的第一个原则：如果 Go 方法要把对 receiver参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为receiver 参数的类型。</p><p>存在问题：如果我们选择了 *T 作为 Go 方法 receiver参数的类型，那么我们是不是只能通过 *T 类型变量调用该方法，而不能通过 T类型变量调用了呢？</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>     a <span class="hljs-type">int</span><br> &#125;<br> <br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1() &#123;<br>     t.a = <span class="hljs-number">10</span><br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &#123;<br>    t.a = <span class="hljs-number">11</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t1 T<br>    <span class="hljs-built_in">println</span>(t1.a) <span class="hljs-comment">// 0</span><br>    t1.M1()<br>    <span class="hljs-built_in">println</span>(t1.a) <span class="hljs-comment">// 0</span><br>    t1.M2()<br>    <span class="hljs-built_in">println</span>(t1.a) <span class="hljs-comment">// 11</span><br><br>    <span class="hljs-keyword">var</span> t2 = &amp;T&#123;&#125;<br>    <span class="hljs-built_in">println</span>(t2.a) <span class="hljs-comment">// 0</span><br>    t2.M1()<br>    <span class="hljs-built_in">println</span>(t2.a) <span class="hljs-comment">// 0</span><br>    t2.M2()<br>    <span class="hljs-built_in">println</span>(t2.a) <span class="hljs-comment">// 11</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过这个实例，我们知道了这样一个结论：无论是 T 类型实例，还是 *T类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为*T 类型的方法。这样，我们在为方法选择 receiver参数的类型的时候，就不需要担心这个方法不能被与 receiver参数类型不一致的类型实例调用了。</p><h3 id="选择-receiver-参数类型的第二个原则">选择 receiver参数类型的第二个原则</h3><p>考虑到 Go 方法调用时，receiver参数是以值拷贝的形式传入方法中的。那么，如果 receiver 参数类型的 size较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为receiver 类型可能更好些。</p><h4 id="方法集合">方法集合</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    <span class="hljs-keyword">var</span> i Interface<br><br>    i = pt<br>    i = t <span class="hljs-comment">// cannot use t (type T) as type Interface in assignment: T does not implement Interface (M2 method has pointer receiver)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们定义了一个接口类型 Interface 以及一个自定义类型T。Interface 接口类型包含了两个方法 M1 和 M2，代码中还定义了基类型为 T的两个方法 M1 和 M2，但它们的 receiver 参数类型不同，一个为 T，另一个为*T。在 main 函数中，我们分别将 T 类型实例 t 和 *T 类型实例 pt 赋值给Interface 类型变量 i。运行一下这个示例程序，我们在i = t这一行会得到 Go编译器的错误提示，Go 编译器提示我们：T 没有实现 Interface类型方法列表中的 M2，因此类型 T 的实例 t 不能赋值给 Interface变量。有些事情并不是表面看起来这个样子的。了解方法集合后，这个问题就迎刃而解了。同时，方法集合也是用来判断一个类型是否实现了某接口类型的唯一手段，可以说，“方法集合决定了接口实现”。</p><p>所谓的方法集合决定接口实现的含义就是：如果某类型 T的方法集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I方法集合的超集，那么我们就说这个类型 T 实现了接口I。或者说，方法集合这个概念在 Go语言中的主要用途，就是用来判断某个类型是否实现了某个接口。</p><h3 id="选择-receiver-参数类型的第三个原则">选择 receiver参数类型的第三个原则</h3><p>这个原则的选择依据就是 T 类型是否需要实现某个接口，也就是是否存在将 T类型的变量赋值给某接口类型变量的情况。如果 T类型需要实现某个接口，那我们就要使用 T 作为 receiver参数的类型，来满足接口类型方法集合中的所有方法。如果 T不需要实现某一接口，但 *T 需要实现该接口，那么根据方法集合概念，*T的方法集合是包含 T 的方法集合的，这样我们在确定 Go 方法的 receiver的类型时，参考原则一和原则二就可以了。</p><h3 id="receiver-总结">receiver 总结</h3><p>receiver 参数选型的三个经验原则，在实际进行 Go方法设计时，我们首先应该考虑的是原则三，即 T类型是否要实现某一接口。如果 T类型需要实现某一接口的全部方法，那么我们就需要使用 T 作为 receiver参数的类型来满足接口类型方法集合中的所有方法。如果 T类型不需要实现某一接口，那么我们就可以参考原则一和原则二来为 receiver参数选择类型了。也就是，如果 Go 方法要把对 receiver参数所代表的类型实例的修改反映到原类型实例上，那么我们应该选择 *T 作为receiver 参数的类型。否则通常我们会为 receiver 参数选择 T类型，这样可以减少外部修改类型实例内部状态的“渠道”。除非 receiver参数类型的 size 较大，考虑到传值的较大性能开销，选择 *T 作为 receiver类型可能更适合。</p><p>方法集合。它在 Go语言中的主要用途就是判断某个类型是否实现了某个接口。方法集合像“胶水”一样，将自定义类型与接口隐式地“粘结”在一起，我们后面理解带有类型嵌入的类型时还会借助这个概念。</p><h1 id="继承-类型嵌入">“继承” 类型嵌入</h1><p>类型嵌入指的就是在一个类型的定义中嵌入了其他类型。Go语言支持两种类型嵌入，分别是接口类型的类型嵌入和结构体类型的类型嵌入。</p><h2 id="接口类型的类型嵌入">接口类型的类型嵌入</h2><p>我们先用一个案例，直观地了解一下什么是接口类型的类型嵌入。虽然我们现在还没有系统学习接口类型，但在前面的讲解中，我们已经多次接触了接口类型。我们知道，接口类型声明了由一个方法集合代表的接口，比如下面接口类型E：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> E <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个接口类型 E 的方法集合，包含两个方法，分别是 M1 和 M2，它们组成了E 这个接口类型所代表的接口。如果某个类型实现了方法 M1 和M2，我们就说这个类型实现了 E所代表的接口。此时，我们再定义另外一个接口类型I，它的方法集合中包含了三个方法 M1、M2 和 M3，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>    M3()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到接口类型 I 方法集合中的 M1 和 M2，与接口类型 E的方法集合中的方法完全相同。在这种情况下，我们可以用接口类型 E替代上面接口类型 I 定义中 M1 和 M2，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    E<br>    M3()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>像这种在一个接口类型（I）定义中，嵌入另外一个接口类型（E）的方式，就是我们说的接口类型的类型嵌入。而且，这个带有类型嵌入的接口类型I 的定义与上面那个包含 M1、M2 和 M3 的接口类型 I的定义，是等价的。因此，我们可以得到一个结论，这种接口类型嵌入的语义就是新接口类型（如接口类型I）将嵌入的接口类型（如接口类型E）的方法集合，并入到自己的方法集合中。</p><p>这也是 Go 组合设计哲学的一种体现</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/io/io.go</span><br><br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;<br>    Close() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>&#125;<br><br><span class="hljs-keyword">type</span> ReadCloser <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Closer<br>&#125;<br><br><span class="hljs-keyword">type</span> WriteCloser <span class="hljs-keyword">interface</span> &#123;<br>    Writer<br>    Closer<br>&#125;<br><br><span class="hljs-keyword">type</span> ReadWriteCloser <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>    Closer<br>&#125;<br></code></pre></div></td></tr></table></figure><p>不过，这种通过嵌入其他接口类型来创建新接口类型的方式，在 Go 1.14版本之前是有约束的：如果新接口类型嵌入了多个接口类型，这些嵌入的接口类型的方法集合不能有交集，同时嵌入的接口类型的方法集合中的方法名字，也不能与新接口中的其他方法同名。</p><h2 id="结构体类型的类型嵌入">结构体类型的类型嵌入</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    A <span class="hljs-type">int</span><br>    b <span class="hljs-type">string</span><br>    c T<br>    p *P<br>    _ [<span class="hljs-number">10</span>]<span class="hljs-type">int8</span><br>    F <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>结构体类型 S中的每个字段（field）都有唯一的名字与对应的类型，即便是使用空标识符占位的字段，它的类型也是明确的，但这还不是Go 结构体类型的“完全体”。Go结构体类型定义还有另外一种形式，那就是带有嵌入字段（EmbeddedField）的结构体定义。我们看下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> t2 <span class="hljs-keyword">struct</span>&#123;<br>    n <span class="hljs-type">int</span><br>    m <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>&#125;<br><br><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *t2<br>    I            <br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，结构体 S1 定义中有三个“非常规形式”的标识符，分别是 T1、t2和I，这三个标识符究竟代表的是什么呢？是字段名还是字段的类型呢？它们既代表字段的名字，也代表字段的类型。我们分别以这三个标识符为例，说明一下它们的具体含义：* 标识符 T1 表示字段名为 T1，它的类型为自定义类型 T1； * 标识符 t2表示字段名为 t2，它的类型为自定义结构体类型 t2 的指针类型； * 标识符 I表示字段名为 I，它的类型为接口类型 I。</p><p>这种以某个类型名、类型的指针类型名或接口类型名，直接作为结构体字段的方式就叫做结构体的类型嵌入，这些字段也被叫做嵌入字段（EmbeddedField）。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *MyInt)</span></span> Add(m <span class="hljs-type">int</span>) &#123;<br>    *n = *n + MyInt(m)<br>&#125;<br><br><span class="hljs-keyword">type</span> t <span class="hljs-keyword">struct</span> &#123;<br>    a <span class="hljs-type">int</span><br>    b <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>    *MyInt<br>    t<br>    io.Reader<br>    s <span class="hljs-type">string</span><br>    n <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := MyInt(<span class="hljs-number">17</span>)<br>    r := strings.NewReader(<span class="hljs-string">&quot;hello, go&quot;</span>)<br>    s := S&#123;<br>        MyInt: &amp;m,<br>        t: t&#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>        &#125;,<br>        Reader: r,<br>        s:      <span class="hljs-string">&quot;demo&quot;</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>    s.Reader.Read(sl)<br>    fmt.Println(<span class="hljs-type">string</span>(sl)) <span class="hljs-comment">// hello, go</span><br>    s.MyInt.Add(<span class="hljs-number">5</span>)<br>    fmt.Println(*(s.MyInt)) <span class="hljs-comment">// 22</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先，这个例子中的结构体类型 S使用了类型嵌入方式进行定义，它有三个嵌入字段 MyInt、t 和Reader。为什么第三个嵌入字段的名字为 Reader 而不是io.Reader？这是因为，Go语言规定如果结构体使用从其他包导入的类型作为嵌入字段，比如pkg.T，那么这个嵌入字段的字段名就是 T，代表的类型为 pkg.T。</p><p>接下来，我们再来看结构体类型 S 的变量的初始化。我们使用 field:value方式对 S 类型的变量 s的各个字段进行初始化。和普通的字段一样，初始化嵌入字段时，我们可以直接用嵌入字段名作为field。</p><p>而且，通过变量 s使用这些嵌入字段时，我们也可以像普通字段那样直接用变量s+字段选择符.+嵌入字段的名字，比如s.Reader。我们还可以通过这种方式调用嵌入字段的方法，比如 s.Reader.Read和 s.MyInt.Add。</p><h2 id="实现继承的原理">“实现继承”的原理</h2><p>我们将上面例子代码做一下细微改动，我这里只列了变化部分的代码<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sl = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;hello, go&quot;</span>))<br>s.Read(sl) <br>fmt.Println(<span class="hljs-type">string</span>(sl))<br>s.Add(<span class="hljs-number">5</span>) <br>fmt.Println(*(s.MyInt))<br></code></pre></div></td></tr></table></figure></p><p>这段代码似乎在告诉我们：Read 方法与 Add 方法就是类型 S方法集合中的方法。但是，这里类型 S明明没有显式实现这两个方法呀，它是从哪里得到这两个方法的实现的呢？</p><p>其实，这两个方法就来自结构体类型 S 的两个嵌入字段 Reader 和MyInt。结构体类型 S“继承”了 Reader 字段的方法 Read 的实现，也“继承”了*MyInt 的 Add方法的实现。注意，我这里的“继承”用了引号，说明这并不是真正的继承，它只是Go 语言的一种“障眼法”。</p><p>这种“障眼法”的工作机制是这样的，当我们通过结构体类型 S 的变量 s 调用Read 方法时，Go 发现结构体类型 S 自身并没有定义 Read 方法，于是 Go会查看 S 的嵌入字段对应的类型是否定义了 Read 方法。这个时候，Reader字段就被找了出来，之后 s.Read 的调用就被转换为 s.Reader.Read调用。这样一来，嵌入字段 Reader 的 Read 方法就被提升为 S的方法，放入了类型 S 的方法集合。同理 *MyInt 的 Add 方法也被提升为 S的方法而放入 S的方法集合。从外部来看，这种嵌入字段的方法的提升就给了我们一种结构体类型S“继承”了 io.Reader 类型 Read 方法的实现，以及 *MyInt 类型 Add方法的实现的错觉。到这里，我们就清楚了，嵌入字段的使用的确可以帮我们在Go 中实现方法的“继承”</p><h2 id="类型嵌入与方法集合">类型嵌入与方法集合</h2><p>在前面讲解接口类型的类型嵌入时，我们提到过接口类型的类型嵌入的本质，就是嵌入类型的方法集合并入到新接口类型的方法集合中，并且，接口类型只能嵌入接口类型。而结构体类型对嵌入类型的要求就比较宽泛了，可以是任意自定义类型或接口类型。</p><h3 id="结构体类型中嵌入接口类型">结构体类型中嵌入接口类型</h3><p>在结构体类型中嵌入接口类型后，结构体类型的方法集合会发生什么变化呢？我们通过下面这个例子来看一下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    I<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M3() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> p *T<br>    dumpMethodSet(t)<br>    dumpMethodSet(p)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行这个示例，我们会得到以下结果：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string">- M3</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br>- M3<br></code></pre></div></td></tr></table></figure><p>我们可以看到，原本结构体类型 T 只带有一个方法 M3，但在嵌入接口类型 I后，结构体类型 T 的方法集合中又并入了接口类型 I 的方法集合。并且，由于*T 类型方法集合包括 T 类型的方法集合，因此无论是类型 T 还是类型*T，它们的方法集合都包含 M1、M2 和M3。于是我们可以得出一个结论：结构体类型的方法集合，包含嵌入的接口类型的方法集合。</p><p>如果实现了，Go 就会优先使用结构体自己实现的方法。如果没有实现，那么Go就会查找结构体中的嵌入字段的方法集合中，是否包含了这个方法。如果多个嵌入字段的方法集合中都包含这个方法，那么我们就说方法集合存在交集。这个时候，Go编译器就会因无法确定究竟使用哪个方法而报错。那怎么解决这个问题呢？其实有两种解决方案。一是，我们可以消除E1 和 E2 方法集合存在交集的情况。二是为 T 增加 M1 和 M2方法的实现，这样的话，编译器便会直接选择 T 自己实现的 M1 和M2，不会陷入两难境地。</p><h3 id="结构体类型中嵌入结构体类型">结构体类型中嵌入结构体类型</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T1)</span></span> T1M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T1&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T1)</span></span> PT1M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT1&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T2)</span></span> T2M1()   &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;T2&#x27;s M1&quot;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T2)</span></span> PT2M2() &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;PT2&#x27;s M2&quot;</span>) &#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>    T1<br>    *T2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t := T&#123;<br>        T1: T1&#123;&#125;,<br>        T2: &amp;T2&#123;&#125;,<br>    &#125;<br><br>    dumpMethodSet(t)<br>    dumpMethodSet(&amp;t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，结构体类型 T 有两个嵌入字段，分别是 T1 和 *T2，我们知道T1 与 *T1、T2 与 *T2 的方法集合是不同的： T1 的方法集合包含：T1M1； *T1的方法集合包含：T1M1、PT1M2； T2 的方法集合包含：T2M1； *T2的方法集合包含：T2M1、PT2M2。</p><p>它们作为嵌入字段嵌入到 T 中后，对 T 和 *T的方法集合的影响也是不同的。我们运行一下这个示例，看一下输出结果：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- PT2M2</span><br><span class="hljs-string">- T1M1</span><br><span class="hljs-string">- T2M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- PT1M2<br>- PT2M2<br>- T1M1<br>- T2M1<br></code></pre></div></td></tr></table></figure><p>通过输出结果，我们看到了 T 和 *T 类型的方法集合果然有差别的： 类型 T的方法集合 = T1 的方法集合 + *T2 的方法集合类型 *T 的方法集合 = *T1的方法集合 + *T2 的方法集合</p><h2 id="defined-类型与-alias-类型的方法集合">defined 类型与 alias类型的方法集合</h2><p>Go 语言中，凡通过类型声明语法声明的类型都被称为 defined类型，下面是一些 defined 类型的声明的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>    M1()<br>    M2()<br>&#125;<br><span class="hljs-keyword">type</span> T <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> NT T <span class="hljs-comment">// 基于已存在的类型T创建新的defined类型NT</span><br><span class="hljs-keyword">type</span> NI I <span class="hljs-comment">// 基于已存在的接口类型I创建新defined接口类型NI</span><br></code></pre></div></td></tr></table></figure><p>对于那些基于接口类型创建的 defined的接口类型，它们的方法集合与原接口类型的方法集合是一致的。但对于基于非接口类型的defined 类型创建的非接口类型，我们通过下面例子来看一下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> t T<br>  <span class="hljs-keyword">var</span> pt *T<br>  <span class="hljs-keyword">var</span> t1 T1<br>  <span class="hljs-keyword">var</span> pt1 *T1<br><br>  dumpMethodSet(t)<br>  dumpMethodSet(t1)<br><br>  dumpMethodSet(pt)<br>  dumpMethodSet(pt1)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们基于一个 defined 的非接口类型 T 创建了新 defined类型 T1，并且分别输出 T1 和 *T1 的方法集合来确认它们是否“继承”了 T的方法集合。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T1&#x27;</span>s method set is empty!<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T1&#x27;</span>s method set is empty!<br></code></pre></div></td></tr></table></figure><p>从输出结果上看，新类型 T1 并没有“继承”原 defined 类型 T的任何一个方法。从逻辑上来说，这也符合 T1 与 T是两个不同类型的语义。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M1()  &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*T)</span></span> M2() &#123;&#125;<br><br><span class="hljs-keyword">type</span> T1 = T<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t T<br>    <span class="hljs-keyword">var</span> pt *T<br>    <span class="hljs-keyword">var</span> t1 T1<br>    <span class="hljs-keyword">var</span> pt1 *T1<br><br>    dumpMethodSet(t)<br>    dumpMethodSet(t1)<br><br>    dumpMethodSet(pt)<br>    dumpMethodSet(pt1)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string"></span><br><span class="hljs-string">main.T&#x27;</span>s method set:<br>- M1<br><br>*main.T<span class="hljs-string">&#x27;s method set:</span><br><span class="hljs-string">- M1</span><br><span class="hljs-string">- M2</span><br><span class="hljs-string"></span><br><span class="hljs-string">*main.T&#x27;</span>s method set:<br>- M1<br>- M2<br></code></pre></div></td></tr></table></figure><p>通过这个输出结果，我们看到，我们的 dumpMethodSet函数甚至都无法识别出“类型别名”，无论类型别名还是原类型，输出的都是原类型的方法集合。由此我们可以得到一个结论：无论原类型是接口类型还是非接口类型，类型别名都与原类型拥有完全相同的方法集合。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-控制结构、函数</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h1 id="控制结构">控制结构</h1><h2 id="if-语句">if 语句</h2><p>if 语句是 Go 语言中提供的一种分支控制结构，它也是 Go中最常用、最简单的分支控制结构。它会根据布尔表达式的值，在两个分支中选择一个执行。我们先来看一个最简单的、单分支结构的if 语句的形式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression &#123;<br>    <span class="hljs-comment">// 新分支</span><br>&#125;<br><br><span class="hljs-comment">// 原分支</span><br></code></pre></div></td></tr></table></figure><p>虽然各种编程语言几乎都原生支持了 if 语句，但 Go 的 if语句依然有着自己的特点：</p><ol type="1"><li>和 Go 函数一样，if 语句的分支代码块的左大括号与 if关键字在同一行上，这也是 Go 代码风格的统一要求，gofmt工具会帮助我们实现这一点；</li><li>if语句的布尔表达式整体不需要用括号包裹，一定程度上减少了开发人员敲击键盘的次数。而且，if关键字后面的条件判断表达式的求值结果必须是布尔类型，即要么是true，要么是 false</li></ol><h3 id="逻辑操作符">逻辑操作符</h3><p>如果判断的条件比较多，我们可以用多个逻辑操作符连接起多个条件判断表达式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (runtime.GOOS == <span class="hljs-string">&quot;linux&quot;</span>) &amp;&amp; (runtime.GOARCH == <span class="hljs-string">&quot;amd64&quot;</span>) &amp;&amp;<br>    (runtime.Compiler != <span class="hljs-string">&quot;gccgo&quot;</span>) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;we are using standard go compiler on linux os for amd64&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go语言的操作符是有优先级的。这里你要记住，一元操作符，比如上面的逻辑非操作符，具有最高优先级，其他操作符的优先级如下：</p><table><thead><tr class="header"><th>优先级</th><th>操作符</th></tr></thead><tbody><tr class="odd"><td>5</td><td>*、/、%、&lt;&lt;、&gt;&gt;、&amp;、&amp;^</td></tr><tr class="even"><td>4</td><td>+、-</td></tr><tr class="odd"><td>3</td><td>!=、==、&lt;、&lt;=、&gt;、&gt;=</td></tr><tr class="even"><td>2</td><td>&amp;&amp;</td></tr><tr class="odd"><td>1</td><td>||</td></tr></tbody></table><p>操作符优先级决定了操作数优先参与哪个操作符的求值运算，我们以下面代码中if 语句的布尔表达式为例：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a, b := <span class="hljs-literal">false</span>,<span class="hljs-literal">true</span><br>    <span class="hljs-keyword">if</span> a &amp;&amp; b != <span class="hljs-literal">true</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;(a &amp;&amp; b) != true&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;a &amp;&amp; (b != true) == false&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码的关键就在于，if 后面的布尔表达式中的操作数 b 是先参与&amp;&amp; 的求值运算，还是先参与!=的求值运算。根据前面的操作符优先级表，我们知道，!= 的优先级要高于&amp;&amp;，因此操作数 b 先参与的是!= 的求值运算，这样 if后的布尔表达式就等价于 a &amp;&amp; (b != true) ，而不是我们最初认为的(a &amp;&amp; b) != true。</p><p>从学习和使用 C语言开始，我自己就记不住这么多操作符的优先级，况且不同编程语言的操作符优先级还可能有所不同，所以我个人倾向在if 布尔表达式中，使用带有小括号的子布尔表达式来清晰地表达判断条件。</p><p>除了上面的最简形式，Go 语言的 if语句还有其他多种形式，比如二分支结构和多（N）分支结构。</p><p>二分支控制结构比较好理解。比如下面这个例子，当 boolean_expression求值为 true 时，执行分支 1，否则，执行分支 2：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>多分支结构:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression1 &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expression2 &#123;<br>  <span class="hljs-comment">// 分支2</span><br><br>... ...<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expressionN &#123;<br>  <span class="hljs-comment">// 分支N</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支N+1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>支持声明 if语句的自用变量</strong>：无论是单分支、二分支还是多分支结构，我们都可以在if 后的布尔表达式前，进行一些变量的声明，在 if布尔表达式前声明的变量，我叫它 if 语句的自用变量。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a, c := f(), h(); a &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(a)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b := f(); b &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println</span>(a, b, c)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 if 语句中声明自用变量是 Go语言的一个惯用法，这种使用方式直观上可以让开发者有一种代码行数减少的感觉，提高可读性。</p><p><strong>if 语句的“快乐路径”原则</strong>:在日常编码中要减少多分支结构，甚至是二分支结构的使用，这会有助于我们编写出优雅、简洁、易读易维护且不易错的代码。</p><h2 id="for-语句">for 语句</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>&#125;<br><span class="hljs-built_in">println</span>(sum)<br></code></pre></div></td></tr></table></figure><p>这种 for 语句的使用形式是 Go 语言中 for 循环语句的经典形式</p><p>Go 语言的 for循环支持声明多循环变量，并且可以应用在循环体以及判断条件中，比如下面就是一个使用多循环变量的、稍复杂的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, j, k := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>; (i &lt; <span class="hljs-number">20</span>) &amp;&amp; (j &lt; <span class="hljs-number">10</span>) &amp;&amp; (k &lt; <span class="hljs-number">30</span>); i, j, k = i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">5</span> &#123;<br>    sum += (i + j + k)<br>    <span class="hljs-built_in">println</span>(sum)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们继续按四个组成部分分析这段代码。其实，除了循环体部分（③）之外，其余的三个部分都是可选的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; &#123;<br>    i++<br>&#125;<br><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; i++&#123;<br>    <span class="hljs-built_in">println</span>(i)<br>&#125;  <br><br><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>; &#123;<br>    <span class="hljs-built_in">println</span>(i)<br>    i++<br>&#125;<br></code></pre></div></td></tr></table></figure><p>虽然我们对前置语句或后置语句进行了省略，但经典 for循环形式中的分号依然被保留着，你要注意这一点，这是 Go语法的要求。不过有一个例外，那就是当循环前置与后置语句都省略掉，仅保留循环判断条件表达式时，我们可以省略经典for 循环形式中的分号。也就是说，我们可以将上面的例子写出如下形式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-built_in">println</span>(i)<br>    i++<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这种形式也是我们在日常 Go 编码中经常使用的 for循环语句的第二种形式，也就是除了循环体之外，我们仅保留循环判断条件表达式。特殊的，当for 循环语句的循环判断条件表达式的求值结果始终为 true时，我们就可以将它省略掉了：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123; <br>   <span class="hljs-comment">// 循环体代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>for range 循环</strong></p><p>先来看一个例子。如果我们要使用 for经典形式遍历一个切片中的元素，我们可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, sl[i])<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go 语言提供了一个更方便的“语法糖”形式：forrange。现在我们就来写一个等价于上面代码的 for range 循环：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> sl &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sl[%d] = %d\n&quot;</span>, i, v)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>for range 语句也有几个常见变种</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//不关心值时</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">//只关心值</span><br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><br><span class="hljs-comment">//都不关心</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br><span class="hljs-comment">//or</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> sl &#123;<br>  <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>针对不同数据类型，for range 分析</p><p><strong>string</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d %s 0x%x\n&quot;</span>, i, <span class="hljs-type">string</span>(v), v)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// 0 中 0x4e2d</span><br><span class="hljs-comment">// 3 国 0x56fd</span><br><span class="hljs-comment">// 6 人 0x4eba</span><br></code></pre></div></td></tr></table></figure><p>for range 对于 string 类型来说，每次循环得到的 v 值是一个 Unicode字符码点，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为该Unicode字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置。</p><p><strong>map</strong></p><p>但在 Go 语言中，我们要对 map 进行循环操作，for range 是唯一的方法</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;Rob&quot;</span> : <span class="hljs-number">67</span>,<br>    <span class="hljs-string">&quot;Russ&quot;</span> : <span class="hljs-number">39</span>,<br>    <span class="hljs-string">&quot;John&quot;</span> : <span class="hljs-number">29</span>,<br>&#125;<br><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-built_in">println</span>(k, v)<br>&#125;<br><br><span class="hljs-comment">// John 29</span><br><span class="hljs-comment">// Rob 67</span><br><span class="hljs-comment">// Russ 39</span><br></code></pre></div></td></tr></table></figure><p>每次循环，循环变量 k 和 v 分别会被赋值为 map 键值对集合中一个元素的key 值和 value 值。而且，map 类型中没有下标的概念，通过 key 和 value来循环操作 map 类型变量也就十分自然了。</p><p><strong>channel</strong></p><p>channel 是 Go 语言提供的并发设计的原语，它用于多个 Goroutine之间的通信，在for range 中的用法是下面这样的:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> c &#123;<br>   <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，for range 每次从 channel中读取一个元素后，会把它赋值给循环变量 v，并进入循环体。当 channel中没有数据可读的时候，for range 循环会阻塞在对 channel 的读操作上。直到channel 关闭时，for range 循环才会结束，这也是 for range 循环与 channel配合时隐含的循环判断条件。</p><h3 id="带-label-的-continue-语句">带 label 的 continue 语句</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>    <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 忽略切片中值为偶数的元素</span><br>        <span class="hljs-keyword">continue</span><br>    &#125;<br>    sum += sl[i]<br>&#125;<br><span class="hljs-built_in">println</span>(sum) <span class="hljs-comment">// 9</span><br></code></pre></div></td></tr></table></figure><p>与C语法上的continue并没有很大区别，但是Go 语言中的 continue 在 C 语言continue 语义的基础上又增加了对 label 的支持。</p><p>label 语句的作用，是标记跳转的目标。我们可以把上面的代码改造为使用label 的等价形式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><br>loop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 忽略切片中值为偶数的元素</span><br>            <span class="hljs-keyword">continue</span> loop<br>        &#125;<br>        sum += sl[i]<br>    &#125;<br>    <span class="hljs-built_in">println</span>(sum) <span class="hljs-comment">// 9</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>而带 label 的 continue语句，通常出现于嵌套循环语句中，被用于跳转到外层循环并继续执行外层循环语句的下一个迭代，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == <span class="hljs-number">13</span> &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found 13 at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">continue</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>与goto的区别</strong>：使用goto不管是内层循环还是外层循环都会被终结，代码将会从outerloop 这个 label 处，开始重新执行我们的嵌套循环语句，这与带 label 的continue 的跳转语义是完全不同的。</p><h3 id="break-语句的使用">break 语句的使用</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>&#125;<br>    <span class="hljs-keyword">var</span> firstEven <span class="hljs-type">int</span> = <span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 找出整型切片sl中的第一个偶数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">if</span> sl[i]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            firstEven = sl[i]<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">println</span>(firstEven) <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>一旦找到就不需要继续执行后续迭代了，这个时候我们就通过 break语句跳出了这个循环。</p><p>和 continue 语句一样，Go 也 break 语句增加了对 label的支持。而且，和前面 continue 语句一样，如果遇到嵌套循环，break要想跳出外层循环，用不带 label 的 break 是不够，因为不带 label 的 break仅能跳出其所在的最内层循环。要想实现外层循环的跳出，我们还需给 break加上 label。我们来看一个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> gold = <span class="hljs-number">38</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sl = [][]<span class="hljs-type">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">35</span>, <span class="hljs-number">78</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">45</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">99</span>&#125;,<br>        &#123;<span class="hljs-number">101</span>, <span class="hljs-number">13</span>, <span class="hljs-number">38</span>, <span class="hljs-number">7</span>, <span class="hljs-number">127</span>&#125;,<br>        &#123;<span class="hljs-number">54</span>, <span class="hljs-number">27</span>, <span class="hljs-number">40</span>, <span class="hljs-number">83</span>, <span class="hljs-number">81</span>&#125;,<br>    &#125;<br><br>outerloop:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sl); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(sl[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> sl[i][j] == gold &#123;<br>                fmt.Printf(<span class="hljs-string">&quot;found gold at [%d, %d]\n&quot;</span>, i, j)<br>                <span class="hljs-keyword">break</span> outerloop<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们通过带有 label 的 break语句，就可以直接终结外层循环，从而从复杂多层次的嵌套循环中直接跳出，避免不必要的算力资源的浪费。</p><h3 id="for-语句的常见坑">for 语句的常见“坑”</h3><p><strong>问题一：循环变量的重用</strong> <strong>问题二：参与循环的是range 表达式的副本</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123; <span class="hljs-comment">// 是a的一个值拷贝</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>    &#125;<br>    r[i] = v<br>&#125;<br></code></pre></div></td></tr></table></figure><p>r中记录的还是原来的a，而不是修改后的</p><p>解决方案：使用切片</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a[:] &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        a[<span class="hljs-number">1</span>] = <span class="hljs-number">12</span><br>        a[<span class="hljs-number">2</span>] = <span class="hljs-number">13</span><br>    &#125;<br>    r[i] = v<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当进行 range表达式复制时，我们实际上复制的是一个切片，也就是表示切片的结构体。表示切片副本的结构体中的array，依旧指向原切片对应的底层数组，所以我们对切片副本的修改也都会反映到底层数组a 上去。而 v 再从切片副本结构体中 array指向的底层数组中，获取数组元素，也就得到了被修改后的元素值。</p><p><strong>遍历 map 中元素的随机性</strong></p><p>如果我们在循环的过程中，对 map进行了修改，那么这样修改的结果是否会影响后续迭代呢？这个结果和我们遍历map 一样，具有随机性。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;tony&quot;</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-string">&quot;tom&quot;</span>:  <span class="hljs-number">22</span>,<br>    <span class="hljs-string">&quot;jim&quot;</span>:  <span class="hljs-number">23</span>,<br>&#125;<br><br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;tony&quot;</span>)<br>    &#125;<br>    counter++<br>    fmt.Println(k, v)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;counter is &quot;</span>, counter)<br></code></pre></div></td></tr></table></figure><p>如果我们反复运行这个例子多次，会得到两个不同的结果。当k="tony"作为第一个迭代的元素时，我们将得到如下结果：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">tony <span class="hljs-number">21</span><br>tom <span class="hljs-number">22</span><br>jim <span class="hljs-number">23</span><br>counter is  <span class="hljs-number">3</span><br><br><span class="hljs-comment">//or</span><br><br>tom <span class="hljs-number">22</span><br>jim <span class="hljs-number">23</span><br>counter is  <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>考虑到上述这种随机性，我们日常编码遇到遍历 map 的同时，还需要对 map进行修改的场景的时候，要格外小心。</p><h2 id="switch-语句">switch 语句</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> initStmt; expr &#123;<br>    <span class="hljs-keyword">case</span> expr1:<br>        <span class="hljs-comment">// 执行分支1</span><br>    <span class="hljs-keyword">case</span> expr2:<br>        <span class="hljs-comment">// 执行分支2</span><br>    <span class="hljs-keyword">case</span> expr3_1, expr3_2, expr3_3:<br>        <span class="hljs-comment">// 执行分支3</span><br>    <span class="hljs-keyword">case</span> expr4:<br>        <span class="hljs-comment">// 执行分支4</span><br>    ... ...<br>    <span class="hljs-keyword">case</span> exprN:<br>        <span class="hljs-comment">// 执行分支N</span><br>    <span class="hljs-keyword">default</span>: <br>        <span class="hljs-comment">// 执行默认分支</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在有多个 case 执行分支的 switch 语句中，Go 是按什么次序对各个 case表达式进行求值，并且与 switch 表达式（expr）进行比较的？</p><p>顺序执行，一旦匹配到对应case下面，后面的expr语句变不会执行；</p><p>还有一点，无论 default 分支出现在什么位置，它都只会在所有 case都没有匹配上的情况下才会被执行的。</p><h3 id="switch-语句的灵活性">switch 语句的灵活性</h3><p><strong>switch语句各表达式的求值结果可以为各种类型值，只要它的类型支持比较操作就可以了</strong></p><p><strong>switch 语句支持声明临时变量</strong></p><p><strong>case 语句支持表达式列表</strong></p><p><strong>取消了默认执行下一个 case 代码逻辑的语义</strong></p><p>如果在少数场景下，你需要执行下一个 case 的代码逻辑，你可以显式使用 Go提供的关键字 fallthrough 来实现，这也是 Go“显式”设计哲学的一个体现。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> switchexpr() &#123;<br>    <span class="hljs-keyword">case</span> case1():<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exec case1&quot;</span>)<br>        <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">case</span> case2():<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exec case2&quot;</span>)<br>        <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exec default&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="type-switch">type switch</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">13</span><br>    <span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;x is nil&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of x is int&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of x is string&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of x is string&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;don&#x27;t support the type&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>switch 关键字后面跟着的表达式为x.(type)，这种表达式形式是 switch语句专有的，而且也只能在 switch 语句中使用。这个表达式中的 x必须是一个接口类型变量，表达式的求值结果是这个接口类型变量对应的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">13</span><br>    <span class="hljs-keyword">switch</span> v := x.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;v is nil&quot;</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of v is int, v =&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of v is string, v =&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;the type of v is bool, v =&quot;</span>, v)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;don&#x27;t support the type&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里我们将 switch 后面的表达式由x.(type)换成了v :=x.(type)。对于后者，你千万不要认为变量 v 存储的是类型信息，其实 v存储的是变量 x 的动态类型对应的值信息，这样我们在接下来的 case执行路径中就可以使用变量 v 中的值信息了。</p><h1 id="函数">函数</h1><h2 id="go-函数与函数声明">Go 函数与函数声明</h2><p>函数对应的英文单词是 Function，Function这个单词原本是功能、职责的意思。编程语言使用 Function这个单词，表示将一个大问题分解后而形成的、若干具有特定功能或职责的小任务，可以说十分贴切。函数代表的小任务可以在一个程序中被多次使用，甚至可以在不同程序中被使用，因此函数的出现也提升了整个程序界代码复用的水平。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FuncName</span><span class="hljs-params">(<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, ...)</span></span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, err <span class="hljs-type">error</span>)&#123;<br><span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>第一部分是关键字 func</strong>，Go 函数声明必须以关键字 func开始。</p><p><strong>第二部分是函数名</strong>，函数名是指代函数定义的标识符，函数声明后，我们会通过函数名这个标识符来使用这个函数。在同一个Go 包中，函数名应该是唯一的，并且它也遵守 Go标识符的导出规则，也就是我们之前说的，首字母大写的函数名指代的函数是可以在包外使用的，小写的就只在包内可见。</p><p><strong>第三部分是参数列表</strong>，参数列表中声明了我们将要在函数体中使用的各个参数。参数列表紧接在函数名的后面，并用一个括号包裹。它使用逗号作为参数间的分隔符，而且每个参数的参数名在前，参数类型在后，这和变量声明中变量名与类型的排列方式是一致的。</p><p><strong>第四部分是返回值列表</strong>，返回值承载了函数执行后要返回给调用者的结果，返回值列表声明了这些返回值的类型，返回值列表的位置紧接在参数列表后面，两者之间用一个空格隔开。</p><p><strong>放在一对大括号内的是函数体</strong>函数的具体实现都放在这里。不过，函数声明中的函数体是可选的。如果没有函数体，说明这个函数可能是在Go语言之外实现的，比如使用汇编语言实现，然后通过链接器将实现与声明中的函数名链接到一起。</p><p>等价的变量声明 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> FuncName = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, ...)</span></span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">type</span>, err <span class="hljs-type">error</span>) &#123;&#125;<br></code></pre></div></td></tr></table></figure></p><p>函数声明中的函数名其实就是变量名，函数声明中的 func关键字、参数列表和返回值列表共同构成了函数类型。而参数列表与返回值列表的组合也被称为函数签名，它是决定两个函数类型是否相同的决定因素。因此，函数类型也可以看成是由func 关键字与函数签名组合而成的。</p><p>函数签名 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">type</span>, ...)</span></span> (<span class="hljs-keyword">type</span>, <span class="hljs-type">error</span>)<br></code></pre></div></td></tr></table></figure></p><p>这样，如果两个函数类型的函数签名是相同的，即便参数列表中的参数名，以及返回值列表中的返回值变量名都是不同的，那么这两个函数类型也是相同类型，比如下面两个函数类型：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">string</span>)</span></span> (results []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c <span class="hljs-type">int</span>, d <span class="hljs-type">string</span>)</span></span> (sl []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br></code></pre></div></td></tr></table></figure><p>如果我们把这两个函数类型的参数名与返回值变量名省略，那它们都是func(int, string) ([]string, error)，因此它们是相同的函数类型。</p><p>到这里，我们可以得到这样一个结论：每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例，就像vara int = 13这个变量声明语句中 a 是 int 类型的一个实例一样。</p><p><strong>函数字面值（Function Literal）</strong>函数字面值由函数类型与函数体组成，它特别像一个没有函数名的函数声明，因此我们也叫它匿名函数。</p><h2 id="函数参数">函数参数</h2><p>在函数声明阶段，我们把参数列表中的参数叫做形式参数（Parameter，简称形参），在函数体中，我们使用的都是形参；而在函数实际调用时传入的参数被称为实际参数（Argument，简称实参）。当我们实际调用函数的时候，实参会传递给函数，并和形式参数逐一绑定，编译器会根据各个形参的类型与数量，来检查传入的实参的类型与数量是否匹配。只有匹配，程序才能继续执行函数调用，否则编译器就会报错。</p><p>Go语言中，函数参数传递采用是值传递的方式。所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（BitwiseCopy）到形式参数中。对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。</p><p>但是像 string、切片、map这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“浅拷贝”。</p><p>不过函数参数的传递也有两个例外，当函数的形参为接口类型，或者形参是变长参数时，简单的值传递就不能满足要求了，这时Go 编译器会介入：对于类型为接口类型的形参，Go编译器会把传递的实参赋值给对应的接口类型形参；对于为变长参数的形参，Go编译器会将零个或多个实参按一定形式转换为对应的变长形参。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(sl []<span class="hljs-type">int</span>, elems ...<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, elems) <span class="hljs-comment">// []int</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(elems) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;no elems to append&quot;</span>)<br>        <span class="hljs-keyword">return</span> sl<br>    &#125;<br><br>    sl = <span class="hljs-built_in">append</span>(sl, elems...)<br>    <span class="hljs-keyword">return</span> sl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    sl := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    sl = myAppend(sl) <span class="hljs-comment">// no elems to append</span><br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3]</span><br>    sl = myAppend(sl, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>    fmt.Println(sl) <span class="hljs-comment">// [1 2 3 4 5 6]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们重点看一下代码中的 myAppend 函数，这个函数基于append，实现了向一个整型切片追加数据的功能。它支持变长参数，它的第二个形参elems 就是一个变长参数。myAppend 函数通过 Printf输出了变长参数的类型。执行这段代码，我们将看到变长参数 elems的类型为[]int。这也就说明，在 Go中，变长参数实际上是通过切片来实现的。所以，我们在函数体中，就可以使用切片支持的所有操作来操作变长参数，这会大大简化了变长参数的使用复杂度。比如myAppend 中，我们使用 len 函数就可以获取到传给变长参数的实参个数。</p><h2 id="函数支持多返回值">函数支持多返回值</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>                       <span class="hljs-comment">// 无返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>                 <span class="hljs-comment">// 仅有一个返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>, <span class="hljs-type">error</span>)  <span class="hljs-comment">// 有2或2个以上返回值</span><br></code></pre></div></td></tr></table></figure><p>如果一个函数没有显式返回值，那么我们可以像第一种情况那样，在函数声明中省略返回值列表。而且，如果一个函数仅有一个返回值，那么通常我们在函数声明中，就不需要将返回值用括号括起来，如果是2 个或 2 个以上的返回值，那我们还是需要用括号括起来的</p><p>在函数声明的返回值列表中，我们通常会像上面例子那样，仅列举返回值的类型，但我们也可以像fmt.Fprintf函数的返回值列表那样，为每个返回值声明变量名，这种带有名字的返回值被称为具名返回值（NamedReturnValue）。这种具名返回值变量可以像函数体中声明的局部变量一样在函数体内使用。</p><p>当函数的返回值个数较多时，每次显式使用 return语句时都会接一长串返回值，这时，我们用具名返回值可以让函数实现的可读性更好一些，比如下面Go 标准库 time 包中的 parseNanoseconds 函数就是这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/format.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseNanoseconds</span><span class="hljs-params">(value <span class="hljs-type">string</span>, nbytes <span class="hljs-type">int</span>)</span></span> (ns <span class="hljs-type">int</span>, rangeErrString <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> !commaOrPeriod(value[<span class="hljs-number">0</span>]) &#123;<br>        err = errBad<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns, err = atoi(value[<span class="hljs-number">1</span>:nbytes]); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> ns &lt; <span class="hljs-number">0</span> || <span class="hljs-number">1e9</span> &lt;= ns &#123;<br>        rangeErrString = <span class="hljs-string">&quot;fractional second&quot;</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    scaleDigits := <span class="hljs-number">10</span> - nbytes<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; scaleDigits; i++ &#123;<br>        ns *= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="函数是一等公民">函数是“一等公民”</h2><p>函数在 Go 语言中属于“一等公民（First-Class Citizen）”</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为参数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。<br></code></pre></div></td></tr></table></figure><p><strong>特征一：Go 函数可以存储在变量中</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    myFprintf = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-keyword">return</span> fmt.Fprintf(w, format, a...)<br>    &#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, myFprintf) <span class="hljs-comment">// func(io.Writer, string, ...interface &#123;&#125;) (int, error)</span><br>    myFprintf(os.Stdout, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Hello, Go&quot;</span>) <span class="hljs-comment">// 输出Hello，Go</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这个例子中，我们把新创建的一个匿名函数赋值给了一个名为 myFprintf的变量，通过这个变量，我们便可以调用刚刚定义的匿名函数。然后我们再通过Printf 输出 myFprintf变量的类型，也会发现结果与我们预期的函数类型是相符的。</p><p><strong>特征二：支持在函数内创建并通过返回值返回</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">(task <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some setup stuff for&quot;</span>, task)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some teardown stuff for&quot;</span>, task)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    teardown := setup(<span class="hljs-string">&quot;demo&quot;</span>)<br>    <span class="hljs-keyword">defer</span> teardown()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;do some bussiness stuff&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个例子，模拟了执行一些重要逻辑之前的上下文建立（setup），以及之后的上下文拆除（teardown）。在一些单元测试的代码中，我们也经常会在执行某些用例之前，建立此次执行的上下文（setup），并在这些用例执行后拆除上下文（teardown），避免这次执行对后续用例执行的干扰。我们在setup函数中创建了这次执行的上下文拆除函数，并通过返回值的形式，将这个拆除函数返回给了setup 函数的调用者。setup函数的调用者，在执行完对应这次执行上下文的重要逻辑后，再调用 setup函数返回的拆除函数，就可以完成对上下文的拆除了。</p><p>从这段代码中我们也可以看到，setup函数中创建的拆除函数也是一个匿名函数，但和前面我们看到的匿名函数有一个不同，这个不同就在于这个匿名函数使用了定义它的函数setup 的局部变量 task，这样的匿名函数在 Go中也被称为闭包（Closure）。</p><p><strong>特征三：作为参数传入函数</strong></p><p>既然函数可以存储在变量中，也可以作为返回值返回，那我们可以理所当然地想到，把函数作为参数传入函数也是可行的。比如我们在日常编码时经常使用、标准库time 包的 AfterFunc函数，就是一个接受函数类型参数的典型例子。你可以看看下面这行代码，这里通过AfterFunc 函数设置了一个 2秒的定时器，并传入了时间到了后要执行的函数。这里传入的就是一个匿名函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">time.AfterFunc(time.Second*<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;timer fired&quot;</span>) &#125;)<br></code></pre></div></td></tr></table></figure><p><strong>特征四：拥有自己的类型</strong></p><p>每个函数都和整型值、字符串值等一等公民一样，拥有自己的类型，也就是我们讲过的函数类型。我们甚至可以基于函数类型来自定义类型，就像基于整型、字符串类型等类型来自定义类型一样。下面代码中的HandlerFunc、visitFunc 就是 Go标准库中，基于函数类型进行自定义的类型：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-comment">// $GOROOT/src/sort/genzfunc.go</span><br><span class="hljs-keyword">type</span> visitFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ast.Node)</span></span> ast.Visitor<br></code></pre></div></td></tr></table></figure><h2 id="函数一等公民特性的高效运用">函数“一等公民”特性的高效运用</h2><p><strong>应用一：函数类型的妙用</strong></p><p>Go函数是“一等公民”，也就是说，它拥有自己的类型。而且，整型、字符串型等所有类型都可以进行的操作，比如显式转型，也同样可以用在函数类型上面，也就是说，函数也可以被显式转型。并且，这样的转型在特定的领域具有奇妙的作用，一个最为典型的示例就是标准库http 包中的 HandlerFunc 这个类型。我们来看一个使用了这个类型的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome, Gopher!\n&quot;</span>)<br>&#125;                    <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.HandlerFunc(greeting))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以进行这让转换的前提是，两个函数的函数签名是一致的，这类似与底层类型一直的类之间的相互转换</p><p><strong>应用二：利用闭包简化函数调用</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">times</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x * y<br>&#125;<br><br><br>times(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算2 x 5</span><br>times(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算3 x 5</span><br>times(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 计算4 x 5</span><br></code></pre></div></td></tr></table></figure><p>这是一个简单乘法运算，不过，有些场景存在一些高频使用的乘数，这个时候我们就没必要每次都传入这样的高频乘数了。那我们怎样能省去高频乘数的传入呢?我们看看下面这个新函数 partialTimes：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partialTimes</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> times(x, y)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这里，partialTimes 的返回值是一个接受单一参数的函数，这个由partialTimes 函数生成的匿名函数，使用了 partialTimes 函数的参数x。按照前面的定义，这个匿名函数就是一个闭包。partialTimes实质上就是用来生成以 x为固定乘数的、接受另外一个乘数作为参数的、闭包函数的函数。当程序调用partialTimes(2) 时，partialTimes 实际上返回了一个调用 times(2,y)的函数，这个过程的逻辑类似于下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">timesTwo = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> times(<span class="hljs-number">2</span>, y)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个时候，我们再看看如何使用 partialTimes，分别生成以 2、3、4为固定高频乘数的乘法函数，以及这些生成的乘法函数的使用方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  timesTwo := partialTimes(<span class="hljs-number">2</span>)   <span class="hljs-comment">// 以高频乘数2为固定乘数的乘法函数</span><br>  timesThree := partialTimes(<span class="hljs-number">3</span>) <span class="hljs-comment">// 以高频乘数3为固定乘数的乘法函数</span><br>  timesFour := partialTimes(<span class="hljs-number">4</span>)  <span class="hljs-comment">// 以高频乘数4为固定乘数的乘法函数</span><br>  fmt.Println(timesTwo(<span class="hljs-number">5</span>))   <span class="hljs-comment">// 10，等价于times(2, 5)</span><br>  fmt.Println(timesTwo(<span class="hljs-number">6</span>))   <span class="hljs-comment">// 12，等价于times(2, 6)</span><br>  fmt.Println(timesThree(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 15，等价于times(3, 5)</span><br>  fmt.Println(timesThree(<span class="hljs-number">6</span>)) <span class="hljs-comment">// 18，等价于times(3, 6)</span><br>  fmt.Println(timesFour(<span class="hljs-number">5</span>))  <span class="hljs-comment">// 20，等价于times(4, 5)</span><br>  fmt.Println(timesFour(<span class="hljs-number">6</span>))  <span class="hljs-comment">// 24，等价于times(4, 6)</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="错误处理">错误处理</h2><p>Go函数增加了多返回值机制，来支持错误状态与返回信息的分离，并建议开发者把要返回给调用者的信息和错误状态标识，分别放在不同的返回值中。</p><p>Go标准库中有一个fmt.Fprintf的函数，这个函数就是使用一个独立的表示错误状态的返回值（如下面代码中的err），解决了 fprintf 函数中错误状态值与返回信息耦合在一起的问题：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// fmt包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></div></td></tr></table></figure><p>在 Go 语言中，我们依然可以像传统的 C语言那样，用一个整型值来表示错误状态，但 Go 语言惯用法，是使用 error这个接口类型表示错误，并且按惯例，我们通常将 error类型返回值放在返回值列表的末尾，就像 fmt.Fprintf 函数声明中那样。</p><h3 id="error-类型与错误值构造">error 类型与错误值构造</h3><p>error 接口是 Go 原生内置的类型，它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/builtin/builtin.go</span><br><span class="hljs-keyword">type</span> <span class="hljs-keyword">interface</span> <span class="hljs-type">error</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>任何实现了 error 的 Error 方法的类型的实例，都可以作为错误值赋值给error 接口变量。那这里。error接口的错误值构造：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">err := errors.New(<span class="hljs-string">&quot;your first demo error&quot;</span>)<br>errWithCtx = fmt.Errorf(<span class="hljs-string">&quot;index %d is out of bounds&quot;</span>, i)<br></code></pre></div></td></tr></table></figure><p>这两种方法实际上返回的是同一个实现了 error接口的类型的实例，这个未导出的类型就是errors.errorString，它的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/errors/errors.go</span><br><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>    s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></div></td></tr></table></figure><p>大多数情况下，使用这两种方法构建的错误值就可以满足我们的需求了。但我们也要看到，虽然这两种构建错误值的方法很方便，但它们给错误处理者提供的错误上下文（ErrorContext）只限于以字符串形式呈现的信息，也就是 Error 方法返回的信息。</p><p>但在一些场景下，错误处理者需要从错误值中提取出更多信息，帮助他选择错误处理路径，显然这两种方法就不能满足了。这个时候，我们可以自定义错误类型来满足这一需求。比如：标准库中的net 包就定义了一种携带额外错误上下文的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    Op <span class="hljs-type">string</span><br>    Net <span class="hljs-type">string</span><br>    Source Addr<br>    Addr Addr<br>    Err <span class="hljs-type">error</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，错误处理者就可以根据这个类型的错误值提供的额外上下文信息，比如Op、Net、Source 等，做出错误处理路径的选择，比如下面标准库中的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isCommonNetReadError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == <span class="hljs-string">&quot;read&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="error-类型的好处">error 类型的好处</h3><p><strong>第一点：统一了错误类型</strong></p><p>如果不同开发者的代码、不同项目中的代码，甚至标准库中的代码，都统一以error接口变量的形式呈现错误类型，就能在提升代码可读性的同时，还更容易形成统一的错误处理策略。</p><p><strong>第二点：错误是值</strong></p><p>我们构造的错误都是值，也就是说，即便赋值给 error这个接口类型变量，我们也可以像整型值那样对错误做“==”和“!=”的逻辑比较，函数调用者检视错误时的体验保持不变。</p><p><strong>第三点：易扩展，支持自定义错误上下文。</strong></p><p>虽然错误以 error接口变量的形式统一呈现，但我们很容易通过自定义错误类型来扩展我们的错误上下文，就像前面的Go 标准库的 OpError 类型那样。error接口是错误值的提供者与错误值的检视者之间的契约。error接口的实现者负责提供错误上下文，供负责错误处理的代码使用。这种错误具体上下文与作为错误值类型的error 接口类型的解耦，也体现了 Go 组合设计哲学中“正交”的理念。</p><h3 id="error-设计策略">error 设计策略</h3><p><strong>策略一：透明错误处理策略</strong></p><p>简单来说，Go 语言中的错误处理，就是根据函数 / 方法返回的 error类型变量中携带的错误值信息做决策，并选择后续代码执行路径的过程。这样，最简单的错误策略莫过于完全不关心返回错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">err := doSomething()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 不关心err变量底层错误值所携带的具体上下文信息</span><br>    <span class="hljs-comment">// 执行简单错误处理逻辑并返回</span><br>    ... ...<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这也是 Go 语言中最常见的错误处理策略，80% 以上的 Go错误处理情形都可以归类到这种策略下。在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造方（如上面的函数doSomething）可以直接使用Go标准库提供的两个基本错误值构造方法errors.New和fmt.Errorf来构造错误值，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(...)</span></span> <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;some error occurred&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样构造出的错误值代表的上下文信息，对错误处理方是透明的，因此这种策略称为“透明错误处理策略”。在错误处理方不关心错误值上下文的前提下，透明错误处理策略能最大程度地减少错误处理方与错误值构造方之间的耦合关系。</p><p><strong>策略二：“哨兵”错误处理策略</strong></p><p>当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的反模式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err.Error() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: negative count&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: buffer full&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简单来说，反模式就是，错误处理方以透明错误值所能提供的唯一上下文信息（描述错误的字符串），作为错误处理路径选择的依据。但这种“反模式”会造成严重的隐式耦合。这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。</p><p>那这有什么办法吗？Go标准库采用了定义导出的（Exported）“哨兵”错误值的方式，来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策，比如下面的bufio 包中定义的“哨兵错误”：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/bufio/bufio.go</span><br><span class="hljs-keyword">var</span> (<br>    ErrInvalidUnreadByte = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadByte&quot;</span>)<br>    ErrInvalidUnreadRune = errors.New(<span class="hljs-string">&quot;bufio: invalid use of UnreadRune&quot;</span>)<br>    ErrBufferFull        = errors.New(<span class="hljs-string">&quot;bufio: buffer full&quot;</span>)<br>    ErrNegativeCount     = errors.New(<span class="hljs-string">&quot;bufio: negative count&quot;</span>)<br>)<br></code></pre></div></td></tr></table></figure><p>下面的代码片段利用了上面的哨兵错误，进行错误处理分支的决策：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">data, err := b.Peek(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">switch</span> err &#123;<br>    <span class="hljs-keyword">case</span> bufio.ErrNegativeCount:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrBufferFull:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">case</span> bufio.ErrInvalidUnreadByte:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// ... ...</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到，一般“哨兵”错误值变量以 ErrXXX格式命名。和透明错误策略相比，“哨兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。不过，对于API 的开发者而言，暴露“哨兵”错误值也意味着这些错误值和包的公共函数 /方法一起成为了 API的一部分。一旦发布出去，开发者就要对它进行很好的维护。而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。</p><p>从 Go 1.13 版本开始，标准库 errors 包提供了 Is函数用于错误处理方对错误值的检视。Is 函数类似于把一个 error类型变量与“哨兵”错误值进行比较，比如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if err == ErrOutOfBounds&#123; … &#125;</span><br><span class="hljs-keyword">if</span> errors.Is(err, ErrOutOfBounds) &#123;<br>    <span class="hljs-comment">// 越界的错误处理</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>不同的是，如果 error 类型变量的底层错误值是一个包装错误（WrappedError），errors.Is 方法会沿着该包装错误所在错误链（ErrorChain)，与链上所有被包装的错误（WrappedError）进行比较，直至找到一个匹配的错误为止。下面是 Is函数应用的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ErrSentinel = errors.New(<span class="hljs-string">&quot;the underlying sentinel error&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap sentinel: %w&quot;</span>, ErrSentinel)<br>err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br><span class="hljs-built_in">println</span>(err2 == ErrSentinel) <span class="hljs-comment">//false</span><br><span class="hljs-keyword">if</span> errors.Is(err2, ErrSentinel) &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is ErrSentinel&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br> <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;err2 is not ErrSentinel&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果你使用的是 Go 1.13及后续版本，建议尽量使用errors.Is方法去检视某个错误值是否就是某个预期错误值，或者包装了某个特定的“哨兵”错误值。</p><p><strong>策略三：错误值类型检视策略</strong></p><p>基于 Go标准库提供的错误值构造方法构造的“哨兵”错误值，除了让错误处理方可以“有的放矢”的进行值比较之外，并没有提供其他有效的错误上下文信息。那如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理策略和错误值构造方式都无法满足。这种情况下，我们需要通过自定义错误类型的构造错误值的方式，来提供更多的“错误上下文”信息。并且，由于错误值都通过error接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用Go 提供的类型断言机制（Type Assertion）或类型选择机制（TypeSwitch），这种错误处理方式，我称之为错误值类型检视策略。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-keyword">type</span> UnmarshalTypeError <span class="hljs-keyword">struct</span> &#123;<br>    Value  <span class="hljs-type">string</span>       <br>    Type   reflect.Type <br>    Offset <span class="hljs-type">int64</span>        <br>    Struct <span class="hljs-type">string</span>       <br>    Field  <span class="hljs-type">string</span>      <br>&#125;<br></code></pre></div></td></tr></table></figure><p>错误处理方可以通过错误类型检视策略，获得更多错误值的错误上下文信息，下面就是利用这一策略的json 包的一个方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/encoding/json/decode.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *decodeState)</span></span> addErrorContext(err <span class="hljs-type">error</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> d.errorContext.Struct != <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(d.errorContext.FieldStack) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-keyword">case</span> *UnmarshalTypeError:<br>            err.Struct = d.errorContext.Struct.Name()<br>            err.Field = strings.Join(d.errorContext.FieldStack, <span class="hljs-string">&quot;.&quot;</span>)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，这段代码通过类型 switch 语句得到了 err变量代表的动态类型和值，然后在匹配的 case分支中利用错误上下文信息进行处理。这里，一般自定义导出的错误类型以XXXError的形式命名。和“哨兵”错误处理策略一样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数/ 方法一起，成为了 API的一部分。一旦发布出去，开发者就要对它们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖</p><p>从 Go 1.13 版本开始，标准库 errors包提供了As函数给错误处理方检视错误值。As函数类似于通过类型断言判断一个error 类型变量是否为特定的自定义错误类型，如下面代码所示：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 类似 if e, ok := err.(*MyError); ok &#123; … &#125;</span><br><span class="hljs-keyword">var</span> e *MyError<br><span class="hljs-keyword">if</span> errors.As(err, &amp;e) &#123;<br>    <span class="hljs-comment">// 如果err类型为*MyError，变量e将被设置为对应的错误值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>    e <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MyError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> err = &amp;MyError&#123;<span class="hljs-string">&quot;MyError error demo&quot;</span>&#125;<br>    err1 := fmt.Errorf(<span class="hljs-string">&quot;wrap err: %w&quot;</span>, err)<br>    err2 := fmt.Errorf(<span class="hljs-string">&quot;wrap err1: %w&quot;</span>, err1)<br>    <span class="hljs-keyword">var</span> e *MyError<br>    <span class="hljs-keyword">if</span> errors.As(err2, &amp;e) &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is on the chain of err2&quot;</span>)<br>        <span class="hljs-built_in">println</span>(e == err)                  <br>        <span class="hljs-keyword">return</span>                             <br>    &#125;                                      <br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;MyError is not on the chain of err2&quot;</span>)<br>&#125; <br></code></pre></div></td></tr></table></figure><p>errors.As函数会沿着该包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错误类型，就像errors.Is 函数那样。</p><p>errors.As函数沿着 err2所在错误链向下找到了被包装到最深处的错误值，并将 err2 与其类型 *MyError成功匹配。匹配成功后，errors.As 会将匹配到的错误值存储到 As函数的第二个参数中，这也是为什么println(e == err)输出 true 的原因。</p><p>如果你使用的是 Go 1.13及后续版本，请尽量使用errors.As方法去检视某个错误值是否是某自定义错误类型的实例</p><p><strong>策略四：错误行为特征检视策略</strong></p><p>在 Go标准库中，我们发现了这样一种错误处理方式：将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中。这种方式也被叫做错误行为特征检视策略。</p><p>以标准库中的net包为例，它将包内的所有错误类型的公共行为特征抽象并放入net.Error这个接口中，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> Error <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">error</span><br>    Timeout() <span class="hljs-type">bool</span>  <br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，net.Error 接口包含两个用于判断错误行为特征的方法：Timeout用来判断是否是超时（Timeout）错误，Temporary用于判断是否是临时（Temporary）错误。而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并根据这些信息做出后续错误处理分支选择的决策。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/http/server.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, e := l.Accept()<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> &lt;-srv.getDoneChan():<br>                <span class="hljs-keyword">return</span> ErrServerClosed<br>            <span class="hljs-keyword">default</span>:<br>            &#125;<br>            <span class="hljs-keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;<br>                <span class="hljs-comment">// 注：这里对临时性(temporary)错误进行处理</span><br>                ... ...<br>                time.Sleep(tempDelay)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> e<br>        &#125;<br>        ...<br>    &#125;<br>    ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面代码中，Accept方法实际上返回的错误类型为<code>*OpError</code>，它是 net包中的一个自定义错误类型，它实现了错误公共特征接口net.Error，如下代码所示：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/net/net.go</span><br><span class="hljs-keyword">type</span> OpError <span class="hljs-keyword">struct</span> &#123;<br>    ... ...<br>    <span class="hljs-comment">// Err is the error that occurred during the operation.</span><br>    Err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>    Temporary() <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *OpError)</span></span> Temporary() <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">if</span> ne, ok := e.Err.(*os.SyscallError); ok &#123;<br>      t, ok := ne.Err.(temporary)<br>      <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>  &#125;<br>  t, ok := e.Err.(temporary)<br>  <span class="hljs-keyword">return</span> ok &amp;&amp; t.Temporary()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>因此，OpError实例可以被错误处理方通过net.Error接口的方法，判断它的行为是否满足Temporary 或 Timeout 特征。</p><p>在错误处理策略选择上： *请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合； *如果可以通过错误值类型的特征进行错误检视，那么请尽量使用“错误行为特征检视策略”;*在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略；* Go 1.13及后续版本中，尽量用errors.Is和errors.As函数替换原先的错误检视比较语句。</p><h2 id="go-语言中的异常">Go 语言中的异常</h2><h3 id="函数健壮性设计原则">函数健壮性设计原则</h3><p>原则一：不要相信任何外部输入的参数。</p><p>原则二：不要忽略任何一个错误。</p><p>原则三：不要假定异常不会发生。</p><h3 id="认识-go-语言中的异常panic">认识 Go 语言中的异常：panic</h3><p>panic 指的是 Go程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go程序的执行就会被终止，即便出现异常的位置不在主 Goroutine中也会这样。</p><p>在 Go 中，panic 主要有两类来源，一类是来自 Go 运行时，另一类则是 Go开发人员通过 panic 函数主动触发的。无论是哪种，一旦 panic 被触发，后续Go 程序的执行过程都是一样的，这个过程被 Go 语言称为 panicking。</p><p>Go 官方文档以手工调用 panic 函数触发 panic 为例，对 panicking这个过程进行了诠释：当函数 F 调用 panic 函数时，函数 F的执行将停止。不过，函数 F 中已进行求值的 deferred函数都会得到正常执行，执行完这些 deferred 函数后，函数 F才会把控制权返还给其调用者。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call foo&quot;</span>)<br>    bar()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit foo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zoo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call zoo&quot;</span>)<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit zoo&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call main&quot;</span>)<br>    foo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit main&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面这个例子中，从 Go 应用入口开始，函数的调用次序依次为main -&gt;foo -&gt; bar -&gt; zoo。在 bar 函数中，我们调用 panic 函数手动触发了panic。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">call</span> main<br><span class="hljs-keyword">call</span> foo<br><span class="hljs-keyword">call</span> <span class="hljs-built_in">bar</span><br>panic: panic occurs in <span class="hljs-built_in">bar</span><br></code></pre></div></td></tr></table></figure><p>从 main 函数的视角来看，这就好比将它对 foo 函数的调用，换成了对 panic函数的调用一样。结果就是，main函数的执行也被终止了，于是整个程序异常退出，日志"exitmain"也没有得到输出的机会。不过，Go 也提供了捕捉 panic并恢复程序正常执行秩序的方法，我们可以通过 recover函数来实现这一点。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> e := <span class="hljs-built_in">recover</span>(); e != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;recover the panic:&quot;</span>, e)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;call bar&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic occurs in bar&quot;</span>)<br>    zoo()<br>    <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;exit bar&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>recover 是 Go 内置的专门用于恢复 panic 的函数，它必须被放在一个 defer函数中才能生效。如果 recover 捕捉到 panic，它就会返回以 panic的具体内容为错误上下文信息的错误值。如果没有 panic 发生，那么 recover将返回 nil。而且，如果 panic 被 recover 捕捉到，panic 引发的 panicking过程就会停止。</p><h3 id="如何应对-panic">如何应对 panic？</h3><ul><li>第一点：评估程序对 panic的忍受度，不同应用对异常引起的程序崩溃退出的忍受度是不一样的。比如，一个单次运行于控制台窗口中的命令行交互类程序（CLI），和一个常驻内存的后端HTTP服务器程序，对异常崩溃的忍受度就是不同的。前者即便因异常崩溃，对用户来说也仅仅是再重新运行一次而已。但后者一旦崩溃，就很可能导致整个网站停止服务。所以，针对各种应用对panic 忍受度的差异，我们采取的应对 panic 的策略也应该有不同。</li><li>第二点：提示潜在 bug。C 语言中有个很好用的辅助函数，断言（assert宏）。在使用 C编写代码时，我们经常在一些代码执行路径上，使用断言来表达这段执行路径上某种条件一定为真的信心。断言为真，则程序处于正确运行状态，断言为否就是出现了意料之外的问题，而这个问题很可能就是一个潜在的bug，这时我们可以借助断言信息快速定位到问题所在。</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-comment">// $GOROOT/src/encoding/json/encode.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *reflectWithString)</span></span> resolve() <span class="hljs-type">error</span> &#123;<br>    ... ...<br>    <span class="hljs-keyword">switch</span> w.k.Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<br>        w.ks = strconv.FormatInt(w.k.Int(), <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br>        w.ks = strconv.FormatUint(w.k.Uint(), <span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unexpected map key type&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们也看到，去掉这行代码并不会对resolve方法的逻辑造成任何影响，但真正出现问题时，开发人员就缺少了“断言”潜在bug 提醒的辅助支持了。在 Go 标准库中，大多数 panic的使用都是充当类似断言的作用的。</p><ul><li>第三点：不要混淆异常与错误。在日常编码中，我经常会看到一些 Go语言初学者，尤其是一些有过 Java 语言编程经验的程序员，会因为习惯了 Java那种基于try-catch-finally的错误处理思维，而将 Go panic 当成 Java的“checked exception”去用，这显然是混淆了 Go 中的异常与错误，这是 Go错误处理的一种反模式。在 Go 中，作为 API 函数的作者，你一定不要将 panic当作错误返回给 API 调用者。</li></ul><h2 id="使用-defer-简化函数实现">使用 defer 简化函数实现</h2><p>对函数设计来说，如何实现简洁的目标是一个大话题。你可以从通用的设计原则去谈，比如函数要遵守单一职责，职责单一的函数肯定要比担负多种职责的函数更简单。你也可以从函数实现的规模去谈，比如函数体的规模要小，尽量控制在80 行代码之内等。但我们这个是 Go 语言的课程，所以我们的角度更侧重于 Go中是否有现成的语法元素，可以帮助我们简化 Go函数的设计和实现。我也把答案剧透给你，有的，它就是 defer。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br><br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    err = doWithResources() <br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        r3.Close()<br>        r2.Close()<br>        r1.Close()<br>        mu.Unlock()<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    r3.Close()<br>    r2.Close()<br>    r1.Close()<br>    mu.Unlock()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，这类代码的特点就是在函数中会申请一些资源，并在函数退出前释放或关闭这些资源，比如这里的互斥锁mu 以及资源 r1~r3 就是这样。</p><p>函数的实现需要确保，无论函数的执行流是按预期顺利进行，还是出现错误，这些资源在函数退出时都要被及时、正确地释放。为此，我们需要尤为关注函数中的错误处理，在错误处理时不能遗漏对资源的释放。</p><p>但这样的要求，就导致我们在进行资源释放，尤其是有多个资源需要释放的时候，比如上面示例那样，会大大增加开发人员的心智负担。同时当待释放的资源个数较多时，整个代码逻辑就会变得十分复杂，程序可读性、健壮性也会随之下降。但即便如此，如果函数实现中的某段代码逻辑抛出panic，传统的错误处理机制依然没有办法捕获它并尝试从 panic 恢复。</p><p>defer 是 Go 语言提供的一种延迟调用机制，defer的运作离不开函数。怎么理解呢？这句话至少有以下两点含义： * 在 Go中，只有在函数（和方法）内部才能使用 defer； * defer关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。defer将它们注册到其所在 Goroutine 中，用于存放 deferred函数的栈数据结构中，这些 deferred 函数将在执行 defer的函数退出前，按后进先出（LIFO）的顺序被程序调度执行</p><p>而且，无论是执行到函数体尾部返回，还是在某个错误处理分支显式return，又或是出现 panic，已经存储到 deferred函数栈中的函数，都会被调度执行。所以说，deferred函数是一个可以在任何情况下为函数进行收尾工作的好“伙伴”。</p><p>刚才那个例子可以改成</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">var</span> mu sync.Mutex<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br><br>    r1, err := OpenResource1()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r1.Close()<br><br>    r2, err := OpenResource2()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r2.Close()<br><br>    r3, err := OpenResource3()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> r3.Close()<br><br>    <span class="hljs-comment">// 使用r1，r2, r3</span><br>    <span class="hljs-keyword">return</span> doWithResources() <br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们看到，使用 defer后对函数实现逻辑的简化是显而易见的。而且，这里资源释放函数的 defer注册动作，紧邻着资源申请成功的动作，这样成对出现的惯例就极大降低了遗漏资源释放的可能性，我们开发人员也不用再小心翼翼地在每个错误处理分支中检查是否遗漏了某个资源的释放动作。同时，代码的简化也意味代码可读性的提高，以及代码健壮度的增强。</p><h3 id="defer-使用的几个注意事项">defer 使用的几个注意事项</h3><ul><li>第一点：明确哪些函数可以作为 deferred函数。对于自定义的函数或方法，defer可以给与无条件的支持，但是对于有返回值的自定义函数或方法，返回值会在deferred函数被调度执行的时候被自动丢弃。append、cap、len、make、new、imag等内置函数都是不能直接作为 deferred 函数的，而close、copy、delete、print、recover 等内置函数则可以直接被 defer 设置为deferred 函数。</li><li>第二点：注意 defer 关键字后面表达式的求值时机。defer关键字后面的表达式，是在将 deferred 函数注册到 deferred函数栈的时候进行求值的。</li><li>第三点：知晓 defer 带来的性能损耗。在 Go 1.13 前的版本中，defer带来的开销还是很大的。使用 defer 的函数的执行时间是没有使用 defer 函数的8 倍左右。但从 Go 1.13 版本开始，Go 核心团队对 defer性能进行了多次优化，到现在的 Go 1.17 版本，defer的开销已经足够小了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-复合类型</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="数组类型">数组类型</h1><p>Go语言的数组是一个长度固定的、由同构类型元素组成的连续序列。通过这个定义，我们可以识别出Go的数组类型包含两个重要属性：元素的类型和数组长度（元素的个数）。这两个属性也直接构成了Go 语言中数组类型变量的声明：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [N]T<br></code></pre></div></td></tr></table></figure><p>如果两个数组类型的元素类型 T 与数组长度 N都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(arr [5]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> arr3 [<span class="hljs-number">5</span>]<span class="hljs-type">string</span><br><br>    foo(arr1) <span class="hljs-comment">// ok</span><br>    foo(arr2) <span class="hljs-comment">// 错误：[6]int与函数foo参数的类型[5]int不是同一数组类型</span><br>    foo(arr3) <span class="hljs-comment">// 错误：[5]string与函数foo参数的类型[5]int不是同一数组类型</span><br>&#125;  <br></code></pre></div></td></tr></table></figure><p>数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。Go编译器在为数组类型的变量实际分配内存时，会为 Go数组分配一整块、可以容纳它所有元素的连续内存。</p><p>从这个数组类型的内存表示中可以看出来，这块内存全部空间都被用来表示数组元素，所以说这块内存的大小，就等于各个数组元素的大小之和。如果两个数组所分配的内存大小不同，那么它们肯定是不同的数组类型。Go提供了预定义函数 <code>len</code>可以用于获取一个数组类型变量的长度，通过 <code>unsafe</code> 包提供的<code>Sizeof</code>函数，我们可以获得一个数组变量的总大小，如下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;数组长度：&quot;</span>, <span class="hljs-built_in">len</span>(arr))           <span class="hljs-comment">// 6</span><br>fmt.Println(<span class="hljs-string">&quot;数组大小：&quot;</span>, unsafe.Sizeof(arr)) <span class="hljs-comment">// 6 * 8 = 48</span><br></code></pre></div></td></tr></table></figure><p>和基本数据类型一样，我们声明一个数组类型变量的同时，也可以显式地对它进行初始化。我们需要在右值中显式放置数组类型，并通过大括号的方式给各个元素赋值（如下面代码中的arr2）。如果不进行显式初始化，那么数组中的元素值就是它类型的零值。我们也可以忽略掉右值初始化表达式中数组类型的长度，用“…”替代，Go编译器会根据数组元素的个数，自动计算出数组长度。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// [0 0 0 0 0 0]</span><br><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">6</span>]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>,<br>&#125; <span class="hljs-comment">// [11 12 13 14 15 16]</span><br><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-type">int</span> &#123; <br>    <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>,<br>&#125; <span class="hljs-comment">// [21 22 23]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr3) <span class="hljs-comment">// [3]int</span><br><br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-number">99</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">// 将第100个元素(下标值为99)的值赋值为39，其余元素值均为0</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, arr4) <span class="hljs-comment">// [100]int</span><br></code></pre></div></td></tr></table></figure><h1 id="多维数组">多维数组</h1><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mArr [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-type">int</span><br></code></pre></div></td></tr></table></figure><p>多维数组也不难理解，我们以上面示例中的多维数组类型为例，我们从左向右逐维地去看，这样我们就可以将一个多维数组分层拆解成这样</p><p><img src="/page/2022-05/mArr.png" /></p><p>虽然数组类型是 Go语言中最基础的复合数据类型，但是在使用中它也会有一些问题。数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。这点与C 语言完全不同，在 C语言中，数组变量可视为指向数组第一个元素的指针。这样一来，无论是参与迭代，还是作为实际参数传给一个函数/ 方法，Go传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。虽然可以使用指针的方式，来向函数传递数组，但这样做的确可以避免性能损耗，但这更像是C 语言的惯用法。其实，Go 语言为我们提供了一种更为灵活、更为地道的方式，切片，来解决这个问题。它的优秀特性让它成为了 Go语言中最常用的同构复合类型。</p><h1 id="切片">切片</h1><p>初始化切片</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br></code></pre></div></td></tr></table></figure><p>与数组声明相比，切片声明仅仅是少了一个“长度”属性。去掉“长度”这一束缚后，切片展现出更为灵活的特性，这些特性我们后面再分析。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 6</span><br><br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-number">7</span>) <span class="hljs-comment">// 切片变为[1 2 3 4 5 6 7]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure><p>上面代码，表示的是通过len获取切片长度，通过append追加7到切片后面，长度也会对应变化。</p><h2 id="切片的底层实现">切片的底层实现</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>    array unsafe.Pointer<br>    <span class="hljs-built_in">len</span>   <span class="hljs-type">int</span><br>    <span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每个切片包含三个字段：</p><ul><li>array: 是指向底层数组的指针；</li><li>len: 是切片的长度，即切片中当前元素的个数；</li><li>cap: 是底层数组的长度，也是切片的最大容量，cap 值永远大于等于 len值。</li></ul><h3 id="其他切片的创建方式">其他切片的创建方式</h3><p><strong>方法一：通过 make函数来创建切片，并指定底层数组的长度。</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">sl := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 其中10为cap值，即底层数组长度，6为切片的初始长度</span><br></code></pre></div></td></tr></table></figure><p>如果没有在 make 中指定 cap 参数，那么底层数组长度 cap 就等于 len</p><p><strong>方法二：采用 array[low : high :max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">arr := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>sl := arr[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>:<span class="hljs-number">9</span>]<br></code></pre></div></td></tr></table></figure><p>我们基于数组 arr 创建了一个切片 sl，这个切片 sl在运行时中的表示是这样</p><p><img src="/page/2022-05/slice.png" /></p><p>我们看到，基于数组创建的切片，它的起始元素从 low所标识的下标值开始，切片的长度（len）是 high - low，它的容量是 max -low。而且，由于切片 sl 的底层数组就是数组 arr，对切片 sl中元素的修改将直接影响数组 arr 变量。比如，如果我们将切片的第一个元素加10，那么数组 arr 的第四个元素将变为 14。</p><p>切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。这有些类似于我们操作文件之前打开的“文件描述符”（Windows上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。可以说，切片之于数组就像是文件描述符之于文件。</p><p>针对一个已存在的数组，我们还可以建立多个操作数组的切片，这些切片共享同一底层数组，切片对底层数组的操作也同样会反映到其他切片中。</p><p><strong>方法三：基于切片创建切片</strong></p><p>这种切片的运行时表示原理与上面的是一样的</p><h2 id="切片的动态扩容">切片的动态扩容</h2><p>“动态扩容”指的就是，当我们通过 append操作向切片追加数据的时候，如果这时切片的 len 值和 cap值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。前面的切片变量nums 之所以可以存储下新追加的值，就是因为 Go对其进行了动态扩容，也就是重新分配了其底层数组，从一个长度为 6的数组变成了一个长为 12 的数组。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">11</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//1 1</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">12</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//2 2</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">13</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//3 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">14</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//4 4</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">15</span>) <br>fmt.Println(<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s)) <span class="hljs-comment">//5 8</span><br></code></pre></div></td></tr></table></figure><p>append操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">u := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;array:&quot;</span>, u) <span class="hljs-comment">// [11, 12, 13, 14, 15]</span><br>s := u[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s) <span class="hljs-comment">// [12, 13]</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">24</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 24, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 24, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">25</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 25, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 25, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">26</span>)<br>fmt.Println(<span class="hljs-string">&quot;after append 26, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after append 26, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">22</span><br>fmt.Println(<span class="hljs-string">&quot;after reassign 1st elem of slice, array:&quot;</span>, u)<br>fmt.Printf(<span class="hljs-string">&quot;after reassign 1st elem of slice, slice(len=%d, cap=%d): %v\n&quot;</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s), s)<br></code></pre></div></td></tr></table></figure><p>运行这段代码，我们得到这样的结果</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br><span class="hljs-keyword">slice</span>(len=<span class="hljs-number">2</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">24</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">15</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">24</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">3</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">25</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">25</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">4</span>, cap=<span class="hljs-number">4</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">26</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> append <span class="hljs-number">26</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">5</span>, cap=<span class="hljs-number">8</span>): [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]<br><span class="hljs-keyword">after</span> <span class="hljs-keyword">reassign</span> <span class="hljs-number">1</span>st elem <span class="hljs-keyword">of</span> <span class="hljs-keyword">slice</span>, <span class="hljs-keyword">array</span>: [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]<br><span class="hljs-keyword">after</span> <span class="hljs-keyword">reassign</span> <span class="hljs-number">1</span>st elem <span class="hljs-keyword">of</span> <span class="hljs-keyword">slice</span>, <span class="hljs-keyword">slice</span>(len=<span class="hljs-number">5</span>, cap=<span class="hljs-number">8</span>): [<span class="hljs-number">22</span> <span class="hljs-number">13</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]<br></code></pre></div></td></tr></table></figure><p>这里，在 append 25 之后，切片的元素已经触碰到了底层数组 u的边界了。然后我们再 append 26 之后，append 发现底层数组已经无法满足append 的要求，于是新创建了一个底层数组（数组长度为 cap(s) 的 2 倍，即8），并将 slice 的元素拷贝到新数组中了。</p><p>在这之后，我们即便再修改切片的第一个元素值，原数组 u的元素也不会发生改变了，因为这个时候切片 s 与数组 u已经解除了“绑定关系”，s 已经不再是数组 u的“描述符”了。这种因切片的自动扩容而导致的“绑定关系”解除，有时候会成为实践道路上的一个小陷阱，一定要注意这一点。</p><h1 id="map-类型">Map 类型</h1><p>map 是 Go语言提供的一种抽象数据类型，它表示一组无序的键值对。在后面的讲解中，我们会直接使用key 和 value 分别代表 map 的键和值。而且，map 集合中每个 key都是唯一的。和切片类似，作为复合类型的 map，它在 Go 中的类型表示也是由key 类型与 value 类型组成的，就像下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[key_type]value_type<br></code></pre></div></td></tr></table></figure><p>这里，我们要注意，map 类型对 value 的类型没有限制，但是对 key的类型却有严格要求，因为 map 类型要保证 key 的唯一性。Go 语言中要求，key的类型必须支持<code>==</code>和<code>!=</code>两种比较操作符。</p><p>在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil的比较，而不支持同类型两个变量的比较。如果像下面代码这样，进行这些类型的比较，Go编译器将会报错：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br><span class="hljs-built_in">println</span>(s1 == s2) <span class="hljs-comment">// 错误：invalid operation: s1 == s2 (slice can only be compared to nil)</span><br><span class="hljs-built_in">println</span>(f1 == f2) <span class="hljs-comment">// 错误：invalid operation: f1 == f2 (func can only be compared to nil)</span><br><span class="hljs-built_in">println</span>(m1 == m2) <span class="hljs-comment">// 错误：invalid operation: m1 == m2 (map can only be compared to nil)</span><br></code></pre></div></td></tr></table></figure><p>因此在这里，你一定要注意：函数类型、map类型自身，以及切片类型是不能作为 map 的 key 类型的。</p><h2 id="map-变量的声明和初始化">map 变量的声明和初始化</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 一个map[string]int类型的变量</span><br></code></pre></div></td></tr></table></figure><p>和切片类型变量一样，如果我们没有显式地赋予 map 变量初值，map类型变量的默认值为 nil。不过切片变量和 map变量在这里也有些不同。初值为零值 nil 的切片类型变量，可以借助内置的append 的函数进行操作，这种在 Go 语言中被称为“零值可用”。但 map类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的map变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// m = nil</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-number">1</span>         <span class="hljs-comment">// 发生运行时异常：panic: assignment to entry in nil map</span><br></code></pre></div></td></tr></table></figure><p>为 map类型变量显式赋值有两种方式：一种是使用复合字面值；另外一种是使用 make这个预声明的内置函数。</p><p><strong>方法一：使用复合字面值初始化 map 类型变量。</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>这里，我们显式初始化了 map 类型变量 m。不过，你要注意，虽然此时 map类型变量 m 中没有任何键值对，但变量 m 也不等同于初值为 nil 的 map变量。这个时候，我们对 m 进行键值对的插入操作，不会引发运行时异常。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-number">1</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val1_1&quot;</span>, <span class="hljs-string">&quot;val1_2&quot;</span>&#125;,<br>    <span class="hljs-number">3</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val3_1&quot;</span>, <span class="hljs-string">&quot;val3_2&quot;</span>, <span class="hljs-string">&quot;val3_3&quot;</span>&#125;,<br>    <span class="hljs-number">7</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;val7_1&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">type</span> Position <span class="hljs-keyword">struct</span> &#123; <br>    x <span class="hljs-type">float64</span> <br>    y <span class="hljs-type">float64</span><br>&#125;<br><br>m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    Position&#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    Position&#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    Position&#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go 还提供了“语法糖”。这种情况下，Go 允许省略字面值中的元素类型。因为map 类型表示中包含了 key 和 value 的元素类型，Go编译器已经有足够的信息，来推导出字面值中各个值的类型了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m2 := <span class="hljs-keyword">map</span>[Position]<span class="hljs-type">string</span>&#123;<br>    &#123;<span class="hljs-number">29.935523</span>, <span class="hljs-number">52.568915</span>&#125;: <span class="hljs-string">&quot;school&quot;</span>,<br>    &#123;<span class="hljs-number">25.352594</span>, <span class="hljs-number">113.304361</span>&#125;: <span class="hljs-string">&quot;shopping-mall&quot;</span>,<br>    &#123;<span class="hljs-number">73.224455</span>, <span class="hljs-number">111.804306</span>&#125;: <span class="hljs-string">&quot;hospital&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>方法二：使用 make 为 map类型变量进行显式初始化。</strong></p><p>和切片通过 make 进行初始化一样，通过 make 的初始化方式，我们可以为map类型变量指定键值对的初始容量，但无法进行具体的键值对赋值，就像下面代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>) <span class="hljs-comment">// 未指定初始容量</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 指定初始容量为8</span><br></code></pre></div></td></tr></table></figure><p>map类型的容量不会受限于它的初始容量值，当其中的键值对数量超过初始容量后，Go运行时会自动增加 map 类型的容量，保证后续键值对的正常插入。</p><h2 id="map-基本操作">Map 基本操作</h2><p><strong>操作一：插入新键值对。</strong></p><p>面对一个非 nil 的 map 类型变量，我们可以在其中插入符合 map类型定义的任意新键值对。插入新键值对的方式很简单，我们只需要把 value赋值给 map 中对应的 key 就可以了：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value1&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;value2&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;value3&quot;</span><br></code></pre></div></td></tr></table></figure><p>不过，如果我们插入新键值对的时候，某个 key 已经存在于 map中了，那我们的插入操作就会用新值覆盖旧值：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>m[<span class="hljs-string">&quot;key1&quot;</span>] = <span class="hljs-number">11</span> <span class="hljs-comment">// 11会覆盖掉&quot;key1&quot;对应的旧值1</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment">// 此时m为map[key1:11 key2:2 key3:3]</span><br></code></pre></div></td></tr></table></figure><p><strong>操作二：获取键值对数量。</strong></p><p>和切片一样，map 类型也可以通过内置函数len，获取当前变量已经存储的键值对数量:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 2</span><br>m[<span class="hljs-string">&quot;key3&quot;</span>] = <span class="hljs-number">3</span>  <br>fmt.Println(<span class="hljs-built_in">len</span>(m)) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure><p>这里要注意的是我们不能对 map 类型变量调用 cap，来获取当前容量，这是map 类型与切片类型的一个不同点。</p><p><strong>操作三：查找和数据读取</strong></p><p>和写入相比，map类型更多用在查找和数据读取场合。所谓查找，就是判断某个 key是否存在于某个 map 中。有了前面向 map插入键值对的基础，我们可能自然而然地想到，可以用下面代码去查找一个键并获得该键对应的值：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v := m[<span class="hljs-string">&quot;key1&quot;</span>]<br></code></pre></div></td></tr></table></figure><p>乍一看，第二行代码在语法上好像并没有什么不当之处，但其实通过这行语句，我们还是无法确定键key1 是否真实存在于 map中。这是因为，当我们尝试去获取一个键对应的值的时候，如果这个键在 map中并不存在，我们也会得到一个值，这个值是 value 元素类型的零值。</p><p>那么在 map 中查找 key 的正确姿势是什么呢？Go 语言的 map类型支持通过用一种名为“comma ok”的惯用法，进行对某个 key的查询。接下来我们就用“comma ok”惯用法改造一下上面的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br>    <span class="hljs-comment">// &quot;key1&quot;不在map中</span><br>&#125;<br><br><span class="hljs-comment">// &quot;key1&quot;在map中，v将被赋予&quot;key1&quot;键对应的value</span><br></code></pre></div></td></tr></table></figure><p>如果我们并不关心某个键对应的 value，而只关心某个键是否在于 map中，我们可以使用空标识符替代变量 v，忽略可能返回的 value：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>_, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br>... ...<br></code></pre></div></td></tr></table></figure><p>因此，一定要记住：在 Go 语言中，请使用“comma ok”惯用法对 map进行键查找和键值读取操作。</p><p><strong>操作四：删除数据。</strong></p><p>在 Go 中，我们需要借助内置函数 delete 来从 map 中删除数据。使用delete 函数的情况下，传入的第一个参数是我们的 map类型变量，第二个参数就是我们想要删除的键。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> &#123;<br>  <span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">2</span>,<br>&#125;<br><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1 key2:2]</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key2&quot;</span>) <span class="hljs-comment">// 删除&quot;key2&quot;</span><br>fmt.Println(m) <span class="hljs-comment">// map[key1:1]</span><br></code></pre></div></td></tr></table></figure><p>这里要注意的是，delete 函数是从 map 中删除键的唯一方法。即便传给delete 的键在 map 中并不存在，delete函数的执行也不会失败，更不会抛出运行时的异常。</p><p><strong>操作五：遍历 map 中的键值数据</strong></p><p>遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range语句对 map 数据进行遍历。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>  <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;&#123; &quot;</span>)<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;&#125;\n&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们只关心每次迭代的键，我们可以使用下面的方式对 map进行遍历：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> m &#123; <br>  <span class="hljs-comment">// 使用k</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 使用k</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果我们只关心每次迭代返回的键所对应的value，我们同样可以通过空标识符替代变量 k，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 使用v</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们可以看到，对同一 map做多次遍历的时候，每次遍历元素的次序都不相同。这是 Go 语言 map类型的一个重要特点，也是很容易让 Go初学者掉入坑中的一个地方。所以这里你一定要记住：程序逻辑千万不要依赖遍历map 所得到的的元素次序。</p><h2 id="map-变量的传递开销">map 变量的传递开销</h2><p>和切片类型一样，map 也是引用类型。这就意味着 map类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”</p><h2 id="map-的内部实现">map 的内部实现</h2><p>和切片相比，map 类型的内部实现要更加复杂。Go运行时使用一张哈希表来实现抽象的 map 类型。运行时实现了 map类型操作的所有功能，包括查找、插入、删除等。在编译阶段，Go 编译器会将 Go语法层面的 map操作，重写成运行时对应的函数调用。大致的对应关系是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 创建map类型变量实例</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[keyType]valType, capacityhint) → m := runtime.makemap(maptype, capacityhint, m)<br><span class="hljs-comment">// 插入新键值对或给键重新赋值</span><br>m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span> → v := runtime.mapassign(maptype, m, <span class="hljs-string">&quot;key&quot;</span>) v是用于后续存储value的空间的地址<br><span class="hljs-comment">// 获取某键的值 </span><br>v := m[<span class="hljs-string">&quot;key&quot;</span>]      → v := runtime.mapaccess1(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br>v, ok := m[<span class="hljs-string">&quot;key&quot;</span>]  → v, ok := runtime.mapaccess2(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br><span class="hljs-comment">// 删除某键</span><br><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key&quot;</span>)   → runtime.mapdelete(maptype, m, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/page/2022-05/map1.png" /></p><p>我们可以看到，和切片的运行时表示图相比，map的实现示意图显然要复杂得多。接下来，我们结合这张图来简要描述一下 map在运行时层的实现原理。我们重点讲解一下一个 map变量在初始状态、进行键值对操作后，以及在并发场景下的 Go运行时层的实现原理。</p><h3 id="初始状态">初始状态</h3><p>从图中我们可以看到，与语法层面 map 类型变量（m）一一对应的是<code>*runtime.hmap</code> 的实例，即 <code>runtime.hmap</code>类型的指针，也就是我们前面在讲解 <code>map</code>类型变量传递开销时提到的 <code>map</code> 类型的描述符。hmap 类型是 map类型的头部结构（header），它存储了后续 map类型操作所需的所有信息，包括：</p><p><img src="/page/2022-05/map2.png" /></p><p>真正用来存储键值对数据的是桶，也就是 <code>bucket</code>，每个<code>bucket</code> 中存储的是 Hash 值低 bit位数值相同的元素，默认的元素个数为 BUCKETSIZE（值为 8，Go 1.17 版本中在<code>$GOROOT/src/cmd/compile/internal/reflectdata/reflect.go</code>中定义，与 <code>runtime/map.go</code> 中常量 <code>bucketCnt</code>保持一致）。</p><p>当某个 <code>bucket</code>（比如 <code>buckets[0]</code>) 的 8 个空槽slot）都填满了，且 <code>map</code>尚未达到扩容的条件的情况下，运行时会建立<code>overflow bucket</code>，并将这个 <code>overflow bucket</code>挂在上面<code>bucket</code>（如 <code>buckets[0]</code>）末尾的<code>overflow</code> 指针上，这样两个<code>buckets</code>形成了一个链表结构，直到下一次 map扩容之前，这个结构都会一直存在。从图中我们可以看到，每个<code>bucket</code> 由三部分组成，从上到下分别是 <code>tophash</code>区域、key 存储区域和 value 存储区域。</p><h3 id="tophash-区域">tophash 区域</h3><p>当我们向 map 插入一条数据，或者是从 map 按 key查询数据的时候，运行时都会使用哈希函数对 key做哈希运算，并获得一个哈希值（hashcode）。这个 hashcode非常关键，运行时会把 hashcode“一分为二”来看待，其中低位区的值用于选定bucket，高位区的值用于在某个 bucket 中确定 key的位置。我把这一过程整理成了下面这张示意图，你理解起来可以更直观：</p><p><img src="/page/2022-05/map3.png" /></p><p>因此，每个 bucket 的 tophash 区域其实是用来快速定位 key位置的，这样就避免了逐个 key 进行比较这种代价较大的操作。尤其是当 key 是size较大的字符串类型时，好处就更突出了。这是一种以空间换时间的思路。</p><h3 id="key-存储区域">key 存储区域</h3><p>我们看 tophash 区域下面是一块连续的内存区域，存储的是这个 bucket承载的所有 key 数据。运行时在分配 bucket 的时候需要知道 key 的Size。</p><p>当我们声明一个 map 类型变量，比如 <code>var m map[string]int</code>时，Go 运行时就会为这个变量对应的特定 map类型，生成一个<code>runtime.maptype</code>实例。如果这个实例已经存在，就会直接复用。maptype实例的结构是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> maptype <span class="hljs-keyword">struct</span> &#123;<br>    typ        _type<br>    key        *_type<br>    elem       *_type<br>    bucket     *_type <span class="hljs-comment">// internal type representing a hash bucket</span><br>    keysize    <span class="hljs-type">uint8</span>  <span class="hljs-comment">// size of key slot</span><br>    elemsize   <span class="hljs-type">uint8</span>  <span class="hljs-comment">// size of elem slot</span><br>    bucketsize <span class="hljs-type">uint16</span> <span class="hljs-comment">// size of bucket</span><br>    flags      <span class="hljs-type">uint32</span><br>&#125; <br></code></pre></div></td></tr></table></figure><p>我们可以看到，这个实例包含了我们需要的 map类型中的所有"元信息"。我们前面提到过，编译器会把语法层面的 map操作重写成运行时对应的函数调用，这些运行时函数都有一个共同的特点，那就是第一个参数都是maptype 指针类型的参数。</p><p>Go 运行时就是利用 maptype 参数中的信息确定 key 的类型和大小的。map所用的 hash 函数也存放在 maptype.key.alg.hash(key, hmap.hash0) 中。同时maptype 的存在也让 Go 中所有 map 类型都共享一套运行时 map操作函数，而不是像 C++ 那样为每种 map 类型创建一套 map操作函数，这样就节省了对最终二进制文件空间的占用。</p><h3 id="value-存储区域">value 存储区域</h3><p>key 存储区域下方的另外一块连续的内存区域，这个区域存储的是 key 对应的value。和 key 一样，这个区域的创建也是得到了 <code>maptype</code>中信息的帮助。Go 运行时采用了把 key 和 value分开存储的方式，而不是采用一个 kv 接着一个 kv 的 kv紧邻方式存储，这带来的其实是算法上的复杂性，但却减少了因内存对齐带来的内存浪费。</p><p><code>map[int8]int64</code> 为例，看看下面的存储空间利用率对比图</p><p><img src="/page/2022-05/map4.png" /></p><p>当前 Go 运行时使用的方案内存利用效率很高，而 kv紧邻存储的方案在<code>map[int8]int64</code>这样的例子中内存浪费十分严重，它的内存利用率是<code>72/128=56.25%</code>，有近一半的空间都浪费掉了。另外，还有一点要强调一下，如果key 或 value 的数据长度大于一定数值，那么运行时不会在 bucket中直接存储数据，而是会存储 key 或 value 数据的指针。目前 Go运行时定义的最大 key 和 value 的长度是这样的：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/map.go</span><br><span class="hljs-keyword">const</span> (<br>    maxKeySize  = <span class="hljs-number">128</span><br>    maxElemSize = <span class="hljs-number">128</span><br>)<br></code></pre></div></td></tr></table></figure><h3 id="map-扩容">map 扩容</h3><p>我们前面提到过，map会对底层使用的内存进行自动管理。因此，在使用过程中，当插入元素个数超出一定数值后，map一定会存在自动扩容的问题，也就是怎么扩充 bucket 的数量，并重新在 bucket间均衡分配数据的问题。那么 map 在什么情况下会进行扩容呢？Go 运行时的 map实现中引入了一个 LoadFactor（负载因子），当 count &gt; LoadFactor * 2^B或 overflow bucket 过多时，运行时会自动对 map 进行扩容。目前 Go 最新1.17 版本 LoadFactor 设置为 6.5（loadFactorNum/loadFactorDen）。这里是Go 中与 map 扩容相关的部分源码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/runtime/map.go</span><br><span class="hljs-keyword">const</span> (<br>  ... ...<br><br>  loadFactorNum = <span class="hljs-number">13</span><br>  loadFactorDen = <span class="hljs-number">2</span><br>  ... ...<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>  ... ...<br>  <span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>    hashGrow(t, h)<br>    <span class="hljs-keyword">goto</span> again <span class="hljs-comment">// Growing the table invalidates everything, so try again</span><br>  &#125;<br>  ... ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这两方面原因导致的扩容，在运行时的操作其实是不一样的。如果是因为overflow bucket 过多导致的“扩容”，实际上运行时会新建一个和现有规模一样的bucket 数组，然后在 assign 和 delete时做排空和迁移。如果是因为当前数据数量超出 LoadFactor指定水位而进行的扩容，那么运行时会建立一个两倍于现有规模的 bucket数组，但真正的排空和迁移工作也是在 assign 和 delete 时逐步进行的。原bucket 数组会挂在 hmap 的 oldbuckets 指针下面，直到原 buckets数组中所有数据都迁移到新数组后，原 buckets数组才会被释放。你可以结合下面的 map扩容示意图来理解这个过程，这会让你理解得更深刻一些：</p><p><img src="/page/2022-05/map5.png" /></p><h3 id="map-与并发">map 与并发</h3><p>接着我们来看一下 map 和并发。从上面的实现原理来看，充当 map描述符角色的 hmap实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说map 实例不是并发写安全的，也不支持并发读写。如果我们对 map实例进行并发读写，程序运行时就会抛出异常。看看下面这个并发读写 map的例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doIteration</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        _ = fmt.Sprintf(<span class="hljs-string">&quot;[%d, %d] &quot;</span>, k, v)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>        m[k] = v + <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;<br>        <span class="hljs-number">1</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-number">2</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-number">3</span>: <span class="hljs-number">13</span>,<br>    &#125;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>            doIteration(m)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>            doWrite(m)<br>        &#125;<br>    &#125;()<br>    time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行这个示例程序，我们会得到下面的执行错误结果： <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fatal <span class="hljs-type">error</span>: concurrent <span class="hljs-keyword">map</span> iteration and <span class="hljs-keyword">map</span> write<br></code></pre></div></td></tr></table></figure></p><p>不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9版本中引入了支持并发写安全的 sync.Map类型，可以用来在并发读写的场景下替换掉map，如果你有这方面的需求，可以查看一下sync.Map 的手册。另外，考虑到 map可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以Go 不允许获取 map 中 value的地址，这个约束是在编译期间就生效的。下面这段代码就展示了 Go编译器识别出获取 map 中 value 地址的语句后，给出的编译错误：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">p := &amp;m[key]  <span class="hljs-comment">// cannot take the address of m[key]</span><br>fmt.Println(p)<br></code></pre></div></td></tr></table></figure> <strong>特别注意：</strong></p><ul><li>不要依赖 map 的元素遍历顺序；</li><li>map 不是线程安全的，不支持并发读写；</li><li>不要尝试获取 map 中元素（value）的地址。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习笔记-变量、常量、数据类型</title>
    <link href="/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2022-05/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h1 id="变量声明">变量声明</h1><p>在编程语言中，为了方便操作内存特定位置的数据，我们用一个特定的名字与位于特定位置的内存块绑定在一起，这个名字被称为变量，变量所绑定的内存区域是要有一个明确的边界的。动态语言（比如Python、Ruby等）的解释器可以在运行时通过对变量赋值的分析，自动确定变量的边界。并且在动态语言中，一个变量可以在运行时被赋予大小不同的边界。而静态编程语言在这方面的“体验略差”。静态类型语言编译器必须明确知道一个变量的边界才允许使用这个变量，但静态语言编译器又没能力自动提供这个信息，这个边界信息必须由这门语言的使用者提供，于是就有了“变量声明”。</p><h2 id="go-语言的变量声明方法">Go 语言的变量声明方法</h2><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>这个变量声明分为四个部分：var 是修饰变量声明的关键字；a 为变量名；int为该变量的类型；10 是变量的初值。Go语言的变量声明形式与其他主流静态语言有一个显著的差异，那就是它将变量名放在了类型的前面。如果没有显式为变量赋予初值，Go编译器会为变量赋予这个类型的零值。对于整数类型，零值为0；浮点数，零值为0.0；布尔类型，零值为False；字符串类型，零值为""；指针，接口，切片，channel，map和函数类型，零值为nil。</p><p>除了单独声明每个变量外，Go语言还提供了变量声明块（block）的语法形式，可以用一个 var关键字将多个变量声明放在一起，像下面代码这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    a <span class="hljs-type">int</span> = <span class="hljs-number">128</span><br>    b <span class="hljs-type">int8</span> = <span class="hljs-number">6</span><br>    s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;hello&quot;</span><br>    c <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>    t <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>)<br><br><br><span class="hljs-keyword">var</span> a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br><br><br><span class="hljs-keyword">var</span> (<br>    a, b, c <span class="hljs-type">int</span> = <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span><br>    c, d, e <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span><br>) <br></code></pre></div></td></tr></table></figure><h2 id="go语言的语法糖">go语言的语法糖</h2><h3 id="省略类型信息的声明">省略类型信息的声明</h3><p>在通用的变量声明的基础上，Go编译器允许我们省略变量声明中的类型信息，它的标准范式是<code>var varName = initExpression</code>，比如下面就是一个省略了类型信息的变量声明：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-number">13</span><br></code></pre></div></td></tr></table></figure><p>Go编译器会根据右侧变量初值自动推导出变量的类型，并给这个变量赋予初值所对应的默认类型。比如，整型值的默认类型int，浮点值的默认类型为 float64，复数值的默认类型为complex128。其他类型值的默认类型就更好分辨了，在 Go语言中仅有唯一与之对应的类型，比如布尔值的默认类型只能是bool，字符值默认类型只能是 rune，字符串值的默认类型只能是 string等。</p><p>如果我们不接受默认类型，而是要显式地为变量指定类型，除了通用的声明形式，我们还可以通过显式类型转型达到我们的目的：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b = <span class="hljs-type">int32</span>(<span class="hljs-number">13</span>)<br></code></pre></div></td></tr></table></figure></p><p>但是这种省略类型信息声明的“语法糖”仅适用于在变量声明的同时显式赋予变量初值的情况，下面这种没有初值的声明形式是不被允许的：<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b<br></code></pre></div></td></tr></table></figure></p><p>结合多变量声明，我们可以使用这种变量声明“语法糖”声明多个不同类型的变量：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b, c = <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="短变量声明">短变量声明</h3><p>Go语言还为我们提供了最简化的变量声明形式：短变量声明。使用短变量声明时，我们甚至可以省去var关键字以及类型信息，它的标准范式是<code>varName := initExpression</code>。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a := <span class="hljs-number">12</span><br>b := <span class="hljs-string">&#x27;A&#x27;</span><br>c := <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><p>短变量声明将通用变量声明中的四个部分省去了两个，但它并没有使用赋值操作符<code>=</code>，而是使用了短变量声明专用的<code>:=</code>。这个原理和上一种省略类型信息的声明语法糖一样，短变量声明中的变量类型也是由Go 编译器自动推导出来的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a, b, c := <span class="hljs-number">12</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><h1 id="常量声明">常量声明</h1><p>go语言中常量的特点： * 支持无类型常量； * 支持隐式自动转型； *可用于实现枚举。</p><p>Go语言的常量是一种在源码编译期间被创建的语法元素。这是在说这个元素的值可以像变量那样被初始化，但它的初始化表达式必须是在编译期间可以求出值来的。而且，Go常量一旦声明并被初始化后，它的值在整个程序的生命周期内便保持不变。这样，我们在并发设计时就不用考虑常量访问的同步，并且被创建并初始化后的常量还可以作为其他常量的初始表达式的一部分。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi <span class="hljs-type">float64</span> = <span class="hljs-number">3.14159265358979323846</span> <span class="hljs-comment">// 单行常量声明</span><br><br><span class="hljs-comment">// 以const代码块形式声明常量</span><br><span class="hljs-keyword">const</span> (<br>    size <span class="hljs-type">int64</span> = <span class="hljs-number">4096</span><br>    i, j, s = <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-string">&quot;bar&quot;</span> <span class="hljs-comment">// 单行声明多个常量</span><br>)<br></code></pre></div></td></tr></table></figure><p>Go 语言规范规定，Go 常量的类型只局限于 Go基本数据类型，包括数值类型、字符串类型，以及只有两个取值（true 和false）的布尔类型。</p><h2 id="无类型常量">无类型常量</h2><p>声明方式 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> n = <span class="hljs-number">13</span><br></code></pre></div></td></tr></table></figure></p><p>常量 n 在声明时并没有显式地被赋予类型，在 Go中，这样的常量就被称为无类型常量（UntypedConstant）。不过，无类型常量也不是说就真的没有类型，它也有自己的默认类型，不过它的默认类型是根据它的初值形式来决定的。像上面代码中的常量n 的初值为整数形式，所以它的默认类型为 int。</p><p><strong>Go语言对类型安全是有严格要求的：即便两个类型拥有着相同的底层类型，但它们仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算。</strong></p><p>但是对于无类型常量，以下代码是可以编译通过的 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span><br><span class="hljs-keyword">const</span> n = <span class="hljs-number">13</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a myInt = <span class="hljs-number">5</span><br>    fmt.Println(a + n)  <span class="hljs-comment">// 输出：18</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>因为这里存在一个隐式转型的机制</p><h3 id="隐式转型">隐式转型</h3><p>隐式转型说的就是，对于无类型常量参与的表达式求值，Go编译器会根据上下文中的类型信息，把无类型常量自动转换为相应的类型后，再参与求值计算，这一转型动作是隐式进行的。但由于转型的对象是一个常量，所以这并不会引发类型安全问题，Go编译器会保证这一转型的安全性。</p><p>不过隐式转型中，无法转化成目标类型会报错误 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> m = <span class="hljs-number">1333333333</span><br><br><span class="hljs-keyword">var</span> k <span class="hljs-type">int8</span> = <span class="hljs-number">1</span><br>j := k + m <span class="hljs-comment">// 编译器报错：constant 1333333333 overflows int8</span><br></code></pre></div></td></tr></table></figure></p><h2 id="实现枚举">实现枚举</h2><p>Go 语言并没有原生提供枚举类型，但是我们可以使用 const代码块定义的常量集合，来实现枚举。</p><h3 id="两个机制">两个机制</h3><p><strong>隐式重复前一个非空表达式</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Strawberry, Grape <br>    Pear, Watermelon <br>)<br></code></pre></div></td></tr></table></figure><p>这个代码里，常量定义的后两行并没有被显式地赋予初始值，所以 Go编译器就为它们自动使用上一行的表达式，也就获得了下面这个等价的代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-number">11</span>, <span class="hljs-number">22</span><br>    Strawberry, Grape  = <span class="hljs-number">11</span>, <span class="hljs-number">22</span> <span class="hljs-comment">// 使用上一行的初始化表达式</span><br>    Pear, Watermelon  = <span class="hljs-number">11</span>, <span class="hljs-number">22</span> <span class="hljs-comment">// 使用上一行的初始化表达式</span><br>)<br></code></pre></div></td></tr></table></figure><p><strong>iota</strong></p><p>iota 是 Go 语言的一个预定义标识符，它表示的是 const声明块（包括单行声明）中，每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的iota自身也是一个无类型常量，可以像前面我们提到的无类型常量那样，自动参与到不同类型的求值过程中来，不需要我们再对它进行显式转型操作。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/sync/mutex.go </span><br><span class="hljs-keyword">const</span> ( <br>    mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span><br>    mutexWoken<br>    mutexStarving<br>    mutexWaiterShift = <span class="hljs-literal">iota</span><br>    starvationThresholdNs = <span class="hljs-number">1e6</span><br>)<br></code></pre></div></td></tr></table></figure><p>第一行：<code>mutexLocked = 1 &lt;&lt; iota</code> ，iota的值是这行在 const 块中的偏移，因此 iota 的值为 0，我们得到<code>mutexLocked</code> 这个常量的值为 1 &lt;&lt; 0，也就是 1。</p><p>第二行：<code>mutexWorken</code> ，因为这个 const声明块中并没有显式的常量初始化表达式，所以我们根据 const声明块里“隐式重复前一个非空表达式”的机制，这一行就等价于<code>mutexWorken = 1 &lt;&lt; iota</code>。而且，又因为这一行是 const块中的第二行，所以它的偏移量 iota 的值为 1，我们得到<code>mutexWorken</code> 这个常量的值为 1 &lt;&lt; 1，也就是 2。</p><p>第三行：同第二行，只不过这一行的<code>iota=3</code></p><p>第四行：<code>mutexWaiterShift = iota</code> ，这一行为常量<code>mutexWaiterShift</code>做了显式初始化，这样就不用再重复前一行了。由于这一行是第四行，而且作为行偏移值的iota 的值为 3，因此 <code>mutexWaiterShift</code> 的值就为 3。</p><p>第五行：代码中直接用了一个具体值 1e6 给常量<code>starvationThresholdNs</code> 进行了赋值，那么这个常量值就是 1e6本身了。</p><p>iota其他应方式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-literal">iota</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">10</span> <span class="hljs-comment">// 0, 10 (iota = 0)</span><br>    Strawberry, Grape <span class="hljs-comment">// 1, 11 (iota = 1)</span><br>    Pear, Watermelon  <span class="hljs-comment">// 2, 12 (iota = 2)</span><br>)<br></code></pre></div></td></tr></table></figure><p>如果我们要略过 iota = 0，从 iota = 1 开始正式定义枚举常量</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/syscall/net_js.go</span><br><span class="hljs-keyword">const</span> (<br>    _ = <span class="hljs-literal">iota</span><br>    IPV6_V6ONLY  <span class="hljs-comment">// 1</span><br>    SOMAXCONN    <span class="hljs-comment">// 2</span><br>    SO_ERROR     <span class="hljs-comment">// 3</span><br>)<br></code></pre></div></td></tr></table></figure><p>同理，略过中间值的话</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    _ = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>    Pin1<br>    Pin2<br>    Pin3<br>    _<br>    Pin5    <span class="hljs-comment">// 5   </span><br>)<br></code></pre></div></td></tr></table></figure><h1 id="数据类型">数据类型</h1><h2 id="整形">整形</h2><p>Go语言的整型，主要用来表示现实世界中整型数量，比如：人的年龄、班级人数等。它可以分为<strong>平台无关整型</strong>和<strong>平台相关整型</strong>这两种，它们的区别主要就在，这些整数类型在不同CPU 架构或操作系统下面，它们的长度是否是一致的。</p><p><strong>平台无关整形</strong></p><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">长度</th><th style="text-align: center;">取值范围</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">int8</td><td style="text-align: center;">1</td><td style="text-align: center;">[-128, 127]</td></tr><tr class="even"><td style="text-align: center;">int16</td><td style="text-align: center;">2</td><td style="text-align: center;">[-32768, 32767]</td></tr><tr class="odd"><td style="text-align: center;">int32</td><td style="text-align: center;">4</td><td style="text-align: center;">[-2147483648, 2147483647]</td></tr><tr class="even"><td style="text-align: center;">int64</td><td style="text-align: center;">8</td><td style="text-align: center;">[-9223372036854775808,9223372036854775807]</td></tr><tr class="odd"><td style="text-align: center;">uint8</td><td style="text-align: center;">1</td><td style="text-align: center;">[0, 255]</td></tr><tr class="even"><td style="text-align: center;">uint16</td><td style="text-align: center;">2</td><td style="text-align: center;">[0, 65535]</td></tr><tr class="odd"><td style="text-align: center;">uint32</td><td style="text-align: center;">4</td><td style="text-align: center;">[0, 4294967295]</td></tr><tr class="even"><td style="text-align: center;">uint64</td><td style="text-align: center;">8</td><td style="text-align: center;">[0, 18446744073709551615]</td></tr></tbody></table><p>注: 这些平台无关的整型也可以分成两类：有符号整型（int8 ~int64）和无符号整型（uint8 ~uint64）。两者的本质差别在于最高二进制位（bit位）是否被解释为符号位，这点会影响到无符号整型与有符号整型的取值范围。其取值范围为<spanclass="math inline">\([-2^{8 \times n-1}, 2^{8 \times n - 1}-1]\)</span>和 <span class="math inline">\([0, 2^{8 \times n}-1]\)</span></p><p><strong>平台相关整形</strong></p><table><thead><tr class="header"><th>类型</th><th>说明</th><th>32位长度</th><th>64位长度</th></tr></thead><tbody><tr class="odd"><td>int</td><td>默认有符号整型</td><td>4 字节</td><td>8 字节</td></tr><tr class="even"><td>uint</td><td>默认无符号整型</td><td>4 字节</td><td>8 字节</td></tr><tr class="odd"><td>uintptr</td><td>无符号整型</td><td>大到足以存储任何指针的值</td><td></td></tr></tbody></table><p>在这里我们要特别注意一点，由于这三个类型的长度是平台相关的，所以我们在编写有移植性要求的代码时，千万不要强依赖这些类型的长度。</p><h3 id="整型的溢出问题">整型的溢出问题</h3><p>无论哪种整型，都有它的取值范围，也就是有它可以表示的值边界。如果这个整型因为参与某个运算，导致结果超出了这个整型的值边界，我们就说发生了整型溢出的问题。</p><h3 id="字面值与格式化输出">字面值与格式化输出</h3><p>Go 语言在设计开始，就继承了 C 语言关于数值字面值（NumberLiteral）的语法形式。</p><p>声明 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//最初版本</span><br>a := <span class="hljs-number">53</span>        <span class="hljs-comment">// 十进制</span><br>b := <span class="hljs-number">0700</span>      <span class="hljs-comment">// 八进制，以&quot;0&quot;为前缀</span><br>c1 := <span class="hljs-number">0xaabbcc</span> <span class="hljs-comment">// 十六进制，以&quot;0x&quot;为前缀</span><br>c2 := <span class="hljs-number">0Xddeeff</span> <span class="hljs-comment">// 十六进制，以&quot;0X&quot;为前缀</span><br><br><span class="hljs-comment">//1.13 以后</span><br>d1 := <span class="hljs-number">0</span>b10000001 <span class="hljs-comment">// 二进制，以&quot;0b&quot;为前缀</span><br>d2 := <span class="hljs-number">0</span>B10000001 <span class="hljs-comment">// 二进制，以&quot;0B&quot;为前缀</span><br>e1 := <span class="hljs-number">0</span>o700      <span class="hljs-comment">// 八进制，以&quot;0o&quot;为前缀</span><br>e2 := <span class="hljs-number">0</span>O700      <span class="hljs-comment">// 八进制，以&quot;0O&quot;为前缀</span><br><br><span class="hljs-comment">//增加可读性，可以用下划线分割</span><br>a := <span class="hljs-number">5</span>_3_7   <span class="hljs-comment">// 十进制: 537</span><br>b := <span class="hljs-number">0</span>b_1000_0111  <span class="hljs-comment">// 二进制位表示为10000111 </span><br>c1 := <span class="hljs-number">0</span>_700  <span class="hljs-comment">// 八进制: 0700</span><br>c2 := <span class="hljs-number">0</span>o_700 <span class="hljs-comment">// 八进制: 0700</span><br>d1 := <span class="hljs-number">0</span>x_5c_6d <span class="hljs-comment">// 十六进制：0x5c6d</span><br></code></pre></div></td></tr></table></figure></p><p>输出 <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">59</span><br>fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, a) <span class="hljs-comment">//输出二进制：111011</span><br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, a) <span class="hljs-comment">//输出十进制：59</span><br>fmt.Printf(<span class="hljs-string">&quot;%o\n&quot;</span>, a) <span class="hljs-comment">//输出八进制：73</span><br>fmt.Printf(<span class="hljs-string">&quot;%O\n&quot;</span>, a) <span class="hljs-comment">//输出八进制(带0o前缀)：0o73</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(小写)：3b</span><br>fmt.Printf(<span class="hljs-string">&quot;%X\n&quot;</span>, a) <span class="hljs-comment">//输出十六进制(大写)：3B</span><br></code></pre></div></td></tr></table></figure></p><h2 id="浮点型">浮点型</h2><h3 id="浮点型的二进制表示">浮点型的二进制表示</h3><p>IEEE 754 是 IEEE 制定的二进制浮点数算术标准，它是 20 世纪 80年代以来最广泛使用的浮点数运算标准，被许多 CPU与浮点运算器采用。现存的大部分主流编程语言，包括 Go 语言，都提供了符合IEEE 754 标准的浮点数格式与算术运算。</p><p>IEEE 754 标准规定了四种表示浮点数值的方式：单精度（32位）、双精度（64 位）、扩展单精度（43 比特以上）与扩展双精度（79比特以上，通常以 80位实现）。后两种其实很少使用，我们重点关注前面两个就好了。</p><p>Go 语言提供了 float32 与 float64 两种浮点类型，它们分别对应的就是IEEE 754 中的单精度与双精度浮点数值类型。</p><p><strong>不过，这里要注意，Go 语言中没有提供 float 类型。</strong></p><p>浮点数在内存中的二进制表示（BitRepresentation）要比整型复杂得多，IEEE 754规范给出了在内存中存储和表示一个浮点数的标准形式，见下表</p><table><thead><tr class="header"><th>符号位 S</th><th>阶码 E</th><th>尾数 M</th></tr></thead><tbody><tr class="odd"><td>sign</td><td>exponent</td><td>maintissa</td></tr></tbody></table><p>我们看到浮点数在内存中的二进制表示分三个部分：符号位、阶码（即经过换算的指数），以及尾数。这样表示的一个浮点数，它的值等于：<span class="math display">\[(-1)^S \times 1.M \times 2^{E-offset}\]</span> 其中浮点值的符号由符号位决定：当符号位为 1时，浮点值为负值；当符号位为 0 时，浮点值为正值。公式中 offset被称为阶码偏移值。</p><p>单精度（float32）与双精度（float64）浮点数在阶码和尾数上的不同</p><table><thead><tr class="header"><th>浮点类型</th><th>符号位</th><th>阶码</th><th>阶码偏移值</th><th>尾数</th></tr></thead><tbody><tr class="odd"><td>单精度</td><td>1</td><td>8</td><td>127</td><td>23</td></tr><tr class="even"><td>双精度</td><td>1</td><td>11</td><td>1023</td><td>52</td></tr></tbody></table><p>单精度浮点类型（float32）为符号位分配了 1 个 bit，为阶码分配了 8 个bit，剩下的 23 个 bit分给了尾数。而双精度浮点类型，除了符号位的长度与单精度一样之外，其余两个部分的长度都要远大于单精度浮点型，阶码可用的bit 位数量为 11，尾数则更是拥有了 52 个 bit 位。</p><h3 id="十进制小数转二进制小数">十进制小数转二进制小数</h3><p>以139.8125为例</p><ul><li>步骤一：<ul><li>整数部分 139d → 10001011b；除二取余</li><li>小数部分 0.8125d → 0.1101b；乘二取整</li><li>这样 139.8125d 就转化为 10001011.1101b</li></ul></li><li>步骤二：<ul><li>移动小数点，直到整数部分仅有一个 1，即10001011.1101b →1.00010111101b，小数点向左移了 7 位，这样指数就为 7，尾数为00010111101b。</li></ul></li><li>步骤三：<ul><li>IEEE754规定不能将小数点移动而得到的指数，一直填到阶码部分，指数到阶码还需要一个转换过程。对于float32 的单精度浮点数而言，阶码 = 指数 + 偏移值。偏移值的计算公式为<span class="math inline">\(2^{e-1}-1\)</span>，其中 e 为阶码部分的 bit位数，这里为 8，于是单精度浮点数的阶码偏移值就为 2^(8-1)-1 =127。这样在这个例子中，阶码 = 7 + 127 = 134d = 10000110b。</li></ul></li><li>步骤四：<ul><li>将符号位、阶码和尾数填到各自位置，得到最终浮点数的二进制表示。尾数位数不足23 位，可在后面补 0。</li></ul></li></ul><table><thead><tr class="header"><th>*</th><th>符号位</th><th>阶码</th></tr></thead><tbody><tr class="odd"><td>0</td><td>10000110</td><td>00010111101(000000000000)</td></tr></tbody></table><p>最终浮点数 139.8125d 的二进制表示就为0b_0_10000110_00010111101_000000000000。</p><p>代码验证：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> f <span class="hljs-type">float32</span> = <span class="hljs-number">139.8125</span><br>    bits := math.Float32bits(f)<br>    fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, bits)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="字面值与格式化输出-1">字面值与格式化输出</h3><p>Go浮点类型字面值大体可分为两类，一类是直白地用十进制表示的浮点值形式。这一类，我们通过字面值就可直接确定它的浮点值，比如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-number">3.1415</span><br><span class="hljs-number">.15</span>  <span class="hljs-comment">// 整数部分如果为0，整数部分可以省略不写</span><br><span class="hljs-number">81.80</span><br><span class="hljs-number">82.</span> <span class="hljs-comment">// 小数部分如果为0，小数点后的0可以省略不写</span><br></code></pre></div></td></tr></table></figure><p>另一类则是科学计数法形式。采用科学计数法表示的浮点字面值，我们需要通过一定的换算才能确定其浮点值。而且在这里，科学计数法形式又分为十进制形式表示的，和十六进制形式表示的两种。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-number">6674.28e-2</span> <span class="hljs-comment">// 6674.28 * 10^(-2) = 66.742800</span><br><span class="hljs-number">.12345E+5</span>  <span class="hljs-comment">// 0.12345 * 10^5 = 12345.000000</span><br><br><span class="hljs-number">0x2</span>.p10  <span class="hljs-comment">// 2.0 * 2^10 = 2048.000000</span><br><span class="hljs-number">0x1</span>.Fp+<span class="hljs-number">0</span> <span class="hljs-comment">// 1.9375 * 2^0 = 1.937500</span><br></code></pre></div></td></tr></table></figure><p>十六进制科学计数法的整数部分、小数部分用的都是十六进制形式，但指数部分依然是十进制形式，并且字面值中的p/P 代表的幂运算的底数为 2。</p><p>浮点型的字面值后，和整型一样，fmt包也提供了针对浮点数的格式化输出。我们最常使用的格式化输出形式是%f。通过 %f，我们可以输出浮点数最直观的原值形式。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">123.45678</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f) <span class="hljs-comment">// 123.456780</span><br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, f) <span class="hljs-comment">// 1.234568e+02</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, f) <span class="hljs-comment">// 0x1.edd3be22e5de1p+06</span><br></code></pre></div></td></tr></table></figure><p>其中 %e 输出的是十进制的科学计数法形式，而 %x输出的则是十六进制的科学计数法形式。</p><h2 id="字符串类型">字符串类型</h2><h3 id="原生支持字符串有什么好处">原生支持字符串有什么好处？</h3><p>这样定义的非原生字符串在使用过程中会有很多问题，比如： *不是原生类型，编译器不会对它进行类型校验，导致类型安全性差；字符串操作时要时刻考虑结尾的’\0’，防止缓冲区溢出；*以字符数组形式定义的“字符串”，它的值是可变的，在并发场景中需要考虑同步问题；* 获取一个字符串的长度代价较大，通常是 O(n) 时间复杂度； * C语言没有内置对非 ASCII 字符（如中文字符）的支持。</p><h4id="string-类型的数据是不可变的提高了字符串的并发安全性和存储利用率">1.string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。</h4><p>Go语言规定，字符串类型的值在它的生命周期内是不可改变的。这就是说，如果我们声明了一个字符串类型的变量，那我们是无法通过这个变量改变它对应的字符串值的，但这并不是说我们不能为一个字符串类型变量进行二次赋值。</p><p>Go这样的“字符串类型数据不可变”的性质给开发人员带来的最大好处，就是我们不用再担心字符串的并发安全问题。这样，Go字符串可以被多个 Goroutine（Go语言的轻量级用户线程，后面我们会详细讲解）共享，开发者不用因为担心并发安全问题，使用会带来一定开销的同步机制。另外，也由于字符串的不可变性，针对同一个字符串值，无论它在程序的几个位置被使用，Go编译器只需要为它分配一块存储就好了，大大提高了存储利用率。</p><h4id="没有结尾0而且获取长度的时间复杂度是常数时间消除了获取字符串长度的开销">2.没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。</h4><p>Go 语言修正了这个缺陷，Go字符串中没有结尾’\0’，获取字符串长度更不需要结尾’\0’作为结束标志。并且，Go获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，我们都可以快速得到字符串的长度值。</p><h4id="原生支持所见即所得的原始字符串大大降低构造多行字符串时的心智负担">3.原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。</h4><p>Go 语言通过一对反引号原生支持构造“所见即所得”的原始字符串（RawString）</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">`         ,_---~~~~~----._</span><br><span class="hljs-string">    _,,_,*^____      _____*g*\&quot;*,--,</span><br><span class="hljs-string">   / __/ /&#x27;     ^.  /      \ ^@q   f</span><br><span class="hljs-string">  [  @f | @))    |  | @))   l  0 _/</span><br><span class="hljs-string">   \/   \~____ / __ \_____/     \</span><br><span class="hljs-string">     |           _l__l_           I</span><br><span class="hljs-string">    &#125;          [______]           I</span><br><span class="hljs-string">    ]            | | |            |</span><br><span class="hljs-string">    ]             ~ ~             |</span><br><span class="hljs-string">    |                            |</span><br><span class="hljs-string">     |                           |`</span><br>fmt.Println(s)<br></code></pre></div></td></tr></table></figure><h4id="对非-ascii-字符提供原生支持消除了源码在不同环境下显示乱码的可能">4.对非 ASCII 字符提供原生支持，消除了源码在不同环境下显示乱码的可能。</h4><p>Go 语言源文件默认采用的是 Unicode 字符集，Unicode字符集是目前市面上最流行的字符集，它囊括了几乎所有主流非 ASCII字符（包括中文字符）。Go 字符串中的每个字符都是一个 Unicode字符，并且这些 Unicode 字符是以 UTF-8 编码格式存储在内存当中的。</p><h3 id="go-字符串的组成">Go 字符串的组成</h3><p>一种是字节视角，也就是和所有其它支持字符串的主流语言一样，Go语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。一个个的字节只是孤立数据，不表意。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;the length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 9</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i]) <span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>如果要表意，我们就需要从字符串的另外一个视角来看，也就是字符串是由一个可空的字符序列构成。这个时候我们再看下面代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;the character count in s is&quot;</span>, utf8.RuneCountInString(s)) <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, c) <span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>0x4e2d 0x56fd 0x4eba分别是中国人在unicode中的码点</p><h3 id="go-字符串类型的内部表示">Go 字符串类型的内部表示</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/reflect/value.go</span><br><br><span class="hljs-comment">// StringHeader是一个string的运行时表示</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>    Data <span class="hljs-type">uintptr</span><br>    Len  <span class="hljs-type">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>string类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。</p><p>Go 编译器把源码中的 string 类型映射为运行时的一个二元组（Data,Len），真实的字符串值数据就存储在一个被 Data 指向的底层数组中。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dumpBytesArray</span><span class="hljs-params">(arr []<span class="hljs-type">byte</span>)</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;[&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> arr &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, b)<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;]\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span><br>    hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) <span class="hljs-comment">// 将string类型变量地址显式转型为reflect.StringHeader</span><br>    fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, hdr.Data) <span class="hljs-comment">// 0x10a30e0</span><br>    p := (*[<span class="hljs-number">5</span>]<span class="hljs-type">byte</span>)(unsafe.Pointer(hdr.Data)) <span class="hljs-comment">// 获取Data字段所指向的数组的指针</span><br>    dumpBytesArray((*p)[:]) <span class="hljs-comment">// [h e l l o ]   // 输出底层数组的内容</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码利用了 unsafe.Pointer 的通用指针转型能力，按照 StringHeader给出的结构内存布局，“顺藤摸瓜”，一步步找到了底层数组的地址，并输出了底层数组内容。</p><p>可以得到这样一个结论，那就是我们直接将 string 类型通过函数 /方法参数传入也不会带来太多的开销。因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</p><h3 id="go-字符串类型的常见操作">Go 字符串类型的常见操作</h3><h4 id="下标操作">下标操作</h4><p>在字符串的实现中，真正存储数据的是底层的数组。字符串的下标操作本质上等价于底层数组的下标操作。<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, s[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xe4：字符“中” utf-8编码的第一个字节</span><br></code></pre></div></td></tr></table></figure></p><h4 id="字符迭代">字符迭代</h4><p>Go 有两种迭代形式：常规 for 迭代与 for range迭代。你要注意，通过这两种形式的迭代对字符串进行操作得到的结果是不同的。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>两种不同方法分别输出的按字节和按字符输出的</p><h4 id="字符串连接">字符串连接</h4><p>字符串内容是不可变的，但这并不妨碍我们基于已有字符串创建新字符串。Go原生支持通过 +/+= 操作符进行字符串连接</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Rob Pike, &quot;</span><br>s = s + <span class="hljs-string">&quot;Robert Griesemer, &quot;</span><br>s += <span class="hljs-string">&quot; Ken Thompson&quot;</span><br><br>fmt.Println(s) <span class="hljs-comment">// Rob Pike, Robert Griesemer, Ken Thompson</span><br></code></pre></div></td></tr></table></figure><p>虽然通过 +/+=进行字符串连接的开发体验是最好的，但连接性能就未必是最快的了。除了这个方法外，Go还提供了 strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作。</p><h4 id="字符串比较">字符串比较</h4><p>Go 字符串类型支持各种比较关系操作符，包括 = =、!=、&gt;=、&lt;=、&gt; 和 &lt;。在字符串的比较上，Go采用字典序的比较策略，分别从每个字符串的起始处，开始逐个字节地对两个字符串类型变量进行比较。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// ==</span><br>        s1 := <span class="hljs-string">&quot;世界和平&quot;</span><br>        s2 := <span class="hljs-string">&quot;世界&quot;</span> + <span class="hljs-string">&quot;和平&quot;</span><br>        fmt.Println(s1 == s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// !=</span><br>        s1 = <span class="hljs-string">&quot;Go&quot;</span><br>        s2 = <span class="hljs-string">&quot;C&quot;</span><br>        fmt.Println(s1 != s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &lt; and &lt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;23456&quot;</span><br>        fmt.Println(s1 &lt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &lt;= s2) <span class="hljs-comment">// true</span><br><br>        <span class="hljs-comment">// &gt; and &gt;=</span><br>        s1 = <span class="hljs-string">&quot;12345&quot;</span><br>        s2 = <span class="hljs-string">&quot;123&quot;</span><br>        fmt.Println(s1 &gt; s2)  <span class="hljs-comment">// true</span><br>        fmt.Println(s1 &gt;= s2) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="字符串转换">字符串转换</h4><p>Go 支持字符串与字节切片、字符串与 rune切片的双向转换，并且这种转换无需调用任何函数，只需使用显式类型转换就可以了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></div></td></tr></table></figure><p>这样的转型看似简单，但无论是 string 转切片，还是切片转string，这类转型背后也是有着一定开销的。这些开销的根源就在于 string是不可变的，运行时要为转换后的类型分配新内存。</p>]]></content>
    
    
    <categories>
      
      <category>Go语言学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch简单食用笔记</title>
    <link href="/2022-03/Pytorch%E7%AE%80%E5%8D%95%E9%A3%9F%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022-03/Pytorch%E7%AE%80%E5%8D%95%E9%A3%9F%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在学习深度学习的过程中，主要用到的工具为<code>PyTorch</code>，本文主要记录了一些基础的语法功能，以方便更进一步的深度网络的学习设计。</p><h1 id="张量">1.张量</h1><p>在pytorch中主要的计算单元，我的理解一个n阶张量就是一个n维数组，pytorch赋予了更多计算手段，以便于之后的高阶张量的计算。</p><p>在定义上，张量表示由一个数值组成的数组，这个数组可能有多个维度。具有一个轴的张量对应数学上的向量（vector）；具有两个轴的张量对应数学上的矩阵（matrix）；具有两个轴以上的张量没有特殊的数学名称。</p><h2 id="张量的创建">1.1张量的创建</h2><p>pytorch提供了多种多样的张量创建方式</p><ul><li><code>arange(n)</code> 函数类似python原来的range(n)，创建一个张量，其元素是从0到n-1的整数，其形状为(1, n)</li><li><code>zeros((a1, a2, a3, ...))</code>创建一个元素全为0的张量，其形状为(a1, a2, a3, ...)</li><li><code>ones((a1, a2, a3, ...))</code>创建一个元素全为1的张量，其形状为(a1, a2, a3, ...)</li><li><code>rand((a1, a2, a3, ...))</code>创建一个元素随机的张量，取值范围为[0, 1)，其形状为(a1, a2, a3, ...)</li><li><code>randn((a1, a2, a3, ...))</code>创建一个元素满足均值为0，方差为1的正态分布张量，其形状为(a1, a2, a3,...)</li><li><code>normal(mean=n, std=m, size=(a1, a2, a3, ...))</code>创建一个元素满足均值为n，方差为m的正态分布张量，其形状为(a1, a2, a3,...)当<code>mean=0</code>，<code>std=1</code>时，等价与<code>randn()</code></li><li><code>tensor(arr)</code> 通过python的列表类型，创建一个张量</li></ul><h2 id="张量的操作">1.2 张量的操作</h2><p>pytorch中重构了运算符以及提供其他函数，使张量的运算更加方便</p><h3 id="基础运算符">1.2.1 基础运算符</h3><p>对于基础的运算符，张量间的运算方法如下</p><ul><li><code>+</code> 按元素求和</li><li><code>-</code> 按元素求差</li><li><code>*</code> 按元素求积</li><li><code>/</code> 按元素求商</li><li><code>**</code> 按元素求幂</li><li><code>%</code> 按元素求余</li><li><code>exp()</code> 按元素求e的指数</li><li><code>==</code> 按元素判断是否相等</li></ul><h3 id="函数操作">1.2.2 函数操作</h3><ul><li><code>shape</code> 函数返回张量的形状</li><li><code>size()</code> 函数返回张量的形状</li><li><code>reshape(a1, a2, a3, ...)</code>函数返回一个新的张量，其形状为指定的形状，形状为(a1, a2, a3,...)，是进一步的<code>view()</code></li><li><code>sum()</code> 对张量中的所有元素进行求和，会产生一个单元素张量<ul><li><code>sum(axis = n)</code>在张量中，按维度求和，会产生一个张量，阶数低于计算之前的张量</li></ul></li><li><code>numpy()</code> 将张量转化为NumPy张量</li><li><code>item()</code> 将张量转化为python的数字或者python原本的float(x)int(x)也可以将张量转化为python的数字，但是仅限只有一个元素的时候</li><li><code>torch.cat((X, Y), dim = n)</code>按照第n维度，将X和Y连结在一起，需要除了第n维度的其他形状相同</li><li><code>mean()</code> 对张量的所有元素求平均值<ul><li><code>mean(axis = n)</code> 对张量的第n维元素求平均值</li></ul></li></ul><h3 id="广播机制">1.2.3 广播机制</h3><p>当两个张量的形状不同时，可以通过广播机制，将其中一个张量的形状转换成另一个张量的形状，能够广播的前提是参与运算的两个张量的形状在逻辑上可一通过复制扩充达到一致。<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">X = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>Y = torch.tensor([[<span class="hljs-number">4</span>], [<span class="hljs-number">5</span>]])<br>X + Y<br></code></pre></div></td></tr></table></figure> <figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">tensor(<span class="hljs-string">[[5, 6, 7],</span><br><span class="hljs-string">        [6, 7, 8]]</span>)<br></code></pre></div></td></tr></table></figure></p><h3 id="索引和切片">1.2.4 索引和切片</h3><p>torch的索引与python索引机制一致，这里记录一些常用操作</p><ul><li><code>X[-1]</code> 在第一维选择最后一个元素</li><li><code>X[1:3]</code> 在第一维选择下标[1, 3)的连续元素</li><li><code>X[1:3, 2:4]</code>在第一维选择索引[1,3)的元素，在第二维选择索引为[2,4)的元素</li><li><code>X[1, 2, ...]</code> = n 修改张量里具体位置的值</li></ul><h3 id="内存节省方法">1.2.5 内存节省方法</h3><p>如果使用<code>Y=X+Y</code>这种运算方法的话，会导致额外的内存分配，通常使用<code>Y[:]=X+Y</code>或<code>Y+=X</code>来减少内存开销</p><h1 id="层与块">2. 层与块</h1><p>为了实现一些复杂的网络，我们引入了神经网络块的概念。块（block）可以描述单个层、由多个层组成的组件或整个模型本身。使用块进行抽象的一个好处是可以将一些块组合成更大的组件，这一过程通常是递归的，如下图所示<img src="/page/2022-03/161550.png" alt="层与块" /></p><p>从编程的⻆度来看，块由类（class）表示。它的任何子类都必须定义一个将其输入转换为输出的前向传播函数，并且必须存储任何必需的参数。注意，有些块不需要任何参数。最后，为了计算梯度，块必须具有反向传播函数。</p><h2 id="自定义块">2.1 自定义块</h2><h3 id="简单的自定义块">2.1.1 简单的自定义块</h3><p>每个块必须提供的基本功能：</p><ol type="1"><li>将输入数据作为其前向传播函数的参数。</li><li>通过前向传播函数来生成输出。请注意，输出的形状可能与输入的形状不同。</li><li>计算其输出关于输入的梯度，可通过其反向传播函数进行访问。通常这是自动发生的。</li><li>存储和访问前向传播计算所需的参数。</li><li>根据需要初始化模型参数。</li></ol><p>在下面的代码片段中，我们从零开始编写一个块。它包含一个多层感知机，其具有256个隐藏单元的隐藏层和一个10维输出层。注意，下面的MLP类继承了表示块的类。我们的实现<strong>只</strong>需要提供我们自己的构造函数（Python中的__init__函数）和前向传播函数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MLP</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.hidden = nn.Linear(<span class="hljs-number">20</span>, <span class="hljs-number">256</span>)<br>        self.out = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>        <span class="hljs-keyword">return</span> self.out(F.relu(self.hidden(X)))<br></code></pre></div></td></tr></table></figure><p>新建网络和执行<code>forward()</code>方法 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net = MLP()<br>net(X)<br></code></pre></div></td></tr></table></figure></p><h3 id="在向前传播中执行其他计算代码">2.1.2在向前传播中执行其他计算代码</h3><p>在对于向前传播中，pytorch可以做很多操作，来满足各种各样的架构的复杂运算，如下所示代码，它的向前传播进行四步计算：1.全连接层；2.常数参数乘积计算，全元素+1后计算relu；3.全连接层；4.第一范数大于1，全元素/2；5.返回全元素和。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>    X = self.linear(X)<br>    X = self.relu(torch.mm(self.con_weight, X) + <span class="hljs-number">1</span>)<br>    X = self.linear(X)<br>    <span class="hljs-keyword">while</span> X.<span class="hljs-built_in">abs</span>().<span class="hljs-built_in">sum</span>() &gt; <span class="hljs-number">1</span>:<br>        X /= <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> X.<span class="hljs-built_in">sum</span>()<br></code></pre></div></td></tr></table></figure><p>那么我们可以随心所欲的在<code>forward</code>中实现我们复杂的数学计算，（只要数学公式是正确的）</p><h3 id="块与块的嵌套">2.1.3 块与块的嵌套</h3><p>我们可以使用<code>Sequential()</code>来简单连接不同的块，当然，使用一个大的块来进行更复杂网络设计也是可行的<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">chimera = nn.Sequential(NestMLP(), nn.Linear(<span class="hljs-number">16</span>,<span class="hljs-number">20</span>), FixedHiddenMLP())<br></code></pre></div></td></tr></table></figure></p><h3 id="不带参数的自定义层">2.1.4 不带参数的自定义层</h3><p>我们如果想要减去均值，那么可以有如下定义的层，它是一个不包含任何参数的层<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CenteredLayer</span>(nn.Module):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>    <span class="hljs-keyword">return</span> X - X.mean()<br></code></pre></div></td></tr></table></figure></p><h3 id="带参数的自定义层">2.1.5 带参数的自定义层</h3><p>同样，参数我们也可以自己来定义，定义方式如下，我们也可以通过forward来定义向前传播的计算方法<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinear</span>(nn.Module):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, in_units, units</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>        self.weight = nn.Parameter(torch.randn(in_units, units))<br>        self.bias = nn.Parameter(torch.randn(units,))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, X</span>):<br>    linear = torch.matmul(X,self.weight.data) + self.bias.data<br>        <span class="hljs-keyword">return</span> F.relu(linear)<br></code></pre></div></td></tr></table></figure></p><h2 id="块的参数管理">2.2 块的参数管理</h2><p>对于块的参数实际上是一个个张量，我只要访问到张量，通过张量的访问方式就能访问到参数。</p><h3 id="参数访问">2.2.1 参数访问</h3><p>当通过<code>Sequential</code>类定义模型时，我们可以通过索引来访问模型的任意层。这就像模型是一个列表一样，每层的参数都在其属性中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(net[<span class="hljs-number">2</span>].state_dict())<br></code></pre></div></td></tr></table></figure><p>注意，每个参数都表示为参数类的一个实例。要对参数执行任何操作，首先我们需要访问底层的数值。有几种方法可以做到这一点。有些比较简单，而另一些则比较通用。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(net[<span class="hljs-number">2</span>].bias))<br><span class="hljs-built_in">print</span>(net[<span class="hljs-number">2</span>].bias)<br><span class="hljs-built_in">print</span>(net[<span class="hljs-number">2</span>].bias.data)<br></code></pre></div></td></tr></table></figure><p>参数是复合的对象，包含值、梯度和额外信息。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net[<span class="hljs-number">2</span>].weight.grad==<span class="hljs-literal">None</span><br></code></pre></div></td></tr></table></figure><p>通过for-each可以方便的遍历所有参数 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(*[(name, param.shape)<span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net[<span class="hljs-number">0</span>].named_parameters()])<br><span class="hljs-built_in">print</span>(*[(name, param.shape)<span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> net.named_parameters()])<br></code></pre></div></td></tr></table></figure></p><p>输出： <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">(<span class="hljs-string">&#x27;weight&#x27;</span>, torch.Size([<span class="hljs-number">8</span>,<span class="hljs-number">4</span>])) (<span class="hljs-string">&#x27;bias&#x27;</span>, torch.Size([<span class="hljs-number">8</span>]))<br>(<span class="hljs-string">&#x27;0.weight&#x27;</span>, torch.Size([<span class="hljs-number">8</span>,<span class="hljs-number">4</span>])) (<span class="hljs-string">&#x27;0.bias&#x27;</span>, torch.Size([<span class="hljs-number">8</span>])) (<span class="hljs-string">&#x27;2.weight&#x27;</span>, torch.,Size([<span class="hljs-number">1</span>,<span class="hljs-number">8</span>])) (<span class="hljs-string">&#x27;2.bias&#x27;</span>, torch.Size([<span class="hljs-number">1</span>]))<br></code></pre></div></td></tr></table></figure></p><p>根据结果，我们不难得到一种新的访问方式 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net.state_dict()[<span class="hljs-string">&#x27;2.bias&#x27;</span>].data<br></code></pre></div></td></tr></table></figure></p><p>对于嵌套块的，可以像嵌套列表索引一样访问它们</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">rgnet[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].bias.data<br></code></pre></div></td></tr></table></figure><h3 id="参数初始化">2.2.2 参数初始化</h3><p>通过<code>net.apply(init_func)</code>的方法来初始化参数，如下所示</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_normal</span>(<span class="hljs-params">m</span>):<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(m) == nn.Linear:<br> nn.init.normal_(m.weight, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">0.01</span>)<br>        nn.init.zeros_(m.bias)<br>net.apply(init_normal)<br></code></pre></div></td></tr></table></figure><p>其中<code>.normal_()</code>与<code>.zero_()</code>与之前的创建张量的函数有着相同的作用。常用的内置初始化函数有</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">nn.init.normal_(m.weight, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">0.01</span>)<br>nn.init.uniform_(m.weight, -<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>nn.init.constant_(m.weight,<span class="hljs-number">1</span>)<br>nn.init.xavier_uniform_(m.weight)<br>nn.init.zeros_(m.bias)<br></code></pre></div></td></tr></table></figure><p>当然我们随时都可以直接访问每一层的每一个参数，那么我们能够在初始化函数中，写的一些比较复杂的初始化操作。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net[<span class="hljs-number">0</span>].weight.data[:]+=<span class="hljs-number">1</span><br>net[<span class="hljs-number">0</span>].weight.data[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=<span class="hljs-number">42</span><br>net[<span class="hljs-number">0</span>].weight.data[<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h1 id="文件读写">3. 文件读写</h1><p>有时我们希望保存训练的模型，以备将来在各种环境中使用，pytorch也提供了一系列方法用来保存数据。</p><h2 id="加载与保存张量">3.1 加载与保存张量</h2><p>对于单个张量，我们可以直接调用load和save函数分别读写它们。<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.arange(<span class="hljs-number">4</span>)<br>torch.save(x,<span class="hljs-string">&#x27;x-file&#x27;</span>)<br>x2 = torch.load(<span class="hljs-string">&#x27;x-file&#x27;</span>)<br></code></pre></div></td></tr></table></figure></p><p>存储词典，可以用来存储一些权重之类的信息 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">mydict = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: x,<span class="hljs-string">&#x27;y&#x27;</span>: y&#125;<br>torch.save(mydict,<span class="hljs-string">&#x27;mydict&#x27;</span>)<br>mydict2 = torch.load(<span class="hljs-string">&#x27;mydict&#x27;</span>)<br></code></pre></div></td></tr></table></figure></p><h2 id="加载与保存模型参数">3.2 加载与保存模型参数</h2><p>保存单个权重向量（或其他张量）确实有用，但是如果我们想保存整个模型，并在以后加载它们，单独保存每个向量则会变得很麻烦。毕竟，我们可能有数百个参数散布在各处。因此，pytorch提供了内置函数来保存和加载整个网络。需要注意的一个重要细节是，这将保存模型的参数而不是保存整个模型。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net = MLP()<br>torch.save(net.state_dict(),<span class="hljs-string">&#x27;mlp.params&#x27;</span>)<br><br>clone = MLP()<br>clone.load_state_dict(torch.load(<span class="hljs-string">&#x27;mlp.params&#x27;</span>))<br></code></pre></div></td></tr></table></figure><h1 id="gpu">4. GPU</h1><h2 id="获取计算设备">4.1 获取计算设备</h2><p>在pytorch中，CPU和GPU可以用<code>torch.device('cpu')</code>和<code>torch.device('cuda')</code>表示。应该注意的是，cpu设备意味着所有物理CPU和内存，这意味着pytorch的计算将尝试使用所有CPU核心。然而，gpu设备只代表一个卡和相应的显存。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>), torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>), torch.device(<span class="hljs-string">&#x27;cuda:1&#x27;</span>)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">(device(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;cpu&#x27;</span>), device(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;cuda&#x27;</span>), device(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;cuda&#x27;</span>, index=<span class="hljs-number">1</span>))<br></code></pre></div></td></tr></table></figure><p>我们还可一获取GPU设备的数量 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">torch.cuda.device_count()<br></code></pre></div></td></tr></table></figure></p><p>我们可以定义这样的函数来快速获取设备信息 <figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">deftry_gpu(i = <span class="hljs-number">0</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    如果存在，则返回gpu(i)，否则返回cpu()</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> torch.cuda.device_count() &gt;= i+<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> torch.device(<span class="hljs-string">f&#x27;cuda:<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_all_gpus</span>():<span class="hljs-comment">#@save</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    返回所有可用的GPU，如果没有GPU，则返回[cpu(),]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    devices = [torch.device(<span class="hljs-string">f&#x27;cuda:<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(torch.cuda.device_count())]<br>    <span class="hljs-keyword">return</span> devices <span class="hljs-keyword">if</span> devices <span class="hljs-keyword">else</span> [torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>)]<br></code></pre></div></td></tr></table></figure></p><h2 id="计算设备的选择">4.2 计算设备的选择</h2><p>对于张量，如果想使用GPU的话，在创建时可以添加参数<code>device=cuda:0</code>，那么将会在第一块GPU上创建这个张量</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">X = torch.ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, device=try_gpu()<br></code></pre></div></td></tr></table></figure><p>也可以通过复制的手段，将向量添加到另一块GPU上</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">Z = X.cuda(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>对于模型参数，可以通过<code>model.to(device='cuda:0')</code>来将整个参数放到GPU上</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net = nn.Sequential(nn.Linear(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br>net = net.to(device=try_gpu())<br></code></pre></div></td></tr></table></figure><h3 id="其他注意事项">4.3 其他注意事项</h3><p>深度学习框架要求计算的所有输入数据都在同一设备上，无论是CPU还是GPU。</p><p>不经意地移动数据可能会显著降低性能。一个典型的错误如下：计算GPU上每个小批量的损失，并在命令行中将其报告给用戶（或将其记录在NumPyndarray中）时，将触发全局解释器锁，从而使所有GPU阻塞。最好是为GPU内部的日志分配内存，并且只移动较大的日志。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>深度学习</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2022-03/Hello%20Hexo/"/>
    <url>/2022-03/Hello%20Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="hello-hexo">Hello Hexo</h1><p>突发奇想，想要自己搭建一个博客，在网上大多数人都说使用hexo会比较容易搭建，体验了一下雀食不错，所以就简单记录下配置过程，以及相关操作。</p><h2 id="hexo-安装">Hexo 安装</h2><p><ahref="https://hexo.io/zh-cn/index.html">Hexo(https://hexo.io/zh-cn/index.html)</a>的官网上记录了基本的安装与运行方式，这里就不在细说了。</p><h2 id="fluid-主题">fluid 主题</h2><p><a href="https://hexo.fluid-dev.com/docs/">fluid 主题文档</a>文档中也记录相关的配置资料，这个主题整体看起来比较简洁干净，是我比较喜欢的样式。</p><h3 id="主题安装">主题安装</h3><p>在hexo项目的目录下执行指令,来通过node包管理安装主题</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">yarn add --save hexo-theme-fluid<br><span class="hljs-comment"># or</span><br>npm install --save hexo-theme-fluid<br></code></pre></div></td></tr></table></figure><p>然后在<code>_config.yml</code>中将<code>theme: landscape</code> 改为<code>theme: fluid</code>在启动hexo就能看到使用fluid主题的博客页面了。</p><h3 id="主题配置">主题配置</h3><p>这个就跟着文档，按需修改配置好了，我这里开启了Latex数学公式支持，修改了壁纸，其他除了改点博客信息好像也没干什么，就不记录了。</p><h2 id="hexo-操作">Hexo 操作</h2><h3 id="hexo-新建文档">Hexo 新建文档</h3><p>执行指令 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo new post post_name<br></code></pre></div></td></tr></table></figure>这样子可以新建一篇博客，会在<code>source</code>目录下生成一个<code>post_name.md</code>的markdown文件，博客内容就可以写在生成的markdown文件中。</p><h3 id="hexo-页面生成">Hexo 页面生成</h3><p>执行指令 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo generate<br></code></pre></div></td></tr></table></figure>在hexo项目中<code>public</code>目录下会生成编译得到<code>html</code>文件，确定生成的文件展示效果与运行hexo展示一致后(可以用<code>vscode</code>的<code>live server</code>插件来测试一下)，再将其文件部署到有page服务的代码仓库，如<code>github</code>就相当于将网站发布到互联网上了。</p><h3 id="hexo-自动部署">Hexo 自动部署</h3><p>刚才说的将<code>public</code>中的内容部署到<code>github</code>或其他仓库的这一步操作也是可以自动完成的，需要进行一下配置。文档中也有关于一键部署的介绍<ahref="https://hexo.io/docs/one-command-deployment">one-command-deployment</a></p><ol type="1"><li><p>提交本地公钥</p><p>通过指令 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">ssh-keygen -t rsa -C <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></div></td></tr></table></figure>将生成在<code>.ssh</code>目录下的<code>id_rsa.pub</code>文件内容添加到<code>github</code>的<code>SSH keys</code>中,然后执行<figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">ssh -T git@github.com<br></code></pre></div></td></tr></table></figure>如果显示<code>Hi XXXXX! You've successfully authenticated,...</code>则添加成功</p></li><li><p>创建<code>github page</code>仓库,<ahref="https://pages.github.com/">功能介绍</a></p></li><li><p>安装<code>hexo-deployer-git</code>工具 <figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">yarn add hexo-deployer-git<br></code></pre></div></td></tr></table></figure></p></li><li><p>修改<code>_config.yml</code>的<code>deploy</code>中的内容<figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:xxxx/xxxx.github.io.git</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure>云服务器的仓库也是一样的流程，配置好ssh就能实现指令部署了，可以参考这篇文章<ahref="https://blog.csdn.net/pandasunwukong/article/details/103515014">ubuntu部署hexo博客</a>。</p><p>值得注意的时，我的服务器默认关闭22端口，所以地址需要写成<code>ssh://username@ip:port/path/to/repo</code>，这样子执行上传指令时就可以指定端口了。</p></li><li><p>然后执行<code>hexo deploy</code>就可一键部署内容了。</p></li></ol><h2 id="其他">其他</h2><h3 id="部署清理">部署清理</h3><p>每一次部署博客时，最好清理重新生成后推送，不然可能有一堆乱七八糟的麻烦。<figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></div></td></tr></table></figure></p><h3 id="动态更新">动态更新</h3><p>安装组件<code>hexo-browsersync</code>后执行<code>hexo s</code>，在更新markdown文档时，自动重新生成网页，不需要重启服务。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
